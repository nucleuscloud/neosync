package main

import (
	"fmt"
	"os"
	"sort"
	"strings"
)

/*
This script is used by go generate (see generators.go)
For a given text file, it will output a generated go file that includes the following:
 1. a values string slice that is sorted by length, then alphabet.
 2. a map that is computed based on the values. Key: length, Value: two int tuple of the range in the values slice
    where strings of that length can be found. If there are three values of length two, and two is the smallest string found,
    the value in the map would be: 2: {0, 3}
 3. an int slice that is a sorted list of keys from the map. This is effectively a discrete, sorted slice of the
    lengths that are available for generation
*/
func main() {
	args := os.Args
	if len(args) < 4 {
		panic("must provide necessary args")
	}

	datasetFile := args[1]
	gotypename := args[2]
	gopackage := args[3]

	outputFile, err := os.Create(fmt.Sprintf("%s_gen.go", strings.ToLower(gotypename)))
	if err != nil {
		panic(err)
	}
	defer outputFile.Close()

	_, err = outputFile.WriteString(fmt.Sprintf("// Code generated by Neosync datagenerator. DO NOT EDIT.\n// source: %s\n\n", datasetFile))
	if err != nil {
		panic(err)
	}

	_, err = outputFile.WriteString(fmt.Sprintf("package %s\n\n", gopackage))
	if err != nil {
		panic(err)
	}

	_, err = outputFile.WriteString(fmt.Sprintf("var %ss = []string{\n", gotypename))
	if err != nil {
		panic(err)
	}

	content, err := os.ReadFile(datasetFile)
	if err != nil {
		panic(err)
	}

	text := string(content)
	lines := strings.Split(text, "\n")
	sort.Slice(lines, func(i, j int) bool {
		if len(lines[i]) == len(lines[j]) {
			return lines[i] < lines[j] // Alphabetical order if lengths are equal
		}
		return len(lines[i]) < len(lines[j]) // Otherwise, order by length
	})

	filteredLines := []string{}

	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if len(trimmedLine) == 0 || strings.ContainsAny(trimmedLine, "-_") {
			continue
		}
		filteredLines = append(filteredLines, line)
		_, err = outputFile.WriteString(fmt.Sprintf("\t%q,\n", trimmedLine)) // Each line as a quoted string in the slice
		if err != nil {
			panic(err)
		}
	}

	// Close the slice declaration
	_, err = outputFile.WriteString("}\n\n")
	if err != nil {
		panic(err)
	}

	lengthIndicesMap := createLengthMap(filteredLines)
	sortedLengthIdxKeys := getSortedMapKeys(lengthIndicesMap)
	_, err = outputFile.WriteString(fmt.Sprintf("var %sMap = map[int64][2]int{\n", gotypename))
	if err != nil {
		panic(err)
	}

	for _, idx := range sortedLengthIdxKeys {
		subLines, ok := lengthIndicesMap[idx]
		// shouldn't hit this, but just being safe
		if !ok {
			continue
		}
		_, err = outputFile.WriteString(fmt.Sprintf("\t%d: {%d, %d},\n", idx, subLines[0], subLines[1]))
		if err != nil {
			panic(err)
		}
	}
	_, err = outputFile.WriteString("}\n\n")
	if err != nil {
		panic(err)
	}

	_, err = outputFile.WriteString(fmt.Sprintf("var %sIndices = []int64{\n", gotypename))
	if err != nil {
		panic(err)
	}
	for _, idx := range sortedLengthIdxKeys {
		_, err = outputFile.WriteString(fmt.Sprintf("\t%d,\n", idx))
	}
	_, err = outputFile.WriteString("}\n")
	if err != nil {
		panic(err)
	}
}

func createLengthMap(lines []string) map[int][2]int {
	lengthMap := make(map[int][2]int)

	for i, line := range lines {
		length := len(line)
		if _, exists := lengthMap[length]; exists {
			// We've seen this length before, so just update the end index.
			entry := lengthMap[length]
			entry[1] = i // Update end index
			lengthMap[length] = entry
		} else {
			// This is the first time we've seen this length,
			// so set the start and end index to the current index.
			lengthMap[length] = [2]int{i, i}
		}
	}
	return lengthMap
}

func getSortedMapKeys[T any](input map[int]T) []int {
	output := make([]int, 0, len(input))

	for key := range input {
		output = append(output, key)
	}
	sort.Ints(output)
	return output
}
