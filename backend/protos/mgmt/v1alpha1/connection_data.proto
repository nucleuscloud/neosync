syntax = "proto3";

package mgmt.v1alpha1;

import "buf/validate/validate.proto";
import "google/protobuf/struct.proto";

message PostgresStreamConfig {}
message MysqlStreamConfig {}
message AwsDynamoDBStreamConfig {}
message AwsS3StreamConfig {
  oneof id {
    // The unique identifier of the job to get the data stream for.
    string job_id = 1 [(buf.validate.field).string.uuid = true];
    // The unique identifier of the job run to get the data stream for.
    string job_run_id = 2 [(buf.validate.field).string.min_len = 1];
  }
}
message GcpCloudStorageStreamConfig {
  oneof id {
    // The unique identifier of the job to get the data stream for.
    string job_id = 1 [(buf.validate.field).string.uuid = true];
    // The unique identifier of the job run to get the data stream for.
    string job_run_id = 2 [(buf.validate.field).string.min_len = 1];
  }
}

message ConnectionStreamConfig {
  oneof config {
    option (buf.validate.oneof).required = true;

    PostgresStreamConfig pg_config = 1;
    AwsS3StreamConfig aws_s3_config = 2;
    MysqlStreamConfig mysql_config = 3;
    GcpCloudStorageStreamConfig gcp_cloudstorage_config = 4;
    AwsDynamoDBStreamConfig dynamodb_config = 5;
  }
}

message GetConnectionDataStreamRequest {
  // The unique identifier of the connection to get the data stream for.
  string connection_id = 1 [(buf.validate.field).string.uuid = true];
  // The stream configuration to use for the data stream.
  ConnectionStreamConfig stream_config = 2;
  // The schema of the table to get the data stream for.
  string schema = 3;
  // The table to get the data stream for.
  string table = 4;
}

// Each stream response is a single row in the requested schema and table
message GetConnectionDataStreamResponse {
  reserved 1; // Was: map<string, bytes> row = 1;
  // A map of column name to column value, where the value is serialized as bytes. The value represents a map[string]any structure.
  bytes row_bytes = 2;
}

message PostgresSchemaConfig {}
message MysqlSchemaConfig {}
message MssqlSchemaConfig {}
message AwsS3SchemaConfig {
  oneof id {
    // The unique identifier of the job to get the schema for.
    string job_id = 1 [(buf.validate.field).string.uuid = true];
    // The unique identifier of the job run to get the schema for.
    string job_run_id = 2 [(buf.validate.field).string.min_len = 1];
  }
}
message MongoSchemaConfig {}
message DynamoDBSchemaConfig {}
message GcpCloudStorageSchemaConfig {
  oneof id {
    // The unique identifier of the job to get the schema for.
    string job_id = 1 [(buf.validate.field).string.uuid = true];
    // The unique identifier of the job run to get the schema for.
    string job_run_id = 2 [(buf.validate.field).string.min_len = 1];
  }
}

message ConnectionSchemaConfig {
  oneof config {
    option (buf.validate.oneof).required = true;

    PostgresSchemaConfig pg_config = 1;
    AwsS3SchemaConfig aws_s3_config = 2;
    MysqlSchemaConfig mysql_config = 3;
    MongoSchemaConfig mongo_config = 4;
    GcpCloudStorageSchemaConfig gcp_cloudstorage_config = 5;
    DynamoDBSchemaConfig dynamodb_config = 6;
    MssqlSchemaConfig mssql_config = 7;
  }
}

message DatabaseColumn {
  // The database schema. Ex: public
  string schema = 1;
  // The name of the table in the schema
  string table = 2;
  // The name of the column
  string column = 3;
  // The datatype of the column
  string data_type = 4;
  // The isNullable Flag of the column
  string is_nullable = 5;
  // The default value of the column if available
  optional string column_default = 6;
  // Populated if the column is generated. The value is the type of generated column it is. For example, postgres is 's' for stored
  // May be other values in the future, or other DB providers may use a different value types.
  optional string generated_type = 7;
  // Populated if the column is an identity. The value is the type of the identity column it is. For example, postgres is 'd' for generated by default, or 'a' for generated always.
  optional string identity_generation = 8;
}

message GetConnectionSchemaRequest {
  // The unique identifier of the connection to get the schema for.
  string connection_id = 1 [(buf.validate.field).string.uuid = true];
  // The schema configuration to use for the schema map.
  ConnectionSchemaConfig schema_config = 2;
}

message GetConnectionSchemaResponse {
  // The list of database columns
  repeated DatabaseColumn schemas = 1;
}

message GetConnectionSchemaMapRequest {
  // The unique identifier of the connection to get the schema map for.
  string connection_id = 1 [(buf.validate.field).string.uuid = true];
  // The schema configuration to use for the schema map.
  ConnectionSchemaConfig schema_config = 2;
}

message GetConnectionSchemaMapResponse {
  // Returns the database columns separated by the fully qualified <schema>.<table>
  map<string, GetConnectionSchemaResponse> schema_map = 1;
}

message GetConnectionSchemaMapsRequest {
  // List of connection schema maps to request
  repeated GetConnectionSchemaMapRequest requests = 1;
}

message GetConnectionSchemaMapsResponse {
  // List of responses in the same order as the input
  repeated GetConnectionSchemaMapResponse responses = 1;
  // Parallel array of each connection id that matches with the response
  repeated string connection_ids = 2;
}

message ForeignKey {
  // The table that the foreign key is associated with
  string table = 1;
  reserved 2; // Was: string column = 2;
  // The columns that are part of the foreign key
  repeated string columns = 3;
}

message ForeignConstraint {
  reserved 1; // Was: string column = 1;
  reserved 2; // Was: bool is_nullable = 2;
  // The foreign key that is associated with the constraint
  ForeignKey foreign_key = 3;
  // The columns that are part of the constraint
  repeated string columns = 4;
  // The not nullable flag for each column
  repeated bool not_nullable = 5;
}

message ForeignConstraintTables {
  // A list of foreign key constraints
  repeated ForeignConstraint constraints = 1;
}

message InitStatementOptions {
  // Whether or not to generate schema init statements.
  bool init_schema = 1;
  // Whether or not to generate truncation statements
  bool truncate_before_insert = 2;
  // Whether or not to generate truncate cascade statements.
  bool truncate_cascade = 3;
}
message GetConnectionInitStatementsRequest {
  // The unique identifier of the connection to get the init statements for.
  string connection_id = 1 [(buf.validate.field).string.uuid = true];
  // The options to use for the init statements.
  InitStatementOptions options = 2;
}

message SchemaInitStatements {
  // A friendly label associated with the generated schema init statement(s)
  string label = 1;
  // A list of SQL statements that may be used to initialize a database from scratch.
  repeated string statements = 2;
}

// Init statement for a specific table
message GetConnectionInitStatementsResponse {
  // @deprecated - Use schema_init_statements instead
  map<string, string> table_init_statements = 1 [deprecated = true];
  // The key here is <schema>.<table> and value is the table truncate statement.
  map<string, string> table_truncate_statements = 2;
  // A list of schema initialization statements
  repeated SchemaInitStatements schema_init_statements = 3;
}

message PrimaryConstraint {
  // The columns that are part of the primary constraint
  repeated string columns = 1;
}

message UniqueConstraint {
  // The columns that are part of the unique constraint
  repeated string columns = 1;
}

message GetAiGeneratedDataRequest {
  // The unique identifier of a connection, specifically one that is configured for LLM use.
  string ai_connection_id = 1 [(buf.validate.field).string.uuid = true];
  // The number of records to generate
  int64 count = 2 [
    (buf.validate.field).int64.gte = 1,
    (buf.validate.field).int64.lte = 10
  ];
  // The LLM model name to use that works with the configured connection id.
  string model_name = 3 [(buf.validate.field).string.min_len = 1];
  // The prompt that will be used to further refine the data generation. This is appended to the prompt that Neosync generates that includes schema information.
  optional string user_prompt = 4;
  // The unique identifier of a connection that the AI generated data would be inserted into. This is used to generate and send schema information to the LLM to help shape the generated data.
  string data_connection_id = 5 [(buf.validate.field).string.uuid = true];
  // The table to generate data for.
  DatabaseTable table = 6;
}

message DatabaseTable {
  // The schema of the table
  string schema = 1 [(buf.validate.field).string.min_len = 1];
  // The table name
  string table = 2 [(buf.validate.field).string.min_len = 1];
}

message GetAiGeneratedDataResponse {
  // A list of generated records
  repeated google.protobuf.Struct records = 1;
}

message GetConnectionTableConstraintsRequest {
  // The unique identifier of the connection to get the constraints for.
  string connection_id = 1 [(buf.validate.field).string.uuid = true];
}

message UniqueConstraints {
  // The unique constraints found for the table
  repeated UniqueConstraint constraints = 1;
}

message GetConnectionTableConstraintsResponse {
  // the key here is <schema>.<table> and the list of tables that it depends on, also `<schema>.<table>` format.
  map<string, ForeignConstraintTables> foreign_key_constraints = 1;
  // the key here is <schema>.<table> and value is the primary constraint
  map<string, PrimaryConstraint> primary_key_constraints = 2;
  // the key here is <schema>.<table> and value is the unique constraint
  map<string, UniqueConstraints> unique_constraints = 3;
}

message GetTableRowCountRequest {
  // The unique identifier of the connection to get the row count for.
  string connection_id = 1 [(buf.validate.field).string.uuid = true];
  // The schema of the table to get the row count for.
  string schema = 2 [(buf.validate.field).string.min_len = 1];
  // The table to get the row count for.
  string table = 3 [(buf.validate.field).string.min_len = 1];
  // The optional where clause to filter the rows by.
  optional string where_clause = 4;
}

message GetTableRowCountResponse {
  // The count of the rows in the table
  int64 count = 1;
}

// Service for managing connection data.
// This is used in handle data from a connection
service ConnectionDataService {
  // Streaming endpoint that will stream the data available from the Connection to the client.
  // Used primarily by the CLI sync command.
  rpc GetConnectionDataStream(GetConnectionDataStreamRequest) returns (stream GetConnectionDataStreamResponse) {}
  // Returns the schema for a specific connection. Used mostly for SQL-based connections
  rpc GetConnectionSchema(GetConnectionSchemaRequest) returns (GetConnectionSchemaResponse) {}
  // Returns the schema in map format. The keys are the fully qualified table in the format <schema>.<table>
  rpc GetConnectionSchemaMap(GetConnectionSchemaMapRequest) returns (GetConnectionSchemaMapResponse) {}
  // Returns the schema in map format for every request provided
  rpc GetConnectionSchemaMaps(GetConnectionSchemaMapsRequest) returns (GetConnectionSchemaMapsResponse) {}
  // For a specific connection, returns the table constraints. Mostly useful for SQL-based Connections.
  rpc GetConnectionTableConstraints(GetConnectionTableConstraintsRequest) returns (GetConnectionTableConstraintsResponse) {}
  // For a specific connection, returns the init table statements. Mostly useful for SQL-based Connections.
  // Used primarily by the CLI sync command to create table schema init statement.
  rpc GetConnectionInitStatements(GetConnectionInitStatementsRequest) returns (GetConnectionInitStatementsResponse) {}
  // Query an AI connection by providing the necessary values. Typically used for generating preview data
  rpc GetAiGeneratedData(GetAiGeneratedDataRequest) returns (GetAiGeneratedDataResponse) {}
  // Query table with subset to get row count
  rpc GetTableRowCount(GetTableRowCountRequest) returns (GetTableRowCountResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}
