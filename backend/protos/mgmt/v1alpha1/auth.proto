syntax = "proto3";

package mgmt.v1alpha1;

import "buf/validate/validate.proto";

// message RefreshAccessTokenRequest {
//   string refresh_token = 1 [(buf.validate.field).string.min_len = 1];
//   optional string client_id = 2 [(buf.validate.field).string.min_len = 1];
// }

// message RefreshAccessTokenResponse {
//   string access_token = 1;
//   string refresh_token = 2;
//   int64 expires_in = 3;
//   string scope = 4;
//   string id_token = 5;
//   string token_type = 6;
// }

// message GetAccessTokenRequest {
//   string code = 1 [(buf.validate.field).string.min_len = 1];
//   optional string client_id = 2 [(buf.validate.field).string.min_len = 1];
//   optional string redirect_uri = 3 [(buf.validate.field).string.min_len = 1];
// }

// message GetAccessTokenResponse {
//   string access_token = 1;
//   string refresh_token = 2;
//   int64 expires_in = 3;
//   string scope = 4;
//   string id_token = 5;
//   string token_type = 6;
// }

message LoginCliRequest {
  // The oauth code
  string code = 1 [(buf.validate.field).string.min_len = 1];
  // The oauth redirect uri that the client uses during the oauth request
  string redirect_uri = 2 [(buf.validate.field).string.min_len = 1];
}
message LoginCliResponse {
  // The access token that is returned on successful login
  AccessToken access_token = 1;
}

message GetAuthStatusRequest {}
message GetAuthStatusResponse {
  // Whether or not the server has authentication enabled.
  // This tells the client if it is expected to send access tokens.
  bool is_enabled = 1;
}

// A decoded representation of an Access token from the backing auth server
message AccessToken {
  string access_token = 1;
  optional string refresh_token = 2;
  int64 expires_in = 3;
  string scope = 4;
  optional string id_token = 5;
  string token_type = 6;
}

message GetAuthorizeUrlRequest {
  // The state that's generated by the client that is passed along to prevent tampering
  string state = 1 [(buf.validate.field).string.min_len = 1];
  // The redirect uri that the client will be redirected back to during the auth request
  string redirect_uri = 2 [(buf.validate.field).string.min_len = 1];
  // The scopes the client is requesting as a part of the oauth login request
  string scope = 3 [(buf.validate.field).string.min_len = 1];
}
message GetAuthorizeUrlResponse {
  // The generated url that is the client will be redirected to during the Oauth flow
  string url = 1;
}

message GetCliIssuerRequest {}
message GetCliIssuerResponse {
  // The backing authentication issuer url
  string issuer_url = 1;
  // The audience that will be used in the access token. This corresponds to the "aud" claim
  string audience = 2;
}

// Service that handles generic Authentication for Neosync
// Today this is mostly used by the CLI to receive authentication information
service AuthService {
  // Used by the CLI to login to Neosync with OAuth.
  rpc LoginCli(LoginCliRequest) returns (LoginCliResponse) {}
  // Used by the CLI to retrieve Auth Issuer information
  rpc GetCliIssuer(GetCliIssuerRequest) returns (GetCliIssuerResponse) {}
  // Used by the CLI to retrieve an Authorize URL for use with OAuth login.
  rpc GetAuthorizeUrl(GetAuthorizeUrlRequest) returns (GetAuthorizeUrlResponse) {}
  // rpc GetAccessToken(GetAccessTokenRequest) returns (GetAccessTokenResponse) {}
  // rpc RefreshAccessToken(RefreshAccessTokenRequest) returns (RefreshAccessTokenResponse) {}

  // Returns the auth status of the API server. Whether or not the backend has authentication enabled.
  // This is used by clients to make decisions on whether or not they should send access tokens to the API.
  rpc GetAuthStatus(GetAuthStatusRequest) returns (GetAuthStatusResponse) {}
}
