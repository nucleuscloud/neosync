syntax = "proto3";

package mgmt.v1alpha1;

import "buf/validate/validate.proto";

message LoginCliRequest {
  // The oauth code
  string code = 1 [(buf.validate.field).string.min_len = 1];
  // The oauth redirect uri that the client uses during the oauth request
  string redirect_uri = 2 [(buf.validate.field).string.min_len = 1];
}
message LoginCliResponse {
  // The access token that is returned on successful login
  AccessToken access_token = 1;
}

message GetAuthStatusRequest {}
message GetAuthStatusResponse {
  // Whether or not the server has authentication enabled.
  // This tells the client if it is expected to send access tokens.
  bool is_enabled = 1;
}

// A decoded representation of an Access token from the backing auth server
message AccessToken {
  // The access token that will be provided in subsequent requests to provide authenticated access to the Api
  string access_token = 1;
  // Token that can be used to retrieve a refreshed access token.
  // Will not be provided if the offline_access scope is not provided in the initial login flow.
  optional string refresh_token = 2;
  // Relative time in seconds that the access token will expire. Combine with the current time to get the expires_at time.
  int64 expires_in = 3;
  // The scopes that the access token have
  string scope = 4;
  // The identity token of the authenticated user
  optional string id_token = 5;
  // The token type. For JWTs, this will be `Bearer`
  string token_type = 6;
}

message GetAuthorizeUrlRequest {
  // The state that's generated by the client that is passed along to prevent tampering
  string state = 1 [(buf.validate.field).string.min_len = 1];
  // The redirect uri that the client will be redirected back to during the auth request
  string redirect_uri = 2 [(buf.validate.field).string.min_len = 1];
  // The scopes the client is requesting as a part of the oauth login request
  string scope = 3 [(buf.validate.field).string.min_len = 1];
}
message GetAuthorizeUrlResponse {
  // The generated url that is the client will be redirected to during the Oauth flow
  string url = 1;
}

message RefreshCliRequest {
  // The token used to retrieve a new access token.
  string refresh_token = 1 [(buf.validate.field).string.min_len = 1];
}
message RefreshCliResponse {
  // The access token that is returned on successful refresh
  AccessToken access_token = 1;
}

message CheckTokenRequest {}
message CheckTokenResponse {}

// Service that handles generic Authentication for Neosync
// Today this is mostly used by the CLI to receive authentication information
service AuthService {
  // Used by the CLI to login to Neosync with OAuth.
  rpc LoginCli(LoginCliRequest) returns (LoginCliResponse) {}
  // Used by the CLI to refresh an expired Neosync accesss token.
  // This should only be used if an access token was previously retrieved from the `LoginCli` or `RefreshCli` methods.
  rpc RefreshCli(RefreshCliRequest) returns (RefreshCliResponse) {}
  // Empty endpoint to simply check if the provided access token is valid
  rpc CheckToken(CheckTokenRequest) returns (CheckTokenResponse) {}

  // Used by the CLI to retrieve an Authorize URL for use with OAuth login.
  rpc GetAuthorizeUrl(GetAuthorizeUrlRequest) returns (GetAuthorizeUrlResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Returns the auth status of the API server. Whether or not the backend has authentication enabled.
  // This is used by clients to make decisions on whether or not they should send access tokens to the API.
  rpc GetAuthStatus(GetAuthStatusRequest) returns (GetAuthStatusResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}
