// @generated by protoc-gen-es v1.9.0 with parameter "target=ts,import_extension=.js"
// @generated from file mgmt/v1alpha1/connection.proto (package mgmt.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from message mgmt.v1alpha1.GetConnectionsRequest
 */
export class GetConnectionsRequest extends Message<GetConnectionsRequest> {
  /**
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  constructor(data?: PartialMessage<GetConnectionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionsRequest {
    return new GetConnectionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionsRequest {
    return new GetConnectionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionsRequest {
    return new GetConnectionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionsRequest | PlainMessage<GetConnectionsRequest> | undefined, b: GetConnectionsRequest | PlainMessage<GetConnectionsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionsResponse
 */
export class GetConnectionsResponse extends Message<GetConnectionsResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.Connection connections = 1;
   */
  connections: Connection[] = [];

  constructor(data?: PartialMessage<GetConnectionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connections", kind: "message", T: Connection, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionsResponse {
    return new GetConnectionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionsResponse {
    return new GetConnectionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionsResponse {
    return new GetConnectionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionsResponse | PlainMessage<GetConnectionsResponse> | undefined, b: GetConnectionsResponse | PlainMessage<GetConnectionsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionRequest
 */
export class GetConnectionRequest extends Message<GetConnectionRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionRequest {
    return new GetConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionRequest {
    return new GetConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionRequest {
    return new GetConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionRequest | PlainMessage<GetConnectionRequest> | undefined, b: GetConnectionRequest | PlainMessage<GetConnectionRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionResponse
 */
export class GetConnectionResponse extends Message<GetConnectionResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;

  constructor(data?: PartialMessage<GetConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection", kind: "message", T: Connection },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionResponse {
    return new GetConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionResponse {
    return new GetConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionResponse {
    return new GetConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionResponse | PlainMessage<GetConnectionResponse> | undefined, b: GetConnectionResponse | PlainMessage<GetConnectionResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateConnectionRequest
 */
export class CreateConnectionRequest extends Message<CreateConnectionRequest> {
  /**
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * The friendly name of the connection
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;

  constructor(data?: PartialMessage<CreateConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "connection_config", kind: "message", T: ConnectionConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateConnectionRequest {
    return new CreateConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateConnectionRequest {
    return new CreateConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateConnectionRequest {
    return new CreateConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateConnectionRequest | PlainMessage<CreateConnectionRequest> | undefined, b: CreateConnectionRequest | PlainMessage<CreateConnectionRequest> | undefined): boolean {
    return proto3.util.equals(CreateConnectionRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateConnectionResponse
 */
export class CreateConnectionResponse extends Message<CreateConnectionResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;

  constructor(data?: PartialMessage<CreateConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection", kind: "message", T: Connection },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateConnectionResponse {
    return new CreateConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateConnectionResponse {
    return new CreateConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateConnectionResponse {
    return new CreateConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateConnectionResponse | PlainMessage<CreateConnectionResponse> | undefined, b: CreateConnectionResponse | PlainMessage<CreateConnectionResponse> | undefined): boolean {
    return proto3.util.equals(CreateConnectionResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateConnectionRequest
 */
export class UpdateConnectionRequest extends Message<UpdateConnectionRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;

  constructor(data?: PartialMessage<UpdateConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "connection_config", kind: "message", T: ConnectionConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateConnectionRequest {
    return new UpdateConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateConnectionRequest {
    return new UpdateConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateConnectionRequest {
    return new UpdateConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateConnectionRequest | PlainMessage<UpdateConnectionRequest> | undefined, b: UpdateConnectionRequest | PlainMessage<UpdateConnectionRequest> | undefined): boolean {
    return proto3.util.equals(UpdateConnectionRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateConnectionResponse
 */
export class UpdateConnectionResponse extends Message<UpdateConnectionResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;

  constructor(data?: PartialMessage<UpdateConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection", kind: "message", T: Connection },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateConnectionResponse {
    return new UpdateConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateConnectionResponse {
    return new UpdateConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateConnectionResponse {
    return new UpdateConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateConnectionResponse | PlainMessage<UpdateConnectionResponse> | undefined, b: UpdateConnectionResponse | PlainMessage<UpdateConnectionResponse> | undefined): boolean {
    return proto3.util.equals(UpdateConnectionResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteConnectionRequest
 */
export class DeleteConnectionRequest extends Message<DeleteConnectionRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteConnectionRequest {
    return new DeleteConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteConnectionRequest {
    return new DeleteConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteConnectionRequest {
    return new DeleteConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteConnectionRequest | PlainMessage<DeleteConnectionRequest> | undefined, b: DeleteConnectionRequest | PlainMessage<DeleteConnectionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteConnectionRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteConnectionResponse
 */
export class DeleteConnectionResponse extends Message<DeleteConnectionResponse> {
  constructor(data?: PartialMessage<DeleteConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteConnectionResponse {
    return new DeleteConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteConnectionResponse {
    return new DeleteConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteConnectionResponse {
    return new DeleteConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteConnectionResponse | PlainMessage<DeleteConnectionResponse> | undefined, b: DeleteConnectionResponse | PlainMessage<DeleteConnectionResponse> | undefined): boolean {
    return proto3.util.equals(DeleteConnectionResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigRequest
 */
export class CheckConnectionConfigRequest extends Message<CheckConnectionConfigRequest> {
  /**
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 1;
   */
  connectionConfig?: ConnectionConfig;

  constructor(data?: PartialMessage<CheckConnectionConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CheckConnectionConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_config", kind: "message", T: ConnectionConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckConnectionConfigRequest {
    return new CheckConnectionConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckConnectionConfigRequest {
    return new CheckConnectionConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckConnectionConfigRequest {
    return new CheckConnectionConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckConnectionConfigRequest | PlainMessage<CheckConnectionConfigRequest> | undefined, b: CheckConnectionConfigRequest | PlainMessage<CheckConnectionConfigRequest> | undefined): boolean {
    return proto3.util.equals(CheckConnectionConfigRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigResponse
 */
export class CheckConnectionConfigResponse extends Message<CheckConnectionConfigResponse> {
  /**
   * Whether or not the API was able to ping the connection
   *
   * @generated from field: bool is_connected = 1;
   */
  isConnected = false;

  /**
   * This is the error that was received if the API was unable to connect
   *
   * @generated from field: optional string connection_error = 2;
   */
  connectionError?: string;

  /**
   * @generated from field: repeated mgmt.v1alpha1.ConnectionRolePrivilege privileges = 3;
   */
  privileges: ConnectionRolePrivilege[] = [];

  constructor(data?: PartialMessage<CheckConnectionConfigResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CheckConnectionConfigResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_connected", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "connection_error", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "privileges", kind: "message", T: ConnectionRolePrivilege, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckConnectionConfigResponse {
    return new CheckConnectionConfigResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckConnectionConfigResponse {
    return new CheckConnectionConfigResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckConnectionConfigResponse {
    return new CheckConnectionConfigResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckConnectionConfigResponse | PlainMessage<CheckConnectionConfigResponse> | undefined, b: CheckConnectionConfigResponse | PlainMessage<CheckConnectionConfigResponse> | undefined): boolean {
    return proto3.util.equals(CheckConnectionConfigResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ConnectionRolePrivilege
 */
export class ConnectionRolePrivilege extends Message<ConnectionRolePrivilege> {
  /**
   * The role that was given the permissions
   *
   * @generated from field: string grantee = 1;
   */
  grantee = "";

  /**
   * The database schema. Ex: public
   *
   * @generated from field: string schema = 2;
   */
  schema = "";

  /**
   * The name of the table in the schema
   *
   * @generated from field: string table = 3;
   */
  table = "";

  /**
   * The privileges given to that role
   *
   * @generated from field: repeated string privilege_type = 4;
   */
  privilegeType: string[] = [];

  constructor(data?: PartialMessage<ConnectionRolePrivilege>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ConnectionRolePrivilege";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "grantee", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "privilege_type", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionRolePrivilege {
    return new ConnectionRolePrivilege().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionRolePrivilege {
    return new ConnectionRolePrivilege().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionRolePrivilege {
    return new ConnectionRolePrivilege().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionRolePrivilege | PlainMessage<ConnectionRolePrivilege> | undefined, b: ConnectionRolePrivilege | PlainMessage<ConnectionRolePrivilege> | undefined): boolean {
    return proto3.util.equals(ConnectionRolePrivilege, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.Connection
 */
export class Connection extends Message<Connection> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;

  /**
   * @generated from field: string created_by_user_id = 4;
   */
  createdByUserId = "";

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: string updated_by_user_id = 6;
   */
  updatedByUserId = "";

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 7;
   */
  updatedAt?: Timestamp;

  /**
   * @generated from field: string account_id = 8;
   */
  accountId = "";

  constructor(data?: PartialMessage<Connection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.Connection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "connection_config", kind: "message", T: ConnectionConfig },
    { no: 4, name: "created_by_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "created_at", kind: "message", T: Timestamp },
    { no: 6, name: "updated_by_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "updated_at", kind: "message", T: Timestamp },
    { no: 8, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Connection {
    return new Connection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Connection {
    return new Connection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Connection {
    return new Connection().fromJsonString(jsonString, options);
  }

  static equals(a: Connection | PlainMessage<Connection> | undefined, b: Connection | PlainMessage<Connection> | undefined): boolean {
    return proto3.util.equals(Connection, a, b);
  }
}

/**
 * Configuration for all of the supported Neosync connection types
 *
 * @generated from message mgmt.v1alpha1.ConnectionConfig
 */
export class ConnectionConfig extends Message<ConnectionConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.ConnectionConfig.config
   */
  config: {
    /**
     * Configures a PostgreSQL connection
     *
     * @generated from field: mgmt.v1alpha1.PostgresConnectionConfig pg_config = 1;
     */
    value: PostgresConnectionConfig;
    case: "pgConfig";
  } | {
    /**
     * Configures an AWS S3 Connection
     *
     * @generated from field: mgmt.v1alpha1.AwsS3ConnectionConfig aws_s3_config = 2;
     */
    value: AwsS3ConnectionConfig;
    case: "awsS3Config";
  } | {
    /**
     * Configures a MySQL connection
     *
     * @generated from field: mgmt.v1alpha1.MysqlConnectionConfig mysql_config = 3;
     */
    value: MysqlConnectionConfig;
    case: "mysqlConfig";
  } | {
    /**
     * Configures a connection to a directory available on the local file system
     *
     * @generated from field: mgmt.v1alpha1.LocalDirectoryConnectionConfig local_dir_config = 4;
     */
    value: LocalDirectoryConnectionConfig;
    case: "localDirConfig";
  } | {
    /**
     * Connection config for an OpenAI (or compatible) Connection
     *
     * @generated from field: mgmt.v1alpha1.OpenAiConnectionConfig openai_config = 5;
     */
    value: OpenAiConnectionConfig;
    case: "openaiConfig";
  } | {
    /**
     * Configures a MongoDB Connection
     *
     * @generated from field: mgmt.v1alpha1.MongoConnectionConfig mongo_config = 6;
     */
    value: MongoConnectionConfig;
    case: "mongoConfig";
  } | {
    /**
     * Configures a GCP Cloud Storage Connection
     *
     * @generated from field: mgmt.v1alpha1.GcpCloudStorageConnectionConfig gcp_cloudstorage_config = 7;
     */
    value: GcpCloudStorageConnectionConfig;
    case: "gcpCloudstorageConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pg_config", kind: "message", T: PostgresConnectionConfig, oneof: "config" },
    { no: 2, name: "aws_s3_config", kind: "message", T: AwsS3ConnectionConfig, oneof: "config" },
    { no: 3, name: "mysql_config", kind: "message", T: MysqlConnectionConfig, oneof: "config" },
    { no: 4, name: "local_dir_config", kind: "message", T: LocalDirectoryConnectionConfig, oneof: "config" },
    { no: 5, name: "openai_config", kind: "message", T: OpenAiConnectionConfig, oneof: "config" },
    { no: 6, name: "mongo_config", kind: "message", T: MongoConnectionConfig, oneof: "config" },
    { no: 7, name: "gcp_cloudstorage_config", kind: "message", T: GcpCloudStorageConnectionConfig, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionConfig {
    return new ConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionConfig {
    return new ConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionConfig {
    return new ConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionConfig | PlainMessage<ConnectionConfig> | undefined, b: ConnectionConfig | PlainMessage<ConnectionConfig> | undefined): boolean {
    return proto3.util.equals(ConnectionConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MongoConnectionConfig
 */
export class MongoConnectionConfig extends Message<MongoConnectionConfig> {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.MongoConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * The full mongo connection url
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Provide tunnel configuration that can be used to access a connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 2;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 3;
   */
  clientTls?: ClientTlsConfig;

  constructor(data?: PartialMessage<MongoConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MongoConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "connection_config" },
    { no: 2, name: "tunnel", kind: "message", T: SSHTunnel },
    { no: 3, name: "client_tls", kind: "message", T: ClientTlsConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MongoConnectionConfig {
    return new MongoConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MongoConnectionConfig {
    return new MongoConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MongoConnectionConfig {
    return new MongoConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MongoConnectionConfig | PlainMessage<MongoConnectionConfig> | undefined, b: MongoConnectionConfig | PlainMessage<MongoConnectionConfig> | undefined): boolean {
    return proto3.util.equals(MongoConnectionConfig, a, b);
  }
}

/**
 * Configures a connection to OpenAI or OpenAI compatible API.
 *
 * @generated from message mgmt.v1alpha1.OpenAiConnectionConfig
 */
export class OpenAiConnectionConfig extends Message<OpenAiConnectionConfig> {
  /**
   * OpenAI Api Key
   *
   * @generated from field: string api_key = 1;
   */
  apiKey = "";

  /**
   * OpenAI URL
   *
   * @generated from field: string api_url = 2;
   */
  apiUrl = "";

  constructor(data?: PartialMessage<OpenAiConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.OpenAiConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "api_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "api_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OpenAiConnectionConfig {
    return new OpenAiConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OpenAiConnectionConfig {
    return new OpenAiConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OpenAiConnectionConfig {
    return new OpenAiConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: OpenAiConnectionConfig | PlainMessage<OpenAiConnectionConfig> | undefined, b: OpenAiConnectionConfig | PlainMessage<OpenAiConnectionConfig> | undefined): boolean {
    return proto3.util.equals(OpenAiConnectionConfig, a, b);
  }
}

/**
 * Configures a connection to a directory available on the local file system
 *
 * @generated from message mgmt.v1alpha1.LocalDirectoryConnectionConfig
 */
export class LocalDirectoryConnectionConfig extends Message<LocalDirectoryConnectionConfig> {
  /**
   * The absolute path to a directory that is available on the local file system to the API and Worker nodes
   *
   * @generated from field: string path = 1;
   */
  path = "";

  constructor(data?: PartialMessage<LocalDirectoryConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.LocalDirectoryConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocalDirectoryConnectionConfig {
    return new LocalDirectoryConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocalDirectoryConnectionConfig {
    return new LocalDirectoryConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocalDirectoryConnectionConfig {
    return new LocalDirectoryConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: LocalDirectoryConnectionConfig | PlainMessage<LocalDirectoryConnectionConfig> | undefined, b: LocalDirectoryConnectionConfig | PlainMessage<LocalDirectoryConnectionConfig> | undefined): boolean {
    return proto3.util.equals(LocalDirectoryConnectionConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresConnectionConfig
 */
export class PostgresConnectionConfig extends Message<PostgresConnectionConfig> {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.PostgresConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.PostgresConnection connection = 2;
     */
    value: PostgresConnection;
    case: "connection";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Provide tunnel configuration that can be used to access a postgres connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 3;
   */
  tunnel?: SSHTunnel;

  /**
   * @generated from field: mgmt.v1alpha1.SqlConnectionOptions connection_options = 4;
   */
  connectionOptions?: SqlConnectionOptions;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 5;
   */
  clientTls?: ClientTlsConfig;

  constructor(data?: PartialMessage<PostgresConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "connection_config" },
    { no: 2, name: "connection", kind: "message", T: PostgresConnection, oneof: "connection_config" },
    { no: 3, name: "tunnel", kind: "message", T: SSHTunnel },
    { no: 4, name: "connection_options", kind: "message", T: SqlConnectionOptions },
    { no: 5, name: "client_tls", kind: "message", T: ClientTlsConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresConnectionConfig {
    return new PostgresConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresConnectionConfig {
    return new PostgresConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresConnectionConfig {
    return new PostgresConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresConnectionConfig | PlainMessage<PostgresConnectionConfig> | undefined, b: PostgresConnectionConfig | PlainMessage<PostgresConnectionConfig> | undefined): boolean {
    return proto3.util.equals(PostgresConnectionConfig, a, b);
  }
}

/**
 * Config for providing client-side TLS certificates
 *
 * @generated from message mgmt.v1alpha1.ClientTlsConfig
 */
export class ClientTlsConfig extends Message<ClientTlsConfig> {
  /**
   * Root Certificate in PEM Format
   *
   * @generated from field: optional string root_cert = 1;
   */
  rootCert?: string;

  /**
   * Client Certificate in PEM format. Must also provide key.
   *
   * @generated from field: optional string client_cert = 2;
   */
  clientCert?: string;

  /**
   * Client Key in PEM format. Must also provide cert.
   *
   * @generated from field: optional string client_key = 3;
   */
  clientKey?: string;

  constructor(data?: PartialMessage<ClientTlsConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ClientTlsConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_cert", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "client_cert", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "client_key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientTlsConfig {
    return new ClientTlsConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientTlsConfig {
    return new ClientTlsConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientTlsConfig {
    return new ClientTlsConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ClientTlsConfig | PlainMessage<ClientTlsConfig> | undefined, b: ClientTlsConfig | PlainMessage<ClientTlsConfig> | undefined): boolean {
    return proto3.util.equals(ClientTlsConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SqlConnectionOptions
 */
export class SqlConnectionOptions extends Message<SqlConnectionOptions> {
  /**
   * Limits the number of open connections in the pool.
   *
   * @generated from field: optional int32 max_connection_limit = 1;
   */
  maxConnectionLimit?: number;

  constructor(data?: PartialMessage<SqlConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SqlConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_connection_limit", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SqlConnectionOptions {
    return new SqlConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SqlConnectionOptions {
    return new SqlConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SqlConnectionOptions {
    return new SqlConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: SqlConnectionOptions | PlainMessage<SqlConnectionOptions> | undefined, b: SqlConnectionOptions | PlainMessage<SqlConnectionOptions> | undefined): boolean {
    return proto3.util.equals(SqlConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SSHTunnel
 */
export class SSHTunnel extends Message<SSHTunnel> {
  /**
   * The host of the SSH server
   *
   * @generated from field: string host = 1;
   */
  host = "";

  /**
   * The port of the SSH server, typically 22
   *
   * @generated from field: int32 port = 2;
   */
  port = 0;

  /**
   * The user that will be used to authenticate
   *
   * @generated from field: string user = 3;
   */
  user = "";

  /**
   * Optionally provide the public key of the known host of the SSH tunnel that we are connecting to.
   * If this is not provided, the server will blindly connect to the host with the given credentials.
   * This is not recommended for production use!
   *
   * @generated from field: optional string known_host_public_key = 4;
   */
  knownHostPublicKey?: string;

  /**
   * Provide the authentication required to successfully connect to the SSH server for tunneling
   *
   * @generated from field: mgmt.v1alpha1.SSHAuthentication authentication = 5;
   */
  authentication?: SSHAuthentication;

  constructor(data?: PartialMessage<SSHTunnel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SSHTunnel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "known_host_public_key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "authentication", kind: "message", T: SSHAuthentication },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSHTunnel {
    return new SSHTunnel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSHTunnel {
    return new SSHTunnel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSHTunnel {
    return new SSHTunnel().fromJsonString(jsonString, options);
  }

  static equals(a: SSHTunnel | PlainMessage<SSHTunnel> | undefined, b: SSHTunnel | PlainMessage<SSHTunnel> | undefined): boolean {
    return proto3.util.equals(SSHTunnel, a, b);
  }
}

/**
 * SSH Authentication
 *
 * @generated from message mgmt.v1alpha1.SSHAuthentication
 */
export class SSHAuthentication extends Message<SSHAuthentication> {
  /**
   * @generated from oneof mgmt.v1alpha1.SSHAuthentication.auth_config
   */
  authConfig: {
    /**
     * @generated from field: mgmt.v1alpha1.SSHPassphrase passphrase = 1;
     */
    value: SSHPassphrase;
    case: "passphrase";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.SSHPrivateKey private_key = 2;
     */
    value: SSHPrivateKey;
    case: "privateKey";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SSHAuthentication>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SSHAuthentication";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "passphrase", kind: "message", T: SSHPassphrase, oneof: "auth_config" },
    { no: 2, name: "private_key", kind: "message", T: SSHPrivateKey, oneof: "auth_config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSHAuthentication {
    return new SSHAuthentication().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSHAuthentication {
    return new SSHAuthentication().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSHAuthentication {
    return new SSHAuthentication().fromJsonString(jsonString, options);
  }

  static equals(a: SSHAuthentication | PlainMessage<SSHAuthentication> | undefined, b: SSHAuthentication | PlainMessage<SSHAuthentication> | undefined): boolean {
    return proto3.util.equals(SSHAuthentication, a, b);
  }
}

/**
 * Contains the configuration needed to retrieve the SSH passphrase for the tunnel
 *
 * @generated from message mgmt.v1alpha1.SSHPassphrase
 */
export class SSHPassphrase extends Message<SSHPassphrase> {
  /**
   * The password to be used to connect to the SSH server
   *
   * eventually we can expand this to allow pulling from other sources.
   *
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<SSHPassphrase>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SSHPassphrase";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSHPassphrase {
    return new SSHPassphrase().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSHPassphrase {
    return new SSHPassphrase().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSHPassphrase {
    return new SSHPassphrase().fromJsonString(jsonString, options);
  }

  static equals(a: SSHPassphrase | PlainMessage<SSHPassphrase> | undefined, b: SSHPassphrase | PlainMessage<SSHPassphrase> | undefined): boolean {
    return proto3.util.equals(SSHPassphrase, a, b);
  }
}

/**
 * Contains the configuration needed to retrieve the SSH private key for the tunnel
 *
 * @generated from message mgmt.v1alpha1.SSHPrivateKey
 */
export class SSHPrivateKey extends Message<SSHPrivateKey> {
  /**
   * The private key in PEM format.
   *
   * @generated from field: string value = 1;
   */
  value = "";

  /**
   * If the private key is encrypted, this value should decrypt it.
   *
   * @generated from field: optional string passphrase = 2;
   */
  passphrase?: string;

  constructor(data?: PartialMessage<SSHPrivateKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SSHPrivateKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "passphrase", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SSHPrivateKey {
    return new SSHPrivateKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SSHPrivateKey {
    return new SSHPrivateKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SSHPrivateKey {
    return new SSHPrivateKey().fromJsonString(jsonString, options);
  }

  static equals(a: SSHPrivateKey | PlainMessage<SSHPrivateKey> | undefined, b: SSHPrivateKey | PlainMessage<SSHPrivateKey> | undefined): boolean {
    return proto3.util.equals(SSHPrivateKey, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresConnection
 */
export class PostgresConnection extends Message<PostgresConnection> {
  /**
   * @generated from field: string host = 1;
   */
  host = "";

  /**
   * @generated from field: int32 port = 2;
   */
  port = 0;

  /**
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * @generated from field: string user = 4;
   */
  user = "";

  /**
   * @generated from field: string pass = 5;
   */
  pass = "";

  /**
   * @generated from field: optional string ssl_mode = 6;
   */
  sslMode?: string;

  constructor(data?: PartialMessage<PostgresConnection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresConnection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "pass", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "ssl_mode", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresConnection {
    return new PostgresConnection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresConnection {
    return new PostgresConnection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresConnection {
    return new PostgresConnection().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresConnection | PlainMessage<PostgresConnection> | undefined, b: PostgresConnection | PlainMessage<PostgresConnection> | undefined): boolean {
    return proto3.util.equals(PostgresConnection, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlConnection
 */
export class MysqlConnection extends Message<MysqlConnection> {
  /**
   * @generated from field: string user = 1;
   */
  user = "";

  /**
   * @generated from field: string pass = 2;
   */
  pass = "";

  /**
   * @generated from field: string protocol = 3;
   */
  protocol = "";

  /**
   * @generated from field: string host = 4;
   */
  host = "";

  /**
   * @generated from field: int32 port = 5;
   */
  port = 0;

  /**
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<MysqlConnection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlConnection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "user", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pass", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "host", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlConnection {
    return new MysqlConnection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlConnection {
    return new MysqlConnection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlConnection {
    return new MysqlConnection().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlConnection | PlainMessage<MysqlConnection> | undefined, b: MysqlConnection | PlainMessage<MysqlConnection> | undefined): boolean {
    return proto3.util.equals(MysqlConnection, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlConnectionConfig
 */
export class MysqlConnectionConfig extends Message<MysqlConnectionConfig> {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.MysqlConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MysqlConnection connection = 2;
     */
    value: MysqlConnection;
    case: "connection";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Provide tunnel configuration that can be used to access a postgres connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 3;
   */
  tunnel?: SSHTunnel;

  /**
   * @generated from field: mgmt.v1alpha1.SqlConnectionOptions connection_options = 4;
   */
  connectionOptions?: SqlConnectionOptions;

  constructor(data?: PartialMessage<MysqlConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "connection_config" },
    { no: 2, name: "connection", kind: "message", T: MysqlConnection, oneof: "connection_config" },
    { no: 3, name: "tunnel", kind: "message", T: SSHTunnel },
    { no: 4, name: "connection_options", kind: "message", T: SqlConnectionOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlConnectionConfig {
    return new MysqlConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlConnectionConfig {
    return new MysqlConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlConnectionConfig {
    return new MysqlConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlConnectionConfig | PlainMessage<MysqlConnectionConfig> | undefined, b: MysqlConnectionConfig | PlainMessage<MysqlConnectionConfig> | undefined): boolean {
    return proto3.util.equals(MysqlConnectionConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AwsS3ConnectionConfig
 */
export class AwsS3ConnectionConfig extends Message<AwsS3ConnectionConfig> {
  /**
   * @generated from field: string bucket_arn = 1 [deprecated = true];
   * @deprecated
   */
  bucketArn = "";

  /**
   * @generated from field: optional string path_prefix = 2;
   */
  pathPrefix?: string;

  /**
   * @generated from field: optional mgmt.v1alpha1.AwsS3Credentials credentials = 3;
   */
  credentials?: AwsS3Credentials;

  /**
   * @generated from field: optional string region = 4;
   */
  region?: string;

  /**
   * @generated from field: optional string endpoint = 5;
   */
  endpoint?: string;

  /**
   * @generated from field: string bucket = 6;
   */
  bucket = "";

  constructor(data?: PartialMessage<AwsS3ConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsS3ConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_arn", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "credentials", kind: "message", T: AwsS3Credentials, opt: true },
    { no: 4, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "bucket", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3ConnectionConfig {
    return new AwsS3ConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3ConnectionConfig {
    return new AwsS3ConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3ConnectionConfig {
    return new AwsS3ConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3ConnectionConfig | PlainMessage<AwsS3ConnectionConfig> | undefined, b: AwsS3ConnectionConfig | PlainMessage<AwsS3ConnectionConfig> | undefined): boolean {
    return proto3.util.equals(AwsS3ConnectionConfig, a, b);
  }
}

/**
 * S3 Credentials that are used by the worker process.
 * Note: this may be optionally provided if the worker that is being hosted has environment credentials to the S3 bucket instead.
 *
 * @generated from message mgmt.v1alpha1.AwsS3Credentials
 */
export class AwsS3Credentials extends Message<AwsS3Credentials> {
  /**
   * @generated from field: optional string profile = 1;
   */
  profile?: string;

  /**
   * @generated from field: optional string access_key_id = 2;
   */
  accessKeyId?: string;

  /**
   * @generated from field: optional string secret_access_key = 3;
   */
  secretAccessKey?: string;

  /**
   * @generated from field: optional string session_token = 4;
   */
  sessionToken?: string;

  /**
   * @generated from field: optional bool from_ec2_role = 5;
   */
  fromEc2Role?: boolean;

  /**
   * @generated from field: optional string role_arn = 6;
   */
  roleArn?: string;

  /**
   * @generated from field: optional string role_external_id = 7;
   */
  roleExternalId?: string;

  constructor(data?: PartialMessage<AwsS3Credentials>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsS3Credentials";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "profile", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "access_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "secret_access_key", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "session_token", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "from_ec2_role", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 6, name: "role_arn", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "role_external_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3Credentials {
    return new AwsS3Credentials().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3Credentials {
    return new AwsS3Credentials().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3Credentials {
    return new AwsS3Credentials().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3Credentials | PlainMessage<AwsS3Credentials> | undefined, b: AwsS3Credentials | PlainMessage<AwsS3Credentials> | undefined): boolean {
    return proto3.util.equals(AwsS3Credentials, a, b);
  }
}

/**
 * Configuration for GCP Cloud Storage Buckets
 *
 * @generated from message mgmt.v1alpha1.GcpCloudStorageConnectionConfig
 */
export class GcpCloudStorageConnectionConfig extends Message<GcpCloudStorageConnectionConfig> {
  /**
   * The GCP Cloud Storage bucket that will be accessed.
   *
   * @generated from field: string bucket = 1;
   */
  bucket = "";

  /**
   * The path prefix that will be appended to each file
   *
   * @generated from field: optional string path_prefix = 2;
   */
  pathPrefix?: string;

  /**
   * stringified json of the service account credentials file
   *
   * @generated from field: optional string service_account_credentials = 3;
   */
  serviceAccountCredentials?: string;

  constructor(data?: PartialMessage<GcpCloudStorageConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GcpCloudStorageConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "path_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 3, name: "service_account_credentials", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GcpCloudStorageConnectionConfig {
    return new GcpCloudStorageConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GcpCloudStorageConnectionConfig {
    return new GcpCloudStorageConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GcpCloudStorageConnectionConfig {
    return new GcpCloudStorageConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: GcpCloudStorageConnectionConfig | PlainMessage<GcpCloudStorageConnectionConfig> | undefined, b: GcpCloudStorageConnectionConfig | PlainMessage<GcpCloudStorageConnectionConfig> | undefined): boolean {
    return proto3.util.equals(GcpCloudStorageConnectionConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.IsConnectionNameAvailableRequest
 */
export class IsConnectionNameAvailableRequest extends Message<IsConnectionNameAvailableRequest> {
  /**
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * @generated from field: string connection_name = 2;
   */
  connectionName = "";

  constructor(data?: PartialMessage<IsConnectionNameAvailableRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.IsConnectionNameAvailableRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsConnectionNameAvailableRequest {
    return new IsConnectionNameAvailableRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsConnectionNameAvailableRequest {
    return new IsConnectionNameAvailableRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsConnectionNameAvailableRequest {
    return new IsConnectionNameAvailableRequest().fromJsonString(jsonString, options);
  }

  static equals(a: IsConnectionNameAvailableRequest | PlainMessage<IsConnectionNameAvailableRequest> | undefined, b: IsConnectionNameAvailableRequest | PlainMessage<IsConnectionNameAvailableRequest> | undefined): boolean {
    return proto3.util.equals(IsConnectionNameAvailableRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.IsConnectionNameAvailableResponse
 */
export class IsConnectionNameAvailableResponse extends Message<IsConnectionNameAvailableResponse> {
  /**
   * @generated from field: bool is_available = 1;
   */
  isAvailable = false;

  constructor(data?: PartialMessage<IsConnectionNameAvailableResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.IsConnectionNameAvailableResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_available", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsConnectionNameAvailableResponse {
    return new IsConnectionNameAvailableResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsConnectionNameAvailableResponse {
    return new IsConnectionNameAvailableResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsConnectionNameAvailableResponse {
    return new IsConnectionNameAvailableResponse().fromJsonString(jsonString, options);
  }

  static equals(a: IsConnectionNameAvailableResponse | PlainMessage<IsConnectionNameAvailableResponse> | undefined, b: IsConnectionNameAvailableResponse | PlainMessage<IsConnectionNameAvailableResponse> | undefined): boolean {
    return proto3.util.equals(IsConnectionNameAvailableResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CheckSqlQueryRequest
 */
export class CheckSqlQueryRequest extends Message<CheckSqlQueryRequest> {
  /**
   * The connection id that the query will be checked against
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The full query that will be run through a PREPARE statement
   *
   * @generated from field: string query = 2;
   */
  query = "";

  constructor(data?: PartialMessage<CheckSqlQueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CheckSqlQueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckSqlQueryRequest {
    return new CheckSqlQueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckSqlQueryRequest {
    return new CheckSqlQueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckSqlQueryRequest {
    return new CheckSqlQueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckSqlQueryRequest | PlainMessage<CheckSqlQueryRequest> | undefined, b: CheckSqlQueryRequest | PlainMessage<CheckSqlQueryRequest> | undefined): boolean {
    return proto3.util.equals(CheckSqlQueryRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CheckSqlQueryResponse
 */
export class CheckSqlQueryResponse extends Message<CheckSqlQueryResponse> {
  /**
   * The query is run through PREPARE. Returns valid if it correctly compiled
   *
   * @generated from field: bool is_valid = 1;
   */
  isValid = false;

  /**
   * The error message returned by the sql client if the prepare did not return successfully
   *
   * @generated from field: optional string erorr_message = 2;
   */
  erorrMessage?: string;

  constructor(data?: PartialMessage<CheckSqlQueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CheckSqlQueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_valid", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "erorr_message", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckSqlQueryResponse {
    return new CheckSqlQueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckSqlQueryResponse {
    return new CheckSqlQueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckSqlQueryResponse {
    return new CheckSqlQueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckSqlQueryResponse | PlainMessage<CheckSqlQueryResponse> | undefined, b: CheckSqlQueryResponse | PlainMessage<CheckSqlQueryResponse> | undefined): boolean {
    return proto3.util.equals(CheckSqlQueryResponse, a, b);
  }
}

