// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: mgmt/v1alpha1/transformer.proto

package mgmtv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetSystemTransformersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSystemTransformersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSystemTransformersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSystemTransformersRequestMultiError, or nil if none found.
func (m *GetSystemTransformersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSystemTransformersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetSystemTransformersRequestMultiError(errors)
	}

	return nil
}

// GetSystemTransformersRequestMultiError is an error wrapping multiple
// validation errors returned by GetSystemTransformersRequest.ValidateAll() if
// the designated constraints aren't met.
type GetSystemTransformersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSystemTransformersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSystemTransformersRequestMultiError) AllErrors() []error { return m }

// GetSystemTransformersRequestValidationError is the validation error returned
// by GetSystemTransformersRequest.Validate if the designated constraints
// aren't met.
type GetSystemTransformersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSystemTransformersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSystemTransformersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSystemTransformersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSystemTransformersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSystemTransformersRequestValidationError) ErrorName() string {
	return "GetSystemTransformersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSystemTransformersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSystemTransformersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSystemTransformersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSystemTransformersRequestValidationError{}

// Validate checks the field values on GetSystemTransformersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSystemTransformersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSystemTransformersResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSystemTransformersResponseMultiError, or nil if none found.
func (m *GetSystemTransformersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSystemTransformersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransformers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSystemTransformersResponseValidationError{
						field:  fmt.Sprintf("Transformers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSystemTransformersResponseValidationError{
						field:  fmt.Sprintf("Transformers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSystemTransformersResponseValidationError{
					field:  fmt.Sprintf("Transformers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSystemTransformersResponseMultiError(errors)
	}

	return nil
}

// GetSystemTransformersResponseMultiError is an error wrapping multiple
// validation errors returned by GetSystemTransformersResponse.ValidateAll()
// if the designated constraints aren't met.
type GetSystemTransformersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSystemTransformersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSystemTransformersResponseMultiError) AllErrors() []error { return m }

// GetSystemTransformersResponseValidationError is the validation error
// returned by GetSystemTransformersResponse.Validate if the designated
// constraints aren't met.
type GetSystemTransformersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSystemTransformersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSystemTransformersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSystemTransformersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSystemTransformersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSystemTransformersResponseValidationError) ErrorName() string {
	return "GetSystemTransformersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSystemTransformersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSystemTransformersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSystemTransformersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSystemTransformersResponseValidationError{}

// Validate checks the field values on Transformer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transformer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transformer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransformerMultiError, or
// nil if none found.
func (m *Transformer) ValidateAll() error {
	return m.validate(true)
}

func (m *Transformer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransformerValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransformerValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransformerValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransformerMultiError(errors)
	}

	return nil
}

// TransformerMultiError is an error wrapping multiple validation errors
// returned by Transformer.ValidateAll() if the designated constraints aren't met.
type TransformerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransformerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransformerMultiError) AllErrors() []error { return m }

// TransformerValidationError is the validation error returned by
// Transformer.Validate if the designated constraints aren't met.
type TransformerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransformerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransformerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransformerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransformerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransformerValidationError) ErrorName() string { return "TransformerValidationError" }

// Error satisfies the builtin error interface
func (e TransformerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransformer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransformerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransformerValidationError{}

// Validate checks the field values on TransformerConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransformerConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransformerConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransformerConfigMultiError, or nil if none found.
func (m *TransformerConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *TransformerConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Config.(type) {
	case *TransformerConfig_EmailConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEmailConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "EmailConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "EmailConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmailConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "EmailConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_PassthroughConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPassthroughConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "PassthroughConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "PassthroughConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPassthroughConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "PassthroughConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_UuidConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUuidConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "UuidConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "UuidConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUuidConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "UuidConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_FirstNameConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFirstNameConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "FirstNameConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "FirstNameConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFirstNameConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "FirstNameConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_LastNameConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLastNameConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "LastNameConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "LastNameConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastNameConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "LastNameConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_FullNameConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFullNameConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "FullNameConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "FullNameConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFullNameConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "FullNameConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_PhoneNumberConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPhoneNumberConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "PhoneNumberConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "PhoneNumberConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPhoneNumberConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "PhoneNumberConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_IntPhoneNumberConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIntPhoneNumberConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "IntPhoneNumberConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "IntPhoneNumberConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIntPhoneNumberConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "IntPhoneNumberConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_RandomStringConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRandomStringConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "RandomStringConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "RandomStringConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRandomStringConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "RandomStringConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_RandomBoolConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRandomBoolConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "RandomBoolConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "RandomBoolConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRandomBoolConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "RandomBoolConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_RandomIntConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRandomIntConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "RandomIntConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "RandomIntConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRandomIntConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "RandomIntConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_RandomFloatConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRandomFloatConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "RandomFloatConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "RandomFloatConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRandomFloatConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "RandomFloatConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_GenderConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenderConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "GenderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "GenderConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenderConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "GenderConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_NullConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNullConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "NullConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "NullConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNullConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "NullConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_UtcTimestampConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUtcTimestampConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "UtcTimestampConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "UtcTimestampConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUtcTimestampConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "UtcTimestampConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_UnixTimestampConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUnixTimestampConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "UnixTimestampConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "UnixTimestampConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnixTimestampConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "UnixTimestampConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_StreetAddressConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStreetAddressConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "StreetAddressConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "StreetAddressConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStreetAddressConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "StreetAddressConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_CityConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCityConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "CityConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "CityConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCityConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "CityConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_ZipcodeConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZipcodeConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "ZipcodeConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "ZipcodeConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZipcodeConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "ZipcodeConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_StateConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStateConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "StateConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "StateConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStateConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "StateConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TransformerConfig_FullAddressConfig:
		if v == nil {
			err := TransformerConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFullAddressConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "FullAddressConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformerConfigValidationError{
						field:  "FullAddressConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFullAddressConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformerConfigValidationError{
					field:  "FullAddressConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TransformerConfigMultiError(errors)
	}

	return nil
}

// TransformerConfigMultiError is an error wrapping multiple validation errors
// returned by TransformerConfig.ValidateAll() if the designated constraints
// aren't met.
type TransformerConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransformerConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransformerConfigMultiError) AllErrors() []error { return m }

// TransformerConfigValidationError is the validation error returned by
// TransformerConfig.Validate if the designated constraints aren't met.
type TransformerConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransformerConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransformerConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransformerConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransformerConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransformerConfigValidationError) ErrorName() string {
	return "TransformerConfigValidationError"
}

// Error satisfies the builtin error interface
func (e TransformerConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransformerConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransformerConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransformerConfigValidationError{}

// Validate checks the field values on EmailConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmailConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmailConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmailConfigMultiError, or
// nil if none found.
func (m *EmailConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *EmailConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveDomain

	// no validation rules for PreserveLength

	if len(errors) > 0 {
		return EmailConfigMultiError(errors)
	}

	return nil
}

// EmailConfigMultiError is an error wrapping multiple validation errors
// returned by EmailConfig.ValidateAll() if the designated constraints aren't met.
type EmailConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailConfigMultiError) AllErrors() []error { return m }

// EmailConfigValidationError is the validation error returned by
// EmailConfig.Validate if the designated constraints aren't met.
type EmailConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailConfigValidationError) ErrorName() string { return "EmailConfigValidationError" }

// Error satisfies the builtin error interface
func (e EmailConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmailConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailConfigValidationError{}

// Validate checks the field values on Passthrough with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Passthrough) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Passthrough with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PassthroughMultiError, or
// nil if none found.
func (m *Passthrough) ValidateAll() error {
	return m.validate(true)
}

func (m *Passthrough) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PassthroughMultiError(errors)
	}

	return nil
}

// PassthroughMultiError is an error wrapping multiple validation errors
// returned by Passthrough.ValidateAll() if the designated constraints aren't met.
type PassthroughMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PassthroughMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PassthroughMultiError) AllErrors() []error { return m }

// PassthroughValidationError is the validation error returned by
// Passthrough.Validate if the designated constraints aren't met.
type PassthroughValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PassthroughValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PassthroughValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PassthroughValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PassthroughValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PassthroughValidationError) ErrorName() string { return "PassthroughValidationError" }

// Error satisfies the builtin error interface
func (e PassthroughValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPassthrough.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PassthroughValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PassthroughValidationError{}

// Validate checks the field values on Uuid with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Uuid) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Uuid with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UuidMultiError, or nil if none found.
func (m *Uuid) ValidateAll() error {
	return m.validate(true)
}

func (m *Uuid) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IncludeHyphen

	if len(errors) > 0 {
		return UuidMultiError(errors)
	}

	return nil
}

// UuidMultiError is an error wrapping multiple validation errors returned by
// Uuid.ValidateAll() if the designated constraints aren't met.
type UuidMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UuidMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UuidMultiError) AllErrors() []error { return m }

// UuidValidationError is the validation error returned by Uuid.Validate if the
// designated constraints aren't met.
type UuidValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UuidValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UuidValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UuidValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UuidValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UuidValidationError) ErrorName() string { return "UuidValidationError" }

// Error satisfies the builtin error interface
func (e UuidValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUuid.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UuidValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UuidValidationError{}

// Validate checks the field values on FirstName with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FirstName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FirstName with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FirstNameMultiError, or nil
// if none found.
func (m *FirstName) ValidateAll() error {
	return m.validate(true)
}

func (m *FirstName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveLength

	if len(errors) > 0 {
		return FirstNameMultiError(errors)
	}

	return nil
}

// FirstNameMultiError is an error wrapping multiple validation errors returned
// by FirstName.ValidateAll() if the designated constraints aren't met.
type FirstNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FirstNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FirstNameMultiError) AllErrors() []error { return m }

// FirstNameValidationError is the validation error returned by
// FirstName.Validate if the designated constraints aren't met.
type FirstNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FirstNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FirstNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FirstNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FirstNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FirstNameValidationError) ErrorName() string { return "FirstNameValidationError" }

// Error satisfies the builtin error interface
func (e FirstNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFirstName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FirstNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FirstNameValidationError{}

// Validate checks the field values on LastName with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LastName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LastName with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LastNameMultiError, or nil
// if none found.
func (m *LastName) ValidateAll() error {
	return m.validate(true)
}

func (m *LastName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveLength

	if len(errors) > 0 {
		return LastNameMultiError(errors)
	}

	return nil
}

// LastNameMultiError is an error wrapping multiple validation errors returned
// by LastName.ValidateAll() if the designated constraints aren't met.
type LastNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LastNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LastNameMultiError) AllErrors() []error { return m }

// LastNameValidationError is the validation error returned by
// LastName.Validate if the designated constraints aren't met.
type LastNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LastNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LastNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LastNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LastNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LastNameValidationError) ErrorName() string { return "LastNameValidationError" }

// Error satisfies the builtin error interface
func (e LastNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLastName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LastNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LastNameValidationError{}

// Validate checks the field values on FullName with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FullName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FullName with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FullNameMultiError, or nil
// if none found.
func (m *FullName) ValidateAll() error {
	return m.validate(true)
}

func (m *FullName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveLength

	if len(errors) > 0 {
		return FullNameMultiError(errors)
	}

	return nil
}

// FullNameMultiError is an error wrapping multiple validation errors returned
// by FullName.ValidateAll() if the designated constraints aren't met.
type FullNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FullNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FullNameMultiError) AllErrors() []error { return m }

// FullNameValidationError is the validation error returned by
// FullName.Validate if the designated constraints aren't met.
type FullNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FullNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FullNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FullNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FullNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FullNameValidationError) ErrorName() string { return "FullNameValidationError" }

// Error satisfies the builtin error interface
func (e FullNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFullName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FullNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FullNameValidationError{}

// Validate checks the field values on PhoneNumber with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PhoneNumber) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PhoneNumber with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PhoneNumberMultiError, or
// nil if none found.
func (m *PhoneNumber) ValidateAll() error {
	return m.validate(true)
}

func (m *PhoneNumber) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveLength

	// no validation rules for E164Format

	// no validation rules for IncludeHyphens

	if len(errors) > 0 {
		return PhoneNumberMultiError(errors)
	}

	return nil
}

// PhoneNumberMultiError is an error wrapping multiple validation errors
// returned by PhoneNumber.ValidateAll() if the designated constraints aren't met.
type PhoneNumberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PhoneNumberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PhoneNumberMultiError) AllErrors() []error { return m }

// PhoneNumberValidationError is the validation error returned by
// PhoneNumber.Validate if the designated constraints aren't met.
type PhoneNumberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PhoneNumberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PhoneNumberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PhoneNumberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PhoneNumberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PhoneNumberValidationError) ErrorName() string { return "PhoneNumberValidationError" }

// Error satisfies the builtin error interface
func (e PhoneNumberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPhoneNumber.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PhoneNumberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PhoneNumberValidationError{}

// Validate checks the field values on IntPhoneNumber with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IntPhoneNumber) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IntPhoneNumber with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IntPhoneNumberMultiError,
// or nil if none found.
func (m *IntPhoneNumber) ValidateAll() error {
	return m.validate(true)
}

func (m *IntPhoneNumber) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveLength

	if len(errors) > 0 {
		return IntPhoneNumberMultiError(errors)
	}

	return nil
}

// IntPhoneNumberMultiError is an error wrapping multiple validation errors
// returned by IntPhoneNumber.ValidateAll() if the designated constraints
// aren't met.
type IntPhoneNumberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IntPhoneNumberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IntPhoneNumberMultiError) AllErrors() []error { return m }

// IntPhoneNumberValidationError is the validation error returned by
// IntPhoneNumber.Validate if the designated constraints aren't met.
type IntPhoneNumberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IntPhoneNumberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IntPhoneNumberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IntPhoneNumberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IntPhoneNumberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IntPhoneNumberValidationError) ErrorName() string { return "IntPhoneNumberValidationError" }

// Error satisfies the builtin error interface
func (e IntPhoneNumberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIntPhoneNumber.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IntPhoneNumberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IntPhoneNumberValidationError{}

// Validate checks the field values on RandomString with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RandomString) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RandomString with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RandomStringMultiError, or
// nil if none found.
func (m *RandomString) ValidateAll() error {
	return m.validate(true)
}

func (m *RandomString) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveLength

	// no validation rules for StrLength

	// no validation rules for StrCase

	if len(errors) > 0 {
		return RandomStringMultiError(errors)
	}

	return nil
}

// RandomStringMultiError is an error wrapping multiple validation errors
// returned by RandomString.ValidateAll() if the designated constraints aren't met.
type RandomStringMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RandomStringMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RandomStringMultiError) AllErrors() []error { return m }

// RandomStringValidationError is the validation error returned by
// RandomString.Validate if the designated constraints aren't met.
type RandomStringValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RandomStringValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RandomStringValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RandomStringValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RandomStringValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RandomStringValidationError) ErrorName() string { return "RandomStringValidationError" }

// Error satisfies the builtin error interface
func (e RandomStringValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRandomString.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RandomStringValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RandomStringValidationError{}

// Validate checks the field values on Null with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Null) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Null with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NullMultiError, or nil if none found.
func (m *Null) ValidateAll() error {
	return m.validate(true)
}

func (m *Null) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NullMultiError(errors)
	}

	return nil
}

// NullMultiError is an error wrapping multiple validation errors returned by
// Null.ValidateAll() if the designated constraints aren't met.
type NullMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NullMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NullMultiError) AllErrors() []error { return m }

// NullValidationError is the validation error returned by Null.Validate if the
// designated constraints aren't met.
type NullValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NullValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NullValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NullValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NullValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NullValidationError) ErrorName() string { return "NullValidationError" }

// Error satisfies the builtin error interface
func (e NullValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNull.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NullValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NullValidationError{}

// Validate checks the field values on RandomBool with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RandomBool) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RandomBool with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RandomBoolMultiError, or
// nil if none found.
func (m *RandomBool) ValidateAll() error {
	return m.validate(true)
}

func (m *RandomBool) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RandomBoolMultiError(errors)
	}

	return nil
}

// RandomBoolMultiError is an error wrapping multiple validation errors
// returned by RandomBool.ValidateAll() if the designated constraints aren't met.
type RandomBoolMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RandomBoolMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RandomBoolMultiError) AllErrors() []error { return m }

// RandomBoolValidationError is the validation error returned by
// RandomBool.Validate if the designated constraints aren't met.
type RandomBoolValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RandomBoolValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RandomBoolValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RandomBoolValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RandomBoolValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RandomBoolValidationError) ErrorName() string { return "RandomBoolValidationError" }

// Error satisfies the builtin error interface
func (e RandomBoolValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRandomBool.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RandomBoolValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RandomBoolValidationError{}

// Validate checks the field values on RandomInt with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RandomInt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RandomInt with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RandomIntMultiError, or nil
// if none found.
func (m *RandomInt) ValidateAll() error {
	return m.validate(true)
}

func (m *RandomInt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveLength

	// no validation rules for IntLength

	if len(errors) > 0 {
		return RandomIntMultiError(errors)
	}

	return nil
}

// RandomIntMultiError is an error wrapping multiple validation errors returned
// by RandomInt.ValidateAll() if the designated constraints aren't met.
type RandomIntMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RandomIntMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RandomIntMultiError) AllErrors() []error { return m }

// RandomIntValidationError is the validation error returned by
// RandomInt.Validate if the designated constraints aren't met.
type RandomIntValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RandomIntValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RandomIntValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RandomIntValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RandomIntValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RandomIntValidationError) ErrorName() string { return "RandomIntValidationError" }

// Error satisfies the builtin error interface
func (e RandomIntValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRandomInt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RandomIntValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RandomIntValidationError{}

// Validate checks the field values on RandomFloat with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RandomFloat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RandomFloat with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RandomFloatMultiError, or
// nil if none found.
func (m *RandomFloat) ValidateAll() error {
	return m.validate(true)
}

func (m *RandomFloat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PreserveLength

	// no validation rules for DigitsBeforeDecimal

	// no validation rules for DigitsAfterDecimal

	if len(errors) > 0 {
		return RandomFloatMultiError(errors)
	}

	return nil
}

// RandomFloatMultiError is an error wrapping multiple validation errors
// returned by RandomFloat.ValidateAll() if the designated constraints aren't met.
type RandomFloatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RandomFloatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RandomFloatMultiError) AllErrors() []error { return m }

// RandomFloatValidationError is the validation error returned by
// RandomFloat.Validate if the designated constraints aren't met.
type RandomFloatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RandomFloatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RandomFloatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RandomFloatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RandomFloatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RandomFloatValidationError) ErrorName() string { return "RandomFloatValidationError" }

// Error satisfies the builtin error interface
func (e RandomFloatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRandomFloat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RandomFloatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RandomFloatValidationError{}

// Validate checks the field values on Gender with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Gender) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Gender with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GenderMultiError, or nil if none found.
func (m *Gender) ValidateAll() error {
	return m.validate(true)
}

func (m *Gender) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Abbreviate

	if len(errors) > 0 {
		return GenderMultiError(errors)
	}

	return nil
}

// GenderMultiError is an error wrapping multiple validation errors returned by
// Gender.ValidateAll() if the designated constraints aren't met.
type GenderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenderMultiError) AllErrors() []error { return m }

// GenderValidationError is the validation error returned by Gender.Validate if
// the designated constraints aren't met.
type GenderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenderValidationError) ErrorName() string { return "GenderValidationError" }

// Error satisfies the builtin error interface
func (e GenderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGender.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenderValidationError{}

// Validate checks the field values on UTCTimestamp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UTCTimestamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UTCTimestamp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UTCTimestampMultiError, or
// nil if none found.
func (m *UTCTimestamp) ValidateAll() error {
	return m.validate(true)
}

func (m *UTCTimestamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UTCTimestampMultiError(errors)
	}

	return nil
}

// UTCTimestampMultiError is an error wrapping multiple validation errors
// returned by UTCTimestamp.ValidateAll() if the designated constraints aren't met.
type UTCTimestampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UTCTimestampMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UTCTimestampMultiError) AllErrors() []error { return m }

// UTCTimestampValidationError is the validation error returned by
// UTCTimestamp.Validate if the designated constraints aren't met.
type UTCTimestampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UTCTimestampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UTCTimestampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UTCTimestampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UTCTimestampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UTCTimestampValidationError) ErrorName() string { return "UTCTimestampValidationError" }

// Error satisfies the builtin error interface
func (e UTCTimestampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUTCTimestamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UTCTimestampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UTCTimestampValidationError{}

// Validate checks the field values on UnixTimestamp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UnixTimestamp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnixTimestamp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UnixTimestampMultiError, or
// nil if none found.
func (m *UnixTimestamp) ValidateAll() error {
	return m.validate(true)
}

func (m *UnixTimestamp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UnixTimestampMultiError(errors)
	}

	return nil
}

// UnixTimestampMultiError is an error wrapping multiple validation errors
// returned by UnixTimestamp.ValidateAll() if the designated constraints
// aren't met.
type UnixTimestampMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnixTimestampMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnixTimestampMultiError) AllErrors() []error { return m }

// UnixTimestampValidationError is the validation error returned by
// UnixTimestamp.Validate if the designated constraints aren't met.
type UnixTimestampValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnixTimestampValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnixTimestampValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnixTimestampValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnixTimestampValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnixTimestampValidationError) ErrorName() string { return "UnixTimestampValidationError" }

// Error satisfies the builtin error interface
func (e UnixTimestampValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnixTimestamp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnixTimestampValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnixTimestampValidationError{}

// Validate checks the field values on StreetAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreetAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreetAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreetAddressMultiError, or
// nil if none found.
func (m *StreetAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *StreetAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StreetAddressMultiError(errors)
	}

	return nil
}

// StreetAddressMultiError is an error wrapping multiple validation errors
// returned by StreetAddress.ValidateAll() if the designated constraints
// aren't met.
type StreetAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreetAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreetAddressMultiError) AllErrors() []error { return m }

// StreetAddressValidationError is the validation error returned by
// StreetAddress.Validate if the designated constraints aren't met.
type StreetAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreetAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreetAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreetAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreetAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreetAddressValidationError) ErrorName() string { return "StreetAddressValidationError" }

// Error satisfies the builtin error interface
func (e StreetAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreetAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreetAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreetAddressValidationError{}

// Validate checks the field values on Zipcode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Zipcode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Zipcode with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ZipcodeMultiError, or nil if none found.
func (m *Zipcode) ValidateAll() error {
	return m.validate(true)
}

func (m *Zipcode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ZipcodeMultiError(errors)
	}

	return nil
}

// ZipcodeMultiError is an error wrapping multiple validation errors returned
// by Zipcode.ValidateAll() if the designated constraints aren't met.
type ZipcodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZipcodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZipcodeMultiError) AllErrors() []error { return m }

// ZipcodeValidationError is the validation error returned by Zipcode.Validate
// if the designated constraints aren't met.
type ZipcodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZipcodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZipcodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZipcodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZipcodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZipcodeValidationError) ErrorName() string { return "ZipcodeValidationError" }

// Error satisfies the builtin error interface
func (e ZipcodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZipcode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZipcodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZipcodeValidationError{}

// Validate checks the field values on City with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *City) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on City with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CityMultiError, or nil if none found.
func (m *City) ValidateAll() error {
	return m.validate(true)
}

func (m *City) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CityMultiError(errors)
	}

	return nil
}

// CityMultiError is an error wrapping multiple validation errors returned by
// City.ValidateAll() if the designated constraints aren't met.
type CityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CityMultiError) AllErrors() []error { return m }

// CityValidationError is the validation error returned by City.Validate if the
// designated constraints aren't met.
type CityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CityValidationError) ErrorName() string { return "CityValidationError" }

// Error satisfies the builtin error interface
func (e CityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CityValidationError{}

// Validate checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *State) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StateMultiError, or nil if none found.
func (m *State) ValidateAll() error {
	return m.validate(true)
}

func (m *State) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StateMultiError(errors)
	}

	return nil
}

// StateMultiError is an error wrapping multiple validation errors returned by
// State.ValidateAll() if the designated constraints aren't met.
type StateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateMultiError) AllErrors() []error { return m }

// StateValidationError is the validation error returned by State.Validate if
// the designated constraints aren't met.
type StateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateValidationError) ErrorName() string { return "StateValidationError" }

// Error satisfies the builtin error interface
func (e StateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateValidationError{}

// Validate checks the field values on FullAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FullAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FullAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FullAddressMultiError, or
// nil if none found.
func (m *FullAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *FullAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FullAddressMultiError(errors)
	}

	return nil
}

// FullAddressMultiError is an error wrapping multiple validation errors
// returned by FullAddress.ValidateAll() if the designated constraints aren't met.
type FullAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FullAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FullAddressMultiError) AllErrors() []error { return m }

// FullAddressValidationError is the validation error returned by
// FullAddress.Validate if the designated constraints aren't met.
type FullAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FullAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FullAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FullAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FullAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FullAddressValidationError) ErrorName() string { return "FullAddressValidationError" }

// Error satisfies the builtin error interface
func (e FullAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFullAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FullAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FullAddressValidationError{}
