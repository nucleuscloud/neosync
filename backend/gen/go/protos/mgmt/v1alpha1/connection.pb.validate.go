// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: mgmt/v1alpha1/connection.proto

package mgmtv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetConnectionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionsRequestMultiError, or nil if none found.
func (m *GetConnectionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return GetConnectionsRequestMultiError(errors)
	}

	return nil
}

// GetConnectionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetConnectionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionsRequestMultiError) AllErrors() []error { return m }

// GetConnectionsRequestValidationError is the validation error returned by
// GetConnectionsRequest.Validate if the designated constraints aren't met.
type GetConnectionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionsRequestValidationError) ErrorName() string {
	return "GetConnectionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionsRequestValidationError{}

// Validate checks the field values on GetConnectionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionsResponseMultiError, or nil if none found.
func (m *GetConnectionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetConnectionsResponseValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetConnectionsResponseValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetConnectionsResponseValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetConnectionsResponseMultiError(errors)
	}

	return nil
}

// GetConnectionsResponseMultiError is an error wrapping multiple validation
// errors returned by GetConnectionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionsResponseMultiError) AllErrors() []error { return m }

// GetConnectionsResponseValidationError is the validation error returned by
// GetConnectionsResponse.Validate if the designated constraints aren't met.
type GetConnectionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionsResponseValidationError) ErrorName() string {
	return "GetConnectionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionsResponseValidationError{}

// Validate checks the field values on GetConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionRequestMultiError, or nil if none found.
func (m *GetConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetConnectionRequestMultiError(errors)
	}

	return nil
}

// GetConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by GetConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionRequestMultiError) AllErrors() []error { return m }

// GetConnectionRequestValidationError is the validation error returned by
// GetConnectionRequest.Validate if the designated constraints aren't met.
type GetConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionRequestValidationError) ErrorName() string {
	return "GetConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionRequestValidationError{}

// Validate checks the field values on GetConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionResponseMultiError, or nil if none found.
func (m *GetConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetConnectionResponseMultiError(errors)
	}

	return nil
}

// GetConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by GetConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionResponseMultiError) AllErrors() []error { return m }

// GetConnectionResponseValidationError is the validation error returned by
// GetConnectionResponse.Validate if the designated constraints aren't met.
type GetConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionResponseValidationError) ErrorName() string {
	return "GetConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionResponseValidationError{}

// Validate checks the field values on CreateConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectionRequestMultiError, or nil if none found.
func (m *CreateConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectionRequestMultiError(errors)
	}

	return nil
}

// CreateConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectionRequestMultiError) AllErrors() []error { return m }

// CreateConnectionRequestValidationError is the validation error returned by
// CreateConnectionRequest.Validate if the designated constraints aren't met.
type CreateConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectionRequestValidationError) ErrorName() string {
	return "CreateConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectionRequestValidationError{}

// Validate checks the field values on CreateConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectionResponseMultiError, or nil if none found.
func (m *CreateConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectionResponseMultiError(errors)
	}

	return nil
}

// CreateConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectionResponseMultiError) AllErrors() []error { return m }

// CreateConnectionResponseValidationError is the validation error returned by
// CreateConnectionResponse.Validate if the designated constraints aren't met.
type CreateConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectionResponseValidationError) ErrorName() string {
	return "CreateConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectionResponseValidationError{}

// Validate checks the field values on UpdateConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateConnectionRequestMultiError, or nil if none found.
func (m *UpdateConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateConnectionRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateConnectionRequestMultiError(errors)
	}

	return nil
}

// UpdateConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateConnectionRequestMultiError) AllErrors() []error { return m }

// UpdateConnectionRequestValidationError is the validation error returned by
// UpdateConnectionRequest.Validate if the designated constraints aren't met.
type UpdateConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateConnectionRequestValidationError) ErrorName() string {
	return "UpdateConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateConnectionRequestValidationError{}

// Validate checks the field values on UpdateConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateConnectionResponseMultiError, or nil if none found.
func (m *UpdateConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateConnectionResponseMultiError(errors)
	}

	return nil
}

// UpdateConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateConnectionResponseMultiError) AllErrors() []error { return m }

// UpdateConnectionResponseValidationError is the validation error returned by
// UpdateConnectionResponse.Validate if the designated constraints aren't met.
type UpdateConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateConnectionResponseValidationError) ErrorName() string {
	return "UpdateConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateConnectionResponseValidationError{}

// Validate checks the field values on DeleteConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConnectionRequestMultiError, or nil if none found.
func (m *DeleteConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteConnectionRequestMultiError(errors)
	}

	return nil
}

// DeleteConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConnectionRequestMultiError) AllErrors() []error { return m }

// DeleteConnectionRequestValidationError is the validation error returned by
// DeleteConnectionRequest.Validate if the designated constraints aren't met.
type DeleteConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConnectionRequestValidationError) ErrorName() string {
	return "DeleteConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConnectionRequestValidationError{}

// Validate checks the field values on DeleteConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConnectionResponseMultiError, or nil if none found.
func (m *DeleteConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteConnectionResponseMultiError(errors)
	}

	return nil
}

// DeleteConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConnectionResponseMultiError) AllErrors() []error { return m }

// DeleteConnectionResponseValidationError is the validation error returned by
// DeleteConnectionResponse.Validate if the designated constraints aren't met.
type DeleteConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConnectionResponseValidationError) ErrorName() string {
	return "DeleteConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConnectionResponseValidationError{}

// Validate checks the field values on CheckConnectionConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckConnectionConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckConnectionConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckConnectionConfigRequestMultiError, or nil if none found.
func (m *CheckConnectionConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckConnectionConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckConnectionConfigRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckConnectionConfigRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckConnectionConfigRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckConnectionConfigRequestMultiError(errors)
	}

	return nil
}

// CheckConnectionConfigRequestMultiError is an error wrapping multiple
// validation errors returned by CheckConnectionConfigRequest.ValidateAll() if
// the designated constraints aren't met.
type CheckConnectionConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckConnectionConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckConnectionConfigRequestMultiError) AllErrors() []error { return m }

// CheckConnectionConfigRequestValidationError is the validation error returned
// by CheckConnectionConfigRequest.Validate if the designated constraints
// aren't met.
type CheckConnectionConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckConnectionConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckConnectionConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckConnectionConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckConnectionConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckConnectionConfigRequestValidationError) ErrorName() string {
	return "CheckConnectionConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckConnectionConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckConnectionConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckConnectionConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckConnectionConfigRequestValidationError{}

// Validate checks the field values on CheckConnectionConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckConnectionConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckConnectionConfigResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CheckConnectionConfigResponseMultiError, or nil if none found.
func (m *CheckConnectionConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckConnectionConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsConnected

	for idx, item := range m.GetPrivileges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CheckConnectionConfigResponseValidationError{
						field:  fmt.Sprintf("Privileges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CheckConnectionConfigResponseValidationError{
						field:  fmt.Sprintf("Privileges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CheckConnectionConfigResponseValidationError{
					field:  fmt.Sprintf("Privileges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ConnectionError != nil {
		// no validation rules for ConnectionError
	}

	if len(errors) > 0 {
		return CheckConnectionConfigResponseMultiError(errors)
	}

	return nil
}

// CheckConnectionConfigResponseMultiError is an error wrapping multiple
// validation errors returned by CheckConnectionConfigResponse.ValidateAll()
// if the designated constraints aren't met.
type CheckConnectionConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckConnectionConfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckConnectionConfigResponseMultiError) AllErrors() []error { return m }

// CheckConnectionConfigResponseValidationError is the validation error
// returned by CheckConnectionConfigResponse.Validate if the designated
// constraints aren't met.
type CheckConnectionConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckConnectionConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckConnectionConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckConnectionConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckConnectionConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckConnectionConfigResponseValidationError) ErrorName() string {
	return "CheckConnectionConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckConnectionConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckConnectionConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckConnectionConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckConnectionConfigResponseValidationError{}

// Validate checks the field values on ConnectionRolePrivilege with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConnectionRolePrivilege) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectionRolePrivilege with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectionRolePrivilegeMultiError, or nil if none found.
func (m *ConnectionRolePrivilege) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectionRolePrivilege) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Grantee

	// no validation rules for Schema

	// no validation rules for Table

	if len(errors) > 0 {
		return ConnectionRolePrivilegeMultiError(errors)
	}

	return nil
}

// ConnectionRolePrivilegeMultiError is an error wrapping multiple validation
// errors returned by ConnectionRolePrivilege.ValidateAll() if the designated
// constraints aren't met.
type ConnectionRolePrivilegeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionRolePrivilegeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionRolePrivilegeMultiError) AllErrors() []error { return m }

// ConnectionRolePrivilegeValidationError is the validation error returned by
// ConnectionRolePrivilege.Validate if the designated constraints aren't met.
type ConnectionRolePrivilegeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionRolePrivilegeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionRolePrivilegeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionRolePrivilegeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionRolePrivilegeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionRolePrivilegeValidationError) ErrorName() string {
	return "ConnectionRolePrivilegeValidationError"
}

// Error satisfies the builtin error interface
func (e ConnectionRolePrivilegeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionRolePrivilege.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionRolePrivilegeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionRolePrivilegeValidationError{}

// Validate checks the field values on Connection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectionMultiError, or
// nil if none found.
func (m *Connection) ValidateAll() error {
	return m.validate(true)
}

func (m *Connection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedByUserId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedByUserId

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AccountId

	if len(errors) > 0 {
		return ConnectionMultiError(errors)
	}

	return nil
}

// ConnectionMultiError is an error wrapping multiple validation errors
// returned by Connection.ValidateAll() if the designated constraints aren't met.
type ConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionMultiError) AllErrors() []error { return m }

// ConnectionValidationError is the validation error returned by
// Connection.Validate if the designated constraints aren't met.
type ConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionValidationError) ErrorName() string { return "ConnectionValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionValidationError{}

// Validate checks the field values on ConnectionConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectionConfigMultiError, or nil if none found.
func (m *ConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Config.(type) {
	case *ConnectionConfig_PgConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPgConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "PgConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "PgConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPgConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "PgConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_AwsS3Config:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAwsS3Config()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "AwsS3Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "AwsS3Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAwsS3Config()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "AwsS3Config",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_MysqlConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMysqlConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "MysqlConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "MysqlConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMysqlConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "MysqlConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_LocalDirConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLocalDirConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "LocalDirConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "LocalDirConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLocalDirConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "LocalDirConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_OpenaiConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOpenaiConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "OpenaiConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "OpenaiConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpenaiConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "OpenaiConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_MongoConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMongoConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "MongoConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "MongoConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMongoConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "MongoConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_GcpCloudstorageConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGcpCloudstorageConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "GcpCloudstorageConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "GcpCloudstorageConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGcpCloudstorageConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "GcpCloudstorageConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConnectionConfigMultiError(errors)
	}

	return nil
}

// ConnectionConfigMultiError is an error wrapping multiple validation errors
// returned by ConnectionConfig.ValidateAll() if the designated constraints
// aren't met.
type ConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionConfigMultiError) AllErrors() []error { return m }

// ConnectionConfigValidationError is the validation error returned by
// ConnectionConfig.Validate if the designated constraints aren't met.
type ConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionConfigValidationError) ErrorName() string { return "ConnectionConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionConfigValidationError{}

// Validate checks the field values on MongoConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MongoConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MongoConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MongoConnectionConfigMultiError, or nil if none found.
func (m *MongoConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MongoConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTunnel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MongoConnectionConfigValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MongoConnectionConfigValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTunnel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MongoConnectionConfigValidationError{
				field:  "Tunnel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClientTls()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MongoConnectionConfigValidationError{
					field:  "ClientTls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MongoConnectionConfigValidationError{
					field:  "ClientTls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClientTls()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MongoConnectionConfigValidationError{
				field:  "ClientTls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.ConnectionConfig.(type) {
	case *MongoConnectionConfig_Url:
		if v == nil {
			err := MongoConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Url
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MongoConnectionConfigMultiError(errors)
	}

	return nil
}

// MongoConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by MongoConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type MongoConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MongoConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MongoConnectionConfigMultiError) AllErrors() []error { return m }

// MongoConnectionConfigValidationError is the validation error returned by
// MongoConnectionConfig.Validate if the designated constraints aren't met.
type MongoConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MongoConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MongoConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MongoConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MongoConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MongoConnectionConfigValidationError) ErrorName() string {
	return "MongoConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MongoConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMongoConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MongoConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MongoConnectionConfigValidationError{}

// Validate checks the field values on OpenAiConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OpenAiConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenAiConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OpenAiConnectionConfigMultiError, or nil if none found.
func (m *OpenAiConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenAiConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApiKey

	// no validation rules for ApiUrl

	if len(errors) > 0 {
		return OpenAiConnectionConfigMultiError(errors)
	}

	return nil
}

// OpenAiConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by OpenAiConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type OpenAiConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenAiConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenAiConnectionConfigMultiError) AllErrors() []error { return m }

// OpenAiConnectionConfigValidationError is the validation error returned by
// OpenAiConnectionConfig.Validate if the designated constraints aren't met.
type OpenAiConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenAiConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenAiConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenAiConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenAiConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenAiConnectionConfigValidationError) ErrorName() string {
	return "OpenAiConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e OpenAiConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenAiConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenAiConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenAiConnectionConfigValidationError{}

// Validate checks the field values on LocalDirectoryConnectionConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LocalDirectoryConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LocalDirectoryConnectionConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// LocalDirectoryConnectionConfigMultiError, or nil if none found.
func (m *LocalDirectoryConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *LocalDirectoryConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	if len(errors) > 0 {
		return LocalDirectoryConnectionConfigMultiError(errors)
	}

	return nil
}

// LocalDirectoryConnectionConfigMultiError is an error wrapping multiple
// validation errors returned by LocalDirectoryConnectionConfig.ValidateAll()
// if the designated constraints aren't met.
type LocalDirectoryConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocalDirectoryConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocalDirectoryConnectionConfigMultiError) AllErrors() []error { return m }

// LocalDirectoryConnectionConfigValidationError is the validation error
// returned by LocalDirectoryConnectionConfig.Validate if the designated
// constraints aren't met.
type LocalDirectoryConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocalDirectoryConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocalDirectoryConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocalDirectoryConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocalDirectoryConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocalDirectoryConnectionConfigValidationError) ErrorName() string {
	return "LocalDirectoryConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e LocalDirectoryConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocalDirectoryConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocalDirectoryConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocalDirectoryConnectionConfigValidationError{}

// Validate checks the field values on PostgresConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostgresConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostgresConnectionConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostgresConnectionConfigMultiError, or nil if none found.
func (m *PostgresConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PostgresConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTunnel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostgresConnectionConfigValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostgresConnectionConfigValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTunnel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostgresConnectionConfigValidationError{
				field:  "Tunnel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConnectionOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostgresConnectionConfigValidationError{
					field:  "ConnectionOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostgresConnectionConfigValidationError{
					field:  "ConnectionOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostgresConnectionConfigValidationError{
				field:  "ConnectionOptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClientTls()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostgresConnectionConfigValidationError{
					field:  "ClientTls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostgresConnectionConfigValidationError{
					field:  "ClientTls",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClientTls()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostgresConnectionConfigValidationError{
				field:  "ClientTls",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.ConnectionConfig.(type) {
	case *PostgresConnectionConfig_Url:
		if v == nil {
			err := PostgresConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Url
	case *PostgresConnectionConfig_Connection:
		if v == nil {
			err := PostgresConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PostgresConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PostgresConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PostgresConnectionConfigValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PostgresConnectionConfigMultiError(errors)
	}

	return nil
}

// PostgresConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by PostgresConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type PostgresConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostgresConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostgresConnectionConfigMultiError) AllErrors() []error { return m }

// PostgresConnectionConfigValidationError is the validation error returned by
// PostgresConnectionConfig.Validate if the designated constraints aren't met.
type PostgresConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostgresConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostgresConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostgresConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostgresConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostgresConnectionConfigValidationError) ErrorName() string {
	return "PostgresConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e PostgresConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostgresConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostgresConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostgresConnectionConfigValidationError{}

// Validate checks the field values on ClientTlsConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClientTlsConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientTlsConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClientTlsConfigMultiError, or nil if none found.
func (m *ClientTlsConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientTlsConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.RootCert != nil {
		// no validation rules for RootCert
	}

	if m.ClientCert != nil {
		// no validation rules for ClientCert
	}

	if m.ClientKey != nil {
		// no validation rules for ClientKey
	}

	if len(errors) > 0 {
		return ClientTlsConfigMultiError(errors)
	}

	return nil
}

// ClientTlsConfigMultiError is an error wrapping multiple validation errors
// returned by ClientTlsConfig.ValidateAll() if the designated constraints
// aren't met.
type ClientTlsConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientTlsConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientTlsConfigMultiError) AllErrors() []error { return m }

// ClientTlsConfigValidationError is the validation error returned by
// ClientTlsConfig.Validate if the designated constraints aren't met.
type ClientTlsConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientTlsConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientTlsConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientTlsConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientTlsConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientTlsConfigValidationError) ErrorName() string { return "ClientTlsConfigValidationError" }

// Error satisfies the builtin error interface
func (e ClientTlsConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientTlsConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientTlsConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientTlsConfigValidationError{}

// Validate checks the field values on SqlConnectionOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SqlConnectionOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SqlConnectionOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SqlConnectionOptionsMultiError, or nil if none found.
func (m *SqlConnectionOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *SqlConnectionOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.MaxConnectionLimit != nil {
		// no validation rules for MaxConnectionLimit
	}

	if len(errors) > 0 {
		return SqlConnectionOptionsMultiError(errors)
	}

	return nil
}

// SqlConnectionOptionsMultiError is an error wrapping multiple validation
// errors returned by SqlConnectionOptions.ValidateAll() if the designated
// constraints aren't met.
type SqlConnectionOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SqlConnectionOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SqlConnectionOptionsMultiError) AllErrors() []error { return m }

// SqlConnectionOptionsValidationError is the validation error returned by
// SqlConnectionOptions.Validate if the designated constraints aren't met.
type SqlConnectionOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SqlConnectionOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SqlConnectionOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SqlConnectionOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SqlConnectionOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SqlConnectionOptionsValidationError) ErrorName() string {
	return "SqlConnectionOptionsValidationError"
}

// Error satisfies the builtin error interface
func (e SqlConnectionOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSqlConnectionOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SqlConnectionOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SqlConnectionOptionsValidationError{}

// Validate checks the field values on SSHTunnel with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SSHTunnel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSHTunnel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SSHTunnelMultiError, or nil
// if none found.
func (m *SSHTunnel) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHTunnel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	// no validation rules for Port

	// no validation rules for User

	if all {
		switch v := interface{}(m.GetAuthentication()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SSHTunnelValidationError{
					field:  "Authentication",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SSHTunnelValidationError{
					field:  "Authentication",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthentication()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SSHTunnelValidationError{
				field:  "Authentication",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.KnownHostPublicKey != nil {
		// no validation rules for KnownHostPublicKey
	}

	if len(errors) > 0 {
		return SSHTunnelMultiError(errors)
	}

	return nil
}

// SSHTunnelMultiError is an error wrapping multiple validation errors returned
// by SSHTunnel.ValidateAll() if the designated constraints aren't met.
type SSHTunnelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHTunnelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHTunnelMultiError) AllErrors() []error { return m }

// SSHTunnelValidationError is the validation error returned by
// SSHTunnel.Validate if the designated constraints aren't met.
type SSHTunnelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHTunnelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHTunnelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHTunnelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHTunnelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHTunnelValidationError) ErrorName() string { return "SSHTunnelValidationError" }

// Error satisfies the builtin error interface
func (e SSHTunnelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHTunnel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHTunnelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHTunnelValidationError{}

// Validate checks the field values on SSHAuthentication with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SSHAuthentication) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSHAuthentication with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SSHAuthenticationMultiError, or nil if none found.
func (m *SSHAuthentication) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHAuthentication) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.AuthConfig.(type) {
	case *SSHAuthentication_Passphrase:
		if v == nil {
			err := SSHAuthenticationValidationError{
				field:  "AuthConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPassphrase()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SSHAuthenticationValidationError{
						field:  "Passphrase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SSHAuthenticationValidationError{
						field:  "Passphrase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPassphrase()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SSHAuthenticationValidationError{
					field:  "Passphrase",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *SSHAuthentication_PrivateKey:
		if v == nil {
			err := SSHAuthenticationValidationError{
				field:  "AuthConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPrivateKey()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SSHAuthenticationValidationError{
						field:  "PrivateKey",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SSHAuthenticationValidationError{
						field:  "PrivateKey",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrivateKey()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SSHAuthenticationValidationError{
					field:  "PrivateKey",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SSHAuthenticationMultiError(errors)
	}

	return nil
}

// SSHAuthenticationMultiError is an error wrapping multiple validation errors
// returned by SSHAuthentication.ValidateAll() if the designated constraints
// aren't met.
type SSHAuthenticationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHAuthenticationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHAuthenticationMultiError) AllErrors() []error { return m }

// SSHAuthenticationValidationError is the validation error returned by
// SSHAuthentication.Validate if the designated constraints aren't met.
type SSHAuthenticationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHAuthenticationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHAuthenticationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHAuthenticationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHAuthenticationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHAuthenticationValidationError) ErrorName() string {
	return "SSHAuthenticationValidationError"
}

// Error satisfies the builtin error interface
func (e SSHAuthenticationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHAuthentication.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHAuthenticationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHAuthenticationValidationError{}

// Validate checks the field values on SSHPassphrase with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SSHPassphrase) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSHPassphrase with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SSHPassphraseMultiError, or
// nil if none found.
func (m *SSHPassphrase) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHPassphrase) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SSHPassphraseMultiError(errors)
	}

	return nil
}

// SSHPassphraseMultiError is an error wrapping multiple validation errors
// returned by SSHPassphrase.ValidateAll() if the designated constraints
// aren't met.
type SSHPassphraseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHPassphraseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHPassphraseMultiError) AllErrors() []error { return m }

// SSHPassphraseValidationError is the validation error returned by
// SSHPassphrase.Validate if the designated constraints aren't met.
type SSHPassphraseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHPassphraseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHPassphraseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHPassphraseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHPassphraseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHPassphraseValidationError) ErrorName() string { return "SSHPassphraseValidationError" }

// Error satisfies the builtin error interface
func (e SSHPassphraseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHPassphrase.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHPassphraseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHPassphraseValidationError{}

// Validate checks the field values on SSHPrivateKey with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SSHPrivateKey) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SSHPrivateKey with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SSHPrivateKeyMultiError, or
// nil if none found.
func (m *SSHPrivateKey) ValidateAll() error {
	return m.validate(true)
}

func (m *SSHPrivateKey) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if m.Passphrase != nil {
		// no validation rules for Passphrase
	}

	if len(errors) > 0 {
		return SSHPrivateKeyMultiError(errors)
	}

	return nil
}

// SSHPrivateKeyMultiError is an error wrapping multiple validation errors
// returned by SSHPrivateKey.ValidateAll() if the designated constraints
// aren't met.
type SSHPrivateKeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SSHPrivateKeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SSHPrivateKeyMultiError) AllErrors() []error { return m }

// SSHPrivateKeyValidationError is the validation error returned by
// SSHPrivateKey.Validate if the designated constraints aren't met.
type SSHPrivateKeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SSHPrivateKeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SSHPrivateKeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SSHPrivateKeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SSHPrivateKeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SSHPrivateKeyValidationError) ErrorName() string { return "SSHPrivateKeyValidationError" }

// Error satisfies the builtin error interface
func (e SSHPrivateKeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSSHPrivateKey.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SSHPrivateKeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SSHPrivateKeyValidationError{}

// Validate checks the field values on PostgresConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostgresConnection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostgresConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostgresConnectionMultiError, or nil if none found.
func (m *PostgresConnection) ValidateAll() error {
	return m.validate(true)
}

func (m *PostgresConnection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	// no validation rules for Port

	// no validation rules for Name

	// no validation rules for User

	// no validation rules for Pass

	if m.SslMode != nil {
		// no validation rules for SslMode
	}

	if len(errors) > 0 {
		return PostgresConnectionMultiError(errors)
	}

	return nil
}

// PostgresConnectionMultiError is an error wrapping multiple validation errors
// returned by PostgresConnection.ValidateAll() if the designated constraints
// aren't met.
type PostgresConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostgresConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostgresConnectionMultiError) AllErrors() []error { return m }

// PostgresConnectionValidationError is the validation error returned by
// PostgresConnection.Validate if the designated constraints aren't met.
type PostgresConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostgresConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostgresConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostgresConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostgresConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostgresConnectionValidationError) ErrorName() string {
	return "PostgresConnectionValidationError"
}

// Error satisfies the builtin error interface
func (e PostgresConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostgresConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostgresConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostgresConnectionValidationError{}

// Validate checks the field values on MysqlConnection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MysqlConnection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MysqlConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MysqlConnectionMultiError, or nil if none found.
func (m *MysqlConnection) ValidateAll() error {
	return m.validate(true)
}

func (m *MysqlConnection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for User

	// no validation rules for Pass

	// no validation rules for Protocol

	// no validation rules for Host

	// no validation rules for Port

	// no validation rules for Name

	if len(errors) > 0 {
		return MysqlConnectionMultiError(errors)
	}

	return nil
}

// MysqlConnectionMultiError is an error wrapping multiple validation errors
// returned by MysqlConnection.ValidateAll() if the designated constraints
// aren't met.
type MysqlConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MysqlConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MysqlConnectionMultiError) AllErrors() []error { return m }

// MysqlConnectionValidationError is the validation error returned by
// MysqlConnection.Validate if the designated constraints aren't met.
type MysqlConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MysqlConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MysqlConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MysqlConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MysqlConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MysqlConnectionValidationError) ErrorName() string { return "MysqlConnectionValidationError" }

// Error satisfies the builtin error interface
func (e MysqlConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMysqlConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MysqlConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MysqlConnectionValidationError{}

// Validate checks the field values on MysqlConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MysqlConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MysqlConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MysqlConnectionConfigMultiError, or nil if none found.
func (m *MysqlConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MysqlConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTunnel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MysqlConnectionConfigValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MysqlConnectionConfigValidationError{
					field:  "Tunnel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTunnel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MysqlConnectionConfigValidationError{
				field:  "Tunnel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConnectionOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MysqlConnectionConfigValidationError{
					field:  "ConnectionOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MysqlConnectionConfigValidationError{
					field:  "ConnectionOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MysqlConnectionConfigValidationError{
				field:  "ConnectionOptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.ConnectionConfig.(type) {
	case *MysqlConnectionConfig_Url:
		if v == nil {
			err := MysqlConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Url
	case *MysqlConnectionConfig_Connection:
		if v == nil {
			err := MysqlConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MysqlConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MysqlConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MysqlConnectionConfigValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MysqlConnectionConfigMultiError(errors)
	}

	return nil
}

// MysqlConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by MysqlConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type MysqlConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MysqlConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MysqlConnectionConfigMultiError) AllErrors() []error { return m }

// MysqlConnectionConfigValidationError is the validation error returned by
// MysqlConnectionConfig.Validate if the designated constraints aren't met.
type MysqlConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MysqlConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MysqlConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MysqlConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MysqlConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MysqlConnectionConfigValidationError) ErrorName() string {
	return "MysqlConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MysqlConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMysqlConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MysqlConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MysqlConnectionConfigValidationError{}

// Validate checks the field values on AwsS3ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AwsS3ConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AwsS3ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AwsS3ConnectionConfigMultiError, or nil if none found.
func (m *AwsS3ConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AwsS3ConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BucketArn

	// no validation rules for Bucket

	if m.PathPrefix != nil {
		// no validation rules for PathPrefix
	}

	if m.Credentials != nil {

		if all {
			switch v := interface{}(m.GetCredentials()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AwsS3ConnectionConfigValidationError{
						field:  "Credentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AwsS3ConnectionConfigValidationError{
						field:  "Credentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCredentials()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AwsS3ConnectionConfigValidationError{
					field:  "Credentials",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.Endpoint != nil {
		// no validation rules for Endpoint
	}

	if len(errors) > 0 {
		return AwsS3ConnectionConfigMultiError(errors)
	}

	return nil
}

// AwsS3ConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by AwsS3ConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type AwsS3ConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AwsS3ConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AwsS3ConnectionConfigMultiError) AllErrors() []error { return m }

// AwsS3ConnectionConfigValidationError is the validation error returned by
// AwsS3ConnectionConfig.Validate if the designated constraints aren't met.
type AwsS3ConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AwsS3ConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AwsS3ConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AwsS3ConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AwsS3ConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AwsS3ConnectionConfigValidationError) ErrorName() string {
	return "AwsS3ConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AwsS3ConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAwsS3ConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AwsS3ConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AwsS3ConnectionConfigValidationError{}

// Validate checks the field values on AwsS3Credentials with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AwsS3Credentials) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AwsS3Credentials with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AwsS3CredentialsMultiError, or nil if none found.
func (m *AwsS3Credentials) ValidateAll() error {
	return m.validate(true)
}

func (m *AwsS3Credentials) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Profile != nil {
		// no validation rules for Profile
	}

	if m.AccessKeyId != nil {
		// no validation rules for AccessKeyId
	}

	if m.SecretAccessKey != nil {
		// no validation rules for SecretAccessKey
	}

	if m.SessionToken != nil {
		// no validation rules for SessionToken
	}

	if m.FromEc2Role != nil {
		// no validation rules for FromEc2Role
	}

	if m.RoleArn != nil {
		// no validation rules for RoleArn
	}

	if m.RoleExternalId != nil {
		// no validation rules for RoleExternalId
	}

	if len(errors) > 0 {
		return AwsS3CredentialsMultiError(errors)
	}

	return nil
}

// AwsS3CredentialsMultiError is an error wrapping multiple validation errors
// returned by AwsS3Credentials.ValidateAll() if the designated constraints
// aren't met.
type AwsS3CredentialsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AwsS3CredentialsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AwsS3CredentialsMultiError) AllErrors() []error { return m }

// AwsS3CredentialsValidationError is the validation error returned by
// AwsS3Credentials.Validate if the designated constraints aren't met.
type AwsS3CredentialsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AwsS3CredentialsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AwsS3CredentialsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AwsS3CredentialsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AwsS3CredentialsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AwsS3CredentialsValidationError) ErrorName() string { return "AwsS3CredentialsValidationError" }

// Error satisfies the builtin error interface
func (e AwsS3CredentialsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAwsS3Credentials.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AwsS3CredentialsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AwsS3CredentialsValidationError{}

// Validate checks the field values on GcpCloudStorageConnectionConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GcpCloudStorageConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GcpCloudStorageConnectionConfig with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GcpCloudStorageConnectionConfigMultiError, or nil if none found.
func (m *GcpCloudStorageConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *GcpCloudStorageConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bucket

	if m.PathPrefix != nil {
		// no validation rules for PathPrefix
	}

	if m.ServiceAccountCredentials != nil {
		// no validation rules for ServiceAccountCredentials
	}

	if len(errors) > 0 {
		return GcpCloudStorageConnectionConfigMultiError(errors)
	}

	return nil
}

// GcpCloudStorageConnectionConfigMultiError is an error wrapping multiple
// validation errors returned by GcpCloudStorageConnectionConfig.ValidateAll()
// if the designated constraints aren't met.
type GcpCloudStorageConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GcpCloudStorageConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GcpCloudStorageConnectionConfigMultiError) AllErrors() []error { return m }

// GcpCloudStorageConnectionConfigValidationError is the validation error
// returned by GcpCloudStorageConnectionConfig.Validate if the designated
// constraints aren't met.
type GcpCloudStorageConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GcpCloudStorageConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GcpCloudStorageConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GcpCloudStorageConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GcpCloudStorageConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GcpCloudStorageConnectionConfigValidationError) ErrorName() string {
	return "GcpCloudStorageConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e GcpCloudStorageConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGcpCloudStorageConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GcpCloudStorageConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GcpCloudStorageConnectionConfigValidationError{}

// Validate checks the field values on IsConnectionNameAvailableRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *IsConnectionNameAvailableRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsConnectionNameAvailableRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// IsConnectionNameAvailableRequestMultiError, or nil if none found.
func (m *IsConnectionNameAvailableRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IsConnectionNameAvailableRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for ConnectionName

	if len(errors) > 0 {
		return IsConnectionNameAvailableRequestMultiError(errors)
	}

	return nil
}

// IsConnectionNameAvailableRequestMultiError is an error wrapping multiple
// validation errors returned by
// IsConnectionNameAvailableRequest.ValidateAll() if the designated
// constraints aren't met.
type IsConnectionNameAvailableRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsConnectionNameAvailableRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsConnectionNameAvailableRequestMultiError) AllErrors() []error { return m }

// IsConnectionNameAvailableRequestValidationError is the validation error
// returned by IsConnectionNameAvailableRequest.Validate if the designated
// constraints aren't met.
type IsConnectionNameAvailableRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsConnectionNameAvailableRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsConnectionNameAvailableRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsConnectionNameAvailableRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsConnectionNameAvailableRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsConnectionNameAvailableRequestValidationError) ErrorName() string {
	return "IsConnectionNameAvailableRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsConnectionNameAvailableRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsConnectionNameAvailableRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsConnectionNameAvailableRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsConnectionNameAvailableRequestValidationError{}

// Validate checks the field values on IsConnectionNameAvailableResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *IsConnectionNameAvailableResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsConnectionNameAvailableResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// IsConnectionNameAvailableResponseMultiError, or nil if none found.
func (m *IsConnectionNameAvailableResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IsConnectionNameAvailableResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsAvailable

	if len(errors) > 0 {
		return IsConnectionNameAvailableResponseMultiError(errors)
	}

	return nil
}

// IsConnectionNameAvailableResponseMultiError is an error wrapping multiple
// validation errors returned by
// IsConnectionNameAvailableResponse.ValidateAll() if the designated
// constraints aren't met.
type IsConnectionNameAvailableResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsConnectionNameAvailableResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsConnectionNameAvailableResponseMultiError) AllErrors() []error { return m }

// IsConnectionNameAvailableResponseValidationError is the validation error
// returned by IsConnectionNameAvailableResponse.Validate if the designated
// constraints aren't met.
type IsConnectionNameAvailableResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsConnectionNameAvailableResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsConnectionNameAvailableResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsConnectionNameAvailableResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsConnectionNameAvailableResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsConnectionNameAvailableResponseValidationError) ErrorName() string {
	return "IsConnectionNameAvailableResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IsConnectionNameAvailableResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsConnectionNameAvailableResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsConnectionNameAvailableResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsConnectionNameAvailableResponseValidationError{}

// Validate checks the field values on CheckSqlQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckSqlQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckSqlQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckSqlQueryRequestMultiError, or nil if none found.
func (m *CheckSqlQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckSqlQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Query

	if len(errors) > 0 {
		return CheckSqlQueryRequestMultiError(errors)
	}

	return nil
}

// CheckSqlQueryRequestMultiError is an error wrapping multiple validation
// errors returned by CheckSqlQueryRequest.ValidateAll() if the designated
// constraints aren't met.
type CheckSqlQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckSqlQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckSqlQueryRequestMultiError) AllErrors() []error { return m }

// CheckSqlQueryRequestValidationError is the validation error returned by
// CheckSqlQueryRequest.Validate if the designated constraints aren't met.
type CheckSqlQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckSqlQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckSqlQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckSqlQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckSqlQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckSqlQueryRequestValidationError) ErrorName() string {
	return "CheckSqlQueryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckSqlQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckSqlQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckSqlQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckSqlQueryRequestValidationError{}

// Validate checks the field values on CheckSqlQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckSqlQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckSqlQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckSqlQueryResponseMultiError, or nil if none found.
func (m *CheckSqlQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckSqlQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsValid

	if m.ErorrMessage != nil {
		// no validation rules for ErorrMessage
	}

	if len(errors) > 0 {
		return CheckSqlQueryResponseMultiError(errors)
	}

	return nil
}

// CheckSqlQueryResponseMultiError is an error wrapping multiple validation
// errors returned by CheckSqlQueryResponse.ValidateAll() if the designated
// constraints aren't met.
type CheckSqlQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckSqlQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckSqlQueryResponseMultiError) AllErrors() []error { return m }

// CheckSqlQueryResponseValidationError is the validation error returned by
// CheckSqlQueryResponse.Validate if the designated constraints aren't met.
type CheckSqlQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckSqlQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckSqlQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckSqlQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckSqlQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckSqlQueryResponseValidationError) ErrorName() string {
	return "CheckSqlQueryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckSqlQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckSqlQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckSqlQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckSqlQueryResponseValidationError{}
