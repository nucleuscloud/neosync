// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: mgmt/v1alpha1/connection.proto

package mgmtv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GetConnectionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionsRequestMultiError, or nil if none found.
func (m *GetConnectionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return GetConnectionsRequestMultiError(errors)
	}

	return nil
}

// GetConnectionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetConnectionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionsRequestMultiError) AllErrors() []error { return m }

// GetConnectionsRequestValidationError is the validation error returned by
// GetConnectionsRequest.Validate if the designated constraints aren't met.
type GetConnectionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionsRequestValidationError) ErrorName() string {
	return "GetConnectionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionsRequestValidationError{}

// Validate checks the field values on GetConnectionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionsResponseMultiError, or nil if none found.
func (m *GetConnectionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetConnectionsResponseValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetConnectionsResponseValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetConnectionsResponseValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetConnectionsResponseMultiError(errors)
	}

	return nil
}

// GetConnectionsResponseMultiError is an error wrapping multiple validation
// errors returned by GetConnectionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionsResponseMultiError) AllErrors() []error { return m }

// GetConnectionsResponseValidationError is the validation error returned by
// GetConnectionsResponse.Validate if the designated constraints aren't met.
type GetConnectionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionsResponseValidationError) ErrorName() string {
	return "GetConnectionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionsResponseValidationError{}

// Validate checks the field values on GetConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionRequestMultiError, or nil if none found.
func (m *GetConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetConnectionRequestMultiError(errors)
	}

	return nil
}

// GetConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by GetConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionRequestMultiError) AllErrors() []error { return m }

// GetConnectionRequestValidationError is the validation error returned by
// GetConnectionRequest.Validate if the designated constraints aren't met.
type GetConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionRequestValidationError) ErrorName() string {
	return "GetConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionRequestValidationError{}

// Validate checks the field values on GetConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionResponseMultiError, or nil if none found.
func (m *GetConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetConnectionResponseMultiError(errors)
	}

	return nil
}

// GetConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by GetConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionResponseMultiError) AllErrors() []error { return m }

// GetConnectionResponseValidationError is the validation error returned by
// GetConnectionResponse.Validate if the designated constraints aren't met.
type GetConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionResponseValidationError) ErrorName() string {
	return "GetConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionResponseValidationError{}

// Validate checks the field values on CreateConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectionRequestMultiError, or nil if none found.
func (m *CreateConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectionRequestMultiError(errors)
	}

	return nil
}

// CreateConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectionRequestMultiError) AllErrors() []error { return m }

// CreateConnectionRequestValidationError is the validation error returned by
// CreateConnectionRequest.Validate if the designated constraints aren't met.
type CreateConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectionRequestValidationError) ErrorName() string {
	return "CreateConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectionRequestValidationError{}

// Validate checks the field values on CreateConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectionResponseMultiError, or nil if none found.
func (m *CreateConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectionResponseMultiError(errors)
	}

	return nil
}

// CreateConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectionResponseMultiError) AllErrors() []error { return m }

// CreateConnectionResponseValidationError is the validation error returned by
// CreateConnectionResponse.Validate if the designated constraints aren't met.
type CreateConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectionResponseValidationError) ErrorName() string {
	return "CreateConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectionResponseValidationError{}

// Validate checks the field values on UpdateConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateConnectionRequestMultiError, or nil if none found.
func (m *UpdateConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateConnectionRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateConnectionRequestMultiError(errors)
	}

	return nil
}

// UpdateConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateConnectionRequestMultiError) AllErrors() []error { return m }

// UpdateConnectionRequestValidationError is the validation error returned by
// UpdateConnectionRequest.Validate if the designated constraints aren't met.
type UpdateConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateConnectionRequestValidationError) ErrorName() string {
	return "UpdateConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateConnectionRequestValidationError{}

// Validate checks the field values on UpdateConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateConnectionResponseMultiError, or nil if none found.
func (m *UpdateConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateConnectionResponseMultiError(errors)
	}

	return nil
}

// UpdateConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateConnectionResponseMultiError) AllErrors() []error { return m }

// UpdateConnectionResponseValidationError is the validation error returned by
// UpdateConnectionResponse.Validate if the designated constraints aren't met.
type UpdateConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateConnectionResponseValidationError) ErrorName() string {
	return "UpdateConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateConnectionResponseValidationError{}

// Validate checks the field values on DeleteConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConnectionRequestMultiError, or nil if none found.
func (m *DeleteConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteConnectionRequestMultiError(errors)
	}

	return nil
}

// DeleteConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConnectionRequestMultiError) AllErrors() []error { return m }

// DeleteConnectionRequestValidationError is the validation error returned by
// DeleteConnectionRequest.Validate if the designated constraints aren't met.
type DeleteConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConnectionRequestValidationError) ErrorName() string {
	return "DeleteConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConnectionRequestValidationError{}

// Validate checks the field values on DeleteConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConnectionResponseMultiError, or nil if none found.
func (m *DeleteConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteConnectionResponseMultiError(errors)
	}

	return nil
}

// DeleteConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConnectionResponseMultiError) AllErrors() []error { return m }

// DeleteConnectionResponseValidationError is the validation error returned by
// DeleteConnectionResponse.Validate if the designated constraints aren't met.
type DeleteConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConnectionResponseValidationError) ErrorName() string {
	return "DeleteConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConnectionResponseValidationError{}

// Validate checks the field values on CheckConnectionConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckConnectionConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckConnectionConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckConnectionConfigRequestMultiError, or nil if none found.
func (m *CheckConnectionConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckConnectionConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckConnectionConfigRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckConnectionConfigRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckConnectionConfigRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckConnectionConfigRequestMultiError(errors)
	}

	return nil
}

// CheckConnectionConfigRequestMultiError is an error wrapping multiple
// validation errors returned by CheckConnectionConfigRequest.ValidateAll() if
// the designated constraints aren't met.
type CheckConnectionConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckConnectionConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckConnectionConfigRequestMultiError) AllErrors() []error { return m }

// CheckConnectionConfigRequestValidationError is the validation error returned
// by CheckConnectionConfigRequest.Validate if the designated constraints
// aren't met.
type CheckConnectionConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckConnectionConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckConnectionConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckConnectionConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckConnectionConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckConnectionConfigRequestValidationError) ErrorName() string {
	return "CheckConnectionConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckConnectionConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckConnectionConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckConnectionConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckConnectionConfigRequestValidationError{}

// Validate checks the field values on CheckConnectionConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckConnectionConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckConnectionConfigResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CheckConnectionConfigResponseMultiError, or nil if none found.
func (m *CheckConnectionConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckConnectionConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsConnected

	if m.ConnectionError != nil {
		// no validation rules for ConnectionError
	}

	if len(errors) > 0 {
		return CheckConnectionConfigResponseMultiError(errors)
	}

	return nil
}

// CheckConnectionConfigResponseMultiError is an error wrapping multiple
// validation errors returned by CheckConnectionConfigResponse.ValidateAll()
// if the designated constraints aren't met.
type CheckConnectionConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckConnectionConfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckConnectionConfigResponseMultiError) AllErrors() []error { return m }

// CheckConnectionConfigResponseValidationError is the validation error
// returned by CheckConnectionConfigResponse.Validate if the designated
// constraints aren't met.
type CheckConnectionConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckConnectionConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckConnectionConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckConnectionConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckConnectionConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckConnectionConfigResponseValidationError) ErrorName() string {
	return "CheckConnectionConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckConnectionConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckConnectionConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckConnectionConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckConnectionConfigResponseValidationError{}

// Validate checks the field values on Connection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectionMultiError, or
// nil if none found.
func (m *Connection) ValidateAll() error {
	return m.validate(true)
}

func (m *Connection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedByUserId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UpdatedByUserId

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AccountId

	if len(errors) > 0 {
		return ConnectionMultiError(errors)
	}

	return nil
}

// ConnectionMultiError is an error wrapping multiple validation errors
// returned by Connection.ValidateAll() if the designated constraints aren't met.
type ConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionMultiError) AllErrors() []error { return m }

// ConnectionValidationError is the validation error returned by
// Connection.Validate if the designated constraints aren't met.
type ConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionValidationError) ErrorName() string { return "ConnectionValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionValidationError{}

// Validate checks the field values on ConnectionConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectionConfigMultiError, or nil if none found.
func (m *ConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Config.(type) {
	case *ConnectionConfig_PgConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPgConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "PgConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "PgConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPgConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "PgConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_AwsS3Config:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAwsS3Config()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "AwsS3Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "AwsS3Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAwsS3Config()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "AwsS3Config",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_MysqlConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMysqlConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "MysqlConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "MysqlConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMysqlConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "MysqlConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConnectionConfigMultiError(errors)
	}

	return nil
}

// ConnectionConfigMultiError is an error wrapping multiple validation errors
// returned by ConnectionConfig.ValidateAll() if the designated constraints
// aren't met.
type ConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionConfigMultiError) AllErrors() []error { return m }

// ConnectionConfigValidationError is the validation error returned by
// ConnectionConfig.Validate if the designated constraints aren't met.
type ConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionConfigValidationError) ErrorName() string { return "ConnectionConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionConfigValidationError{}

// Validate checks the field values on PostgresConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostgresConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostgresConnectionConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostgresConnectionConfigMultiError, or nil if none found.
func (m *PostgresConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PostgresConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.ConnectionConfig.(type) {
	case *PostgresConnectionConfig_Url:
		if v == nil {
			err := PostgresConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Url
	case *PostgresConnectionConfig_Connection:
		if v == nil {
			err := PostgresConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PostgresConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PostgresConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PostgresConnectionConfigValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PostgresConnectionConfigMultiError(errors)
	}

	return nil
}

// PostgresConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by PostgresConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type PostgresConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostgresConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostgresConnectionConfigMultiError) AllErrors() []error { return m }

// PostgresConnectionConfigValidationError is the validation error returned by
// PostgresConnectionConfig.Validate if the designated constraints aren't met.
type PostgresConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostgresConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostgresConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostgresConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostgresConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostgresConnectionConfigValidationError) ErrorName() string {
	return "PostgresConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e PostgresConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostgresConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostgresConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostgresConnectionConfigValidationError{}

// Validate checks the field values on PostgresConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostgresConnection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostgresConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostgresConnectionMultiError, or nil if none found.
func (m *PostgresConnection) ValidateAll() error {
	return m.validate(true)
}

func (m *PostgresConnection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	// no validation rules for Port

	// no validation rules for Name

	// no validation rules for User

	// no validation rules for Pass

	if m.SslMode != nil {
		// no validation rules for SslMode
	}

	if len(errors) > 0 {
		return PostgresConnectionMultiError(errors)
	}

	return nil
}

// PostgresConnectionMultiError is an error wrapping multiple validation errors
// returned by PostgresConnection.ValidateAll() if the designated constraints
// aren't met.
type PostgresConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostgresConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostgresConnectionMultiError) AllErrors() []error { return m }

// PostgresConnectionValidationError is the validation error returned by
// PostgresConnection.Validate if the designated constraints aren't met.
type PostgresConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostgresConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostgresConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostgresConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostgresConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostgresConnectionValidationError) ErrorName() string {
	return "PostgresConnectionValidationError"
}

// Error satisfies the builtin error interface
func (e PostgresConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostgresConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostgresConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostgresConnectionValidationError{}

// Validate checks the field values on MysqlConnection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MysqlConnection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MysqlConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MysqlConnectionMultiError, or nil if none found.
func (m *MysqlConnection) ValidateAll() error {
	return m.validate(true)
}

func (m *MysqlConnection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for User

	// no validation rules for Pass

	// no validation rules for Protocol

	// no validation rules for Host

	// no validation rules for Port

	// no validation rules for Name

	if len(errors) > 0 {
		return MysqlConnectionMultiError(errors)
	}

	return nil
}

// MysqlConnectionMultiError is an error wrapping multiple validation errors
// returned by MysqlConnection.ValidateAll() if the designated constraints
// aren't met.
type MysqlConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MysqlConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MysqlConnectionMultiError) AllErrors() []error { return m }

// MysqlConnectionValidationError is the validation error returned by
// MysqlConnection.Validate if the designated constraints aren't met.
type MysqlConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MysqlConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MysqlConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MysqlConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MysqlConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MysqlConnectionValidationError) ErrorName() string { return "MysqlConnectionValidationError" }

// Error satisfies the builtin error interface
func (e MysqlConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMysqlConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MysqlConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MysqlConnectionValidationError{}

// Validate checks the field values on MysqlConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MysqlConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MysqlConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MysqlConnectionConfigMultiError, or nil if none found.
func (m *MysqlConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MysqlConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.ConnectionConfig.(type) {
	case *MysqlConnectionConfig_Url:
		if v == nil {
			err := MysqlConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Url
	case *MysqlConnectionConfig_Connection:
		if v == nil {
			err := MysqlConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConnection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MysqlConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MysqlConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MysqlConnectionConfigValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MysqlConnectionConfigMultiError(errors)
	}

	return nil
}

// MysqlConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by MysqlConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type MysqlConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MysqlConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MysqlConnectionConfigMultiError) AllErrors() []error { return m }

// MysqlConnectionConfigValidationError is the validation error returned by
// MysqlConnectionConfig.Validate if the designated constraints aren't met.
type MysqlConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MysqlConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MysqlConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MysqlConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MysqlConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MysqlConnectionConfigValidationError) ErrorName() string {
	return "MysqlConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e MysqlConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMysqlConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MysqlConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MysqlConnectionConfigValidationError{}

// Validate checks the field values on AwsS3ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AwsS3ConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AwsS3ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AwsS3ConnectionConfigMultiError, or nil if none found.
func (m *AwsS3ConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AwsS3ConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BucketArn

	if m.PathPrefix != nil {
		// no validation rules for PathPrefix
	}

	if m.Credentials != nil {

		if all {
			switch v := interface{}(m.GetCredentials()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AwsS3ConnectionConfigValidationError{
						field:  "Credentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AwsS3ConnectionConfigValidationError{
						field:  "Credentials",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCredentials()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AwsS3ConnectionConfigValidationError{
					field:  "Credentials",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Region != nil {
		// no validation rules for Region
	}

	if m.Endpoint != nil {
		// no validation rules for Endpoint
	}

	if len(errors) > 0 {
		return AwsS3ConnectionConfigMultiError(errors)
	}

	return nil
}

// AwsS3ConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by AwsS3ConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type AwsS3ConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AwsS3ConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AwsS3ConnectionConfigMultiError) AllErrors() []error { return m }

// AwsS3ConnectionConfigValidationError is the validation error returned by
// AwsS3ConnectionConfig.Validate if the designated constraints aren't met.
type AwsS3ConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AwsS3ConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AwsS3ConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AwsS3ConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AwsS3ConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AwsS3ConnectionConfigValidationError) ErrorName() string {
	return "AwsS3ConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AwsS3ConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAwsS3ConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AwsS3ConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AwsS3ConnectionConfigValidationError{}

// Validate checks the field values on AwsS3Credentials with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AwsS3Credentials) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AwsS3Credentials with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AwsS3CredentialsMultiError, or nil if none found.
func (m *AwsS3Credentials) ValidateAll() error {
	return m.validate(true)
}

func (m *AwsS3Credentials) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Profile != nil {
		// no validation rules for Profile
	}

	if m.AccessKeyId != nil {
		// no validation rules for AccessKeyId
	}

	if m.SecretAccessKey != nil {
		// no validation rules for SecretAccessKey
	}

	if m.SessionToken != nil {
		// no validation rules for SessionToken
	}

	if m.FromEc2Role != nil {
		// no validation rules for FromEc2Role
	}

	if m.RoleArn != nil {
		// no validation rules for RoleArn
	}

	if m.RoleExternalId != nil {
		// no validation rules for RoleExternalId
	}

	if len(errors) > 0 {
		return AwsS3CredentialsMultiError(errors)
	}

	return nil
}

// AwsS3CredentialsMultiError is an error wrapping multiple validation errors
// returned by AwsS3Credentials.ValidateAll() if the designated constraints
// aren't met.
type AwsS3CredentialsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AwsS3CredentialsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AwsS3CredentialsMultiError) AllErrors() []error { return m }

// AwsS3CredentialsValidationError is the validation error returned by
// AwsS3Credentials.Validate if the designated constraints aren't met.
type AwsS3CredentialsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AwsS3CredentialsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AwsS3CredentialsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AwsS3CredentialsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AwsS3CredentialsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AwsS3CredentialsValidationError) ErrorName() string { return "AwsS3CredentialsValidationError" }

// Error satisfies the builtin error interface
func (e AwsS3CredentialsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAwsS3Credentials.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AwsS3CredentialsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AwsS3CredentialsValidationError{}

// Validate checks the field values on IsConnectionNameAvailableRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *IsConnectionNameAvailableRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsConnectionNameAvailableRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// IsConnectionNameAvailableRequestMultiError, or nil if none found.
func (m *IsConnectionNameAvailableRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IsConnectionNameAvailableRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for ConnectionName

	if len(errors) > 0 {
		return IsConnectionNameAvailableRequestMultiError(errors)
	}

	return nil
}

// IsConnectionNameAvailableRequestMultiError is an error wrapping multiple
// validation errors returned by
// IsConnectionNameAvailableRequest.ValidateAll() if the designated
// constraints aren't met.
type IsConnectionNameAvailableRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsConnectionNameAvailableRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsConnectionNameAvailableRequestMultiError) AllErrors() []error { return m }

// IsConnectionNameAvailableRequestValidationError is the validation error
// returned by IsConnectionNameAvailableRequest.Validate if the designated
// constraints aren't met.
type IsConnectionNameAvailableRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsConnectionNameAvailableRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsConnectionNameAvailableRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsConnectionNameAvailableRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsConnectionNameAvailableRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsConnectionNameAvailableRequestValidationError) ErrorName() string {
	return "IsConnectionNameAvailableRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsConnectionNameAvailableRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsConnectionNameAvailableRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsConnectionNameAvailableRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsConnectionNameAvailableRequestValidationError{}

// Validate checks the field values on IsConnectionNameAvailableResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *IsConnectionNameAvailableResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsConnectionNameAvailableResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// IsConnectionNameAvailableResponseMultiError, or nil if none found.
func (m *IsConnectionNameAvailableResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IsConnectionNameAvailableResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsAvailable

	if len(errors) > 0 {
		return IsConnectionNameAvailableResponseMultiError(errors)
	}

	return nil
}

// IsConnectionNameAvailableResponseMultiError is an error wrapping multiple
// validation errors returned by
// IsConnectionNameAvailableResponse.ValidateAll() if the designated
// constraints aren't met.
type IsConnectionNameAvailableResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsConnectionNameAvailableResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsConnectionNameAvailableResponseMultiError) AllErrors() []error { return m }

// IsConnectionNameAvailableResponseValidationError is the validation error
// returned by IsConnectionNameAvailableResponse.Validate if the designated
// constraints aren't met.
type IsConnectionNameAvailableResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsConnectionNameAvailableResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsConnectionNameAvailableResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsConnectionNameAvailableResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsConnectionNameAvailableResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsConnectionNameAvailableResponseValidationError) ErrorName() string {
	return "IsConnectionNameAvailableResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IsConnectionNameAvailableResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsConnectionNameAvailableResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsConnectionNameAvailableResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsConnectionNameAvailableResponseValidationError{}

// Validate checks the field values on DatabaseColumn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatabaseColumn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatabaseColumn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatabaseColumnMultiError,
// or nil if none found.
func (m *DatabaseColumn) ValidateAll() error {
	return m.validate(true)
}

func (m *DatabaseColumn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Schema

	// no validation rules for Table

	// no validation rules for Column

	// no validation rules for DataType

	if len(errors) > 0 {
		return DatabaseColumnMultiError(errors)
	}

	return nil
}

// DatabaseColumnMultiError is an error wrapping multiple validation errors
// returned by DatabaseColumn.ValidateAll() if the designated constraints
// aren't met.
type DatabaseColumnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseColumnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseColumnMultiError) AllErrors() []error { return m }

// DatabaseColumnValidationError is the validation error returned by
// DatabaseColumn.Validate if the designated constraints aren't met.
type DatabaseColumnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseColumnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseColumnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseColumnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseColumnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseColumnValidationError) ErrorName() string { return "DatabaseColumnValidationError" }

// Error satisfies the builtin error interface
func (e DatabaseColumnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabaseColumn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseColumnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseColumnValidationError{}

// Validate checks the field values on GetConnectionSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionSchemaRequestMultiError, or nil if none found.
func (m *GetConnectionSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetConnectionSchemaRequestMultiError(errors)
	}

	return nil
}

// GetConnectionSchemaRequestMultiError is an error wrapping multiple
// validation errors returned by GetConnectionSchemaRequest.ValidateAll() if
// the designated constraints aren't met.
type GetConnectionSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionSchemaRequestMultiError) AllErrors() []error { return m }

// GetConnectionSchemaRequestValidationError is the validation error returned
// by GetConnectionSchemaRequest.Validate if the designated constraints aren't met.
type GetConnectionSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionSchemaRequestValidationError) ErrorName() string {
	return "GetConnectionSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionSchemaRequestValidationError{}

// Validate checks the field values on GetConnectionSchemaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionSchemaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionSchemaResponseMultiError, or nil if none found.
func (m *GetConnectionSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSchemas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetConnectionSchemaResponseValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetConnectionSchemaResponseValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetConnectionSchemaResponseValidationError{
					field:  fmt.Sprintf("Schemas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetConnectionSchemaResponseMultiError(errors)
	}

	return nil
}

// GetConnectionSchemaResponseMultiError is an error wrapping multiple
// validation errors returned by GetConnectionSchemaResponse.ValidateAll() if
// the designated constraints aren't met.
type GetConnectionSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionSchemaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionSchemaResponseMultiError) AllErrors() []error { return m }

// GetConnectionSchemaResponseValidationError is the validation error returned
// by GetConnectionSchemaResponse.Validate if the designated constraints
// aren't met.
type GetConnectionSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionSchemaResponseValidationError) ErrorName() string {
	return "GetConnectionSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionSchemaResponseValidationError{}

// Validate checks the field values on CheckSqlQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckSqlQueryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckSqlQueryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckSqlQueryRequestMultiError, or nil if none found.
func (m *CheckSqlQueryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckSqlQueryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Query

	if len(errors) > 0 {
		return CheckSqlQueryRequestMultiError(errors)
	}

	return nil
}

// CheckSqlQueryRequestMultiError is an error wrapping multiple validation
// errors returned by CheckSqlQueryRequest.ValidateAll() if the designated
// constraints aren't met.
type CheckSqlQueryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckSqlQueryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckSqlQueryRequestMultiError) AllErrors() []error { return m }

// CheckSqlQueryRequestValidationError is the validation error returned by
// CheckSqlQueryRequest.Validate if the designated constraints aren't met.
type CheckSqlQueryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckSqlQueryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckSqlQueryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckSqlQueryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckSqlQueryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckSqlQueryRequestValidationError) ErrorName() string {
	return "CheckSqlQueryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckSqlQueryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckSqlQueryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckSqlQueryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckSqlQueryRequestValidationError{}

// Validate checks the field values on CheckSqlQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckSqlQueryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckSqlQueryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckSqlQueryResponseMultiError, or nil if none found.
func (m *CheckSqlQueryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckSqlQueryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsValid

	if m.ErorrMessage != nil {
		// no validation rules for ErorrMessage
	}

	if len(errors) > 0 {
		return CheckSqlQueryResponseMultiError(errors)
	}

	return nil
}

// CheckSqlQueryResponseMultiError is an error wrapping multiple validation
// errors returned by CheckSqlQueryResponse.ValidateAll() if the designated
// constraints aren't met.
type CheckSqlQueryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckSqlQueryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckSqlQueryResponseMultiError) AllErrors() []error { return m }

// CheckSqlQueryResponseValidationError is the validation error returned by
// CheckSqlQueryResponse.Validate if the designated constraints aren't met.
type CheckSqlQueryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckSqlQueryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckSqlQueryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckSqlQueryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckSqlQueryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckSqlQueryResponseValidationError) ErrorName() string {
	return "CheckSqlQueryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckSqlQueryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckSqlQueryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckSqlQueryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckSqlQueryResponseValidationError{}

// Validate checks the field values on GetConnectionDataStreamRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionDataStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionDataStreamRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetConnectionDataStreamRequestMultiError, or nil if none found.
func (m *GetConnectionDataStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionDataStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceConnectionId

	// no validation rules for Schema

	// no validation rules for Table

	if len(errors) > 0 {
		return GetConnectionDataStreamRequestMultiError(errors)
	}

	return nil
}

// GetConnectionDataStreamRequestMultiError is an error wrapping multiple
// validation errors returned by GetConnectionDataStreamRequest.ValidateAll()
// if the designated constraints aren't met.
type GetConnectionDataStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionDataStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionDataStreamRequestMultiError) AllErrors() []error { return m }

// GetConnectionDataStreamRequestValidationError is the validation error
// returned by GetConnectionDataStreamRequest.Validate if the designated
// constraints aren't met.
type GetConnectionDataStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionDataStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionDataStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionDataStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionDataStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionDataStreamRequestValidationError) ErrorName() string {
	return "GetConnectionDataStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionDataStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionDataStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionDataStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionDataStreamRequestValidationError{}

// Validate checks the field values on GetConnectionDataStreamResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionDataStreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionDataStreamResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetConnectionDataStreamResponseMultiError, or nil if none found.
func (m *GetConnectionDataStreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionDataStreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetRow()))
		i := 0
		for key := range m.GetRow() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRow()[key]
			_ = val

			// no validation rules for Row[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetConnectionDataStreamResponseValidationError{
							field:  fmt.Sprintf("Row[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetConnectionDataStreamResponseValidationError{
							field:  fmt.Sprintf("Row[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetConnectionDataStreamResponseValidationError{
						field:  fmt.Sprintf("Row[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetConnectionDataStreamResponseMultiError(errors)
	}

	return nil
}

// GetConnectionDataStreamResponseMultiError is an error wrapping multiple
// validation errors returned by GetConnectionDataStreamResponse.ValidateAll()
// if the designated constraints aren't met.
type GetConnectionDataStreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionDataStreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionDataStreamResponseMultiError) AllErrors() []error { return m }

// GetConnectionDataStreamResponseValidationError is the validation error
// returned by GetConnectionDataStreamResponse.Validate if the designated
// constraints aren't met.
type GetConnectionDataStreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionDataStreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionDataStreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionDataStreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionDataStreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionDataStreamResponseValidationError) ErrorName() string {
	return "GetConnectionDataStreamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionDataStreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionDataStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionDataStreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionDataStreamResponseValidationError{}

// Validate checks the field values on Struct with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Struct) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Struct with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StructMultiError, or nil if none found.
func (m *Struct) ValidateAll() error {
	return m.validate(true)
}

func (m *Struct) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetFields()))
		i := 0
		for key := range m.GetFields() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetFields()[key]
			_ = val

			// no validation rules for Fields[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, StructValidationError{
							field:  fmt.Sprintf("Fields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, StructValidationError{
							field:  fmt.Sprintf("Fields[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return StructValidationError{
						field:  fmt.Sprintf("Fields[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return StructMultiError(errors)
	}

	return nil
}

// StructMultiError is an error wrapping multiple validation errors returned by
// Struct.ValidateAll() if the designated constraints aren't met.
type StructMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StructMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StructMultiError) AllErrors() []error { return m }

// StructValidationError is the validation error returned by Struct.Validate if
// the designated constraints aren't met.
type StructValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StructValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StructValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StructValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StructValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StructValidationError) ErrorName() string { return "StructValidationError" }

// Error satisfies the builtin error interface
func (e StructValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStruct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StructValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StructValidationError{}

// Validate checks the field values on Value with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Value) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Value with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ValueMultiError, or nil if none found.
func (m *Value) ValidateAll() error {
	return m.validate(true)
}

func (m *Value) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Kind.(type) {
	case *Value_NullValue:
		if v == nil {
			err := ValueValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for NullValue
	case *Value_NumberValue:
		if v == nil {
			err := ValueValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for NumberValue
	case *Value_StringValue:
		if v == nil {
			err := ValueValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for StringValue
	case *Value_BoolValue:
		if v == nil {
			err := ValueValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for BoolValue
	case *Value_StructValue:
		if v == nil {
			err := ValueValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStructValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "StructValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "StructValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStructValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueValidationError{
					field:  "StructValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Value_ListValue:
		if v == nil {
			err := ValueValidationError{
				field:  "Kind",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetListValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "ListValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ValueValidationError{
						field:  "ListValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetListValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ValueValidationError{
					field:  "ListValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ValueMultiError(errors)
	}

	return nil
}

// ValueMultiError is an error wrapping multiple validation errors returned by
// Value.ValidateAll() if the designated constraints aren't met.
type ValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValueMultiError) AllErrors() []error { return m }

// ValueValidationError is the validation error returned by Value.Validate if
// the designated constraints aren't met.
type ValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValueValidationError) ErrorName() string { return "ValueValidationError" }

// Error satisfies the builtin error interface
func (e ValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValueValidationError{}

// Validate checks the field values on ListValue with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListValue with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListValueMultiError, or nil
// if none found.
func (m *ListValue) ValidateAll() error {
	return m.validate(true)
}

func (m *ListValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListValueValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListValueValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListValueValidationError{
					field:  fmt.Sprintf("Values[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListValueMultiError(errors)
	}

	return nil
}

// ListValueMultiError is an error wrapping multiple validation errors returned
// by ListValue.ValidateAll() if the designated constraints aren't met.
type ListValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListValueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListValueMultiError) AllErrors() []error { return m }

// ListValueValidationError is the validation error returned by
// ListValue.Validate if the designated constraints aren't met.
type ListValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListValueValidationError) ErrorName() string { return "ListValueValidationError" }

// Error satisfies the builtin error interface
func (e ListValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListValueValidationError{}

// Validate checks the field values on GetConnectionForeignConstraintsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetConnectionForeignConstraintsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetConnectionForeignConstraintsRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GetConnectionForeignConstraintsRequestMultiError, or nil if none found.
func (m *GetConnectionForeignConstraintsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionForeignConstraintsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConnectionId

	if len(errors) > 0 {
		return GetConnectionForeignConstraintsRequestMultiError(errors)
	}

	return nil
}

// GetConnectionForeignConstraintsRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetConnectionForeignConstraintsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionForeignConstraintsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionForeignConstraintsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionForeignConstraintsRequestMultiError) AllErrors() []error { return m }

// GetConnectionForeignConstraintsRequestValidationError is the validation
// error returned by GetConnectionForeignConstraintsRequest.Validate if the
// designated constraints aren't met.
type GetConnectionForeignConstraintsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionForeignConstraintsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionForeignConstraintsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionForeignConstraintsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionForeignConstraintsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionForeignConstraintsRequestValidationError) ErrorName() string {
	return "GetConnectionForeignConstraintsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionForeignConstraintsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionForeignConstraintsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionForeignConstraintsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionForeignConstraintsRequestValidationError{}

// Validate checks the field values on ForeignConstraintTables with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ForeignConstraintTables) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForeignConstraintTables with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ForeignConstraintTablesMultiError, or nil if none found.
func (m *ForeignConstraintTables) ValidateAll() error {
	return m.validate(true)
}

func (m *ForeignConstraintTables) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ForeignConstraintTablesMultiError(errors)
	}

	return nil
}

// ForeignConstraintTablesMultiError is an error wrapping multiple validation
// errors returned by ForeignConstraintTables.ValidateAll() if the designated
// constraints aren't met.
type ForeignConstraintTablesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForeignConstraintTablesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForeignConstraintTablesMultiError) AllErrors() []error { return m }

// ForeignConstraintTablesValidationError is the validation error returned by
// ForeignConstraintTables.Validate if the designated constraints aren't met.
type ForeignConstraintTablesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForeignConstraintTablesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForeignConstraintTablesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForeignConstraintTablesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForeignConstraintTablesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForeignConstraintTablesValidationError) ErrorName() string {
	return "ForeignConstraintTablesValidationError"
}

// Error satisfies the builtin error interface
func (e ForeignConstraintTablesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForeignConstraintTables.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForeignConstraintTablesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForeignConstraintTablesValidationError{}

// Validate checks the field values on GetConnectionForeignConstraintsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetConnectionForeignConstraintsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetConnectionForeignConstraintsResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GetConnectionForeignConstraintsResponseMultiError, or nil if none found.
func (m *GetConnectionForeignConstraintsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionForeignConstraintsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetTableConstraints()))
		i := 0
		for key := range m.GetTableConstraints() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTableConstraints()[key]
			_ = val

			// no validation rules for TableConstraints[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetConnectionForeignConstraintsResponseValidationError{
							field:  fmt.Sprintf("TableConstraints[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetConnectionForeignConstraintsResponseValidationError{
							field:  fmt.Sprintf("TableConstraints[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetConnectionForeignConstraintsResponseValidationError{
						field:  fmt.Sprintf("TableConstraints[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetConnectionForeignConstraintsResponseMultiError(errors)
	}

	return nil
}

// GetConnectionForeignConstraintsResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetConnectionForeignConstraintsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionForeignConstraintsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionForeignConstraintsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionForeignConstraintsResponseMultiError) AllErrors() []error { return m }

// GetConnectionForeignConstraintsResponseValidationError is the validation
// error returned by GetConnectionForeignConstraintsResponse.Validate if the
// designated constraints aren't met.
type GetConnectionForeignConstraintsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionForeignConstraintsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionForeignConstraintsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionForeignConstraintsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionForeignConstraintsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionForeignConstraintsResponseValidationError) ErrorName() string {
	return "GetConnectionForeignConstraintsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionForeignConstraintsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionForeignConstraintsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionForeignConstraintsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionForeignConstraintsResponseValidationError{}
