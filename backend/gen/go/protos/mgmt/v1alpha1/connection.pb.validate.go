// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: mgmt/v1alpha1/connection.proto

package mgmtv1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _connection_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on GetConnectionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionsRequestMultiError, or nil if none found.
func (m *GetConnectionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetConnectionsRequestMultiError(errors)
	}

	return nil
}

// GetConnectionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetConnectionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionsRequestMultiError) AllErrors() []error { return m }

// GetConnectionsRequestValidationError is the validation error returned by
// GetConnectionsRequest.Validate if the designated constraints aren't met.
type GetConnectionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionsRequestValidationError) ErrorName() string {
	return "GetConnectionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionsRequestValidationError{}

// Validate checks the field values on GetConnectionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionsResponseMultiError, or nil if none found.
func (m *GetConnectionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConnections() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetConnectionsResponseValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetConnectionsResponseValidationError{
						field:  fmt.Sprintf("Connections[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetConnectionsResponseValidationError{
					field:  fmt.Sprintf("Connections[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetConnectionsResponseMultiError(errors)
	}

	return nil
}

// GetConnectionsResponseMultiError is an error wrapping multiple validation
// errors returned by GetConnectionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionsResponseMultiError) AllErrors() []error { return m }

// GetConnectionsResponseValidationError is the validation error returned by
// GetConnectionsResponse.Validate if the designated constraints aren't met.
type GetConnectionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionsResponseValidationError) ErrorName() string {
	return "GetConnectionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionsResponseValidationError{}

// Validate checks the field values on GetConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionRequestMultiError, or nil if none found.
func (m *GetConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = GetConnectionRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetConnectionRequestMultiError(errors)
	}

	return nil
}

func (m *GetConnectionRequest) _validateUuid(uuid string) error {
	if matched := _connection_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by GetConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionRequestMultiError) AllErrors() []error { return m }

// GetConnectionRequestValidationError is the validation error returned by
// GetConnectionRequest.Validate if the designated constraints aren't met.
type GetConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionRequestValidationError) ErrorName() string {
	return "GetConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionRequestValidationError{}

// Validate checks the field values on GetConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionResponseMultiError, or nil if none found.
func (m *GetConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetConnectionResponseMultiError(errors)
	}

	return nil
}

// GetConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by GetConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type GetConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionResponseMultiError) AllErrors() []error { return m }

// GetConnectionResponseValidationError is the validation error returned by
// GetConnectionResponse.Validate if the designated constraints aren't met.
type GetConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionResponseValidationError) ErrorName() string {
	return "GetConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionResponseValidationError{}

// Validate checks the field values on CreateConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectionRequestMultiError, or nil if none found.
func (m *CreateConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateConnectionRequest_Name_Pattern.MatchString(m.GetName()) {
		err := CreateConnectionRequestValidationError{
			field:  "Name",
			reason: "value does not match regex pattern \"^[a-z0-9-]{3,30}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectionRequestMultiError(errors)
	}

	return nil
}

// CreateConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectionRequestMultiError) AllErrors() []error { return m }

// CreateConnectionRequestValidationError is the validation error returned by
// CreateConnectionRequest.Validate if the designated constraints aren't met.
type CreateConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectionRequestValidationError) ErrorName() string {
	return "CreateConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectionRequestValidationError{}

var _CreateConnectionRequest_Name_Pattern = regexp.MustCompile("^[a-z0-9-]{3,30}$")

// Validate checks the field values on CreateConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConnectionResponseMultiError, or nil if none found.
func (m *CreateConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConnectionResponseMultiError(errors)
	}

	return nil
}

// CreateConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConnectionResponseMultiError) AllErrors() []error { return m }

// CreateConnectionResponseValidationError is the validation error returned by
// CreateConnectionResponse.Validate if the designated constraints aren't met.
type CreateConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConnectionResponseValidationError) ErrorName() string {
	return "CreateConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConnectionResponseValidationError{}

// Validate checks the field values on UpdateConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateConnectionRequestMultiError, or nil if none found.
func (m *UpdateConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = UpdateConnectionRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateConnectionRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateConnectionRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateConnectionRequestMultiError(errors)
	}

	return nil
}

func (m *UpdateConnectionRequest) _validateUuid(uuid string) error {
	if matched := _connection_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UpdateConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateConnectionRequestMultiError) AllErrors() []error { return m }

// UpdateConnectionRequestValidationError is the validation error returned by
// UpdateConnectionRequest.Validate if the designated constraints aren't met.
type UpdateConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateConnectionRequestValidationError) ErrorName() string {
	return "UpdateConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateConnectionRequestValidationError{}

// Validate checks the field values on UpdateConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateConnectionResponseMultiError, or nil if none found.
func (m *UpdateConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateConnectionResponseValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateConnectionResponseValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateConnectionResponseMultiError(errors)
	}

	return nil
}

// UpdateConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateConnectionResponseMultiError) AllErrors() []error { return m }

// UpdateConnectionResponseValidationError is the validation error returned by
// UpdateConnectionResponse.Validate if the designated constraints aren't met.
type UpdateConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateConnectionResponseValidationError) ErrorName() string {
	return "UpdateConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateConnectionResponseValidationError{}

// Validate checks the field values on DeleteConnectionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConnectionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConnectionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConnectionRequestMultiError, or nil if none found.
func (m *DeleteConnectionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConnectionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetId()); err != nil {
		err = DeleteConnectionRequestValidationError{
			field:  "Id",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteConnectionRequestMultiError(errors)
	}

	return nil
}

func (m *DeleteConnectionRequest) _validateUuid(uuid string) error {
	if matched := _connection_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// DeleteConnectionRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteConnectionRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteConnectionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConnectionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConnectionRequestMultiError) AllErrors() []error { return m }

// DeleteConnectionRequestValidationError is the validation error returned by
// DeleteConnectionRequest.Validate if the designated constraints aren't met.
type DeleteConnectionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConnectionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConnectionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConnectionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConnectionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConnectionRequestValidationError) ErrorName() string {
	return "DeleteConnectionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConnectionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConnectionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConnectionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConnectionRequestValidationError{}

// Validate checks the field values on DeleteConnectionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConnectionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConnectionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConnectionResponseMultiError, or nil if none found.
func (m *DeleteConnectionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConnectionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteConnectionResponseMultiError(errors)
	}

	return nil
}

// DeleteConnectionResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteConnectionResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteConnectionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConnectionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConnectionResponseMultiError) AllErrors() []error { return m }

// DeleteConnectionResponseValidationError is the validation error returned by
// DeleteConnectionResponse.Validate if the designated constraints aren't met.
type DeleteConnectionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConnectionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConnectionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConnectionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConnectionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConnectionResponseValidationError) ErrorName() string {
	return "DeleteConnectionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConnectionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConnectionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConnectionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConnectionResponseValidationError{}

// Validate checks the field values on CheckConnectionConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckConnectionConfigRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckConnectionConfigRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckConnectionConfigRequestMultiError, or nil if none found.
func (m *CheckConnectionConfigRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckConnectionConfigRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CheckConnectionConfigRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CheckConnectionConfigRequestValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CheckConnectionConfigRequestValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CheckConnectionConfigRequestMultiError(errors)
	}

	return nil
}

// CheckConnectionConfigRequestMultiError is an error wrapping multiple
// validation errors returned by CheckConnectionConfigRequest.ValidateAll() if
// the designated constraints aren't met.
type CheckConnectionConfigRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckConnectionConfigRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckConnectionConfigRequestMultiError) AllErrors() []error { return m }

// CheckConnectionConfigRequestValidationError is the validation error returned
// by CheckConnectionConfigRequest.Validate if the designated constraints
// aren't met.
type CheckConnectionConfigRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckConnectionConfigRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckConnectionConfigRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckConnectionConfigRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckConnectionConfigRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckConnectionConfigRequestValidationError) ErrorName() string {
	return "CheckConnectionConfigRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckConnectionConfigRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckConnectionConfigRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckConnectionConfigRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckConnectionConfigRequestValidationError{}

// Validate checks the field values on CheckConnectionConfigResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckConnectionConfigResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckConnectionConfigResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CheckConnectionConfigResponseMultiError, or nil if none found.
func (m *CheckConnectionConfigResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckConnectionConfigResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsConnected

	if m.ConnectionError != nil {
		// no validation rules for ConnectionError
	}

	if len(errors) > 0 {
		return CheckConnectionConfigResponseMultiError(errors)
	}

	return nil
}

// CheckConnectionConfigResponseMultiError is an error wrapping multiple
// validation errors returned by CheckConnectionConfigResponse.ValidateAll()
// if the designated constraints aren't met.
type CheckConnectionConfigResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckConnectionConfigResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckConnectionConfigResponseMultiError) AllErrors() []error { return m }

// CheckConnectionConfigResponseValidationError is the validation error
// returned by CheckConnectionConfigResponse.Validate if the designated
// constraints aren't met.
type CheckConnectionConfigResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckConnectionConfigResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckConnectionConfigResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckConnectionConfigResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckConnectionConfigResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckConnectionConfigResponseValidationError) ErrorName() string {
	return "CheckConnectionConfigResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckConnectionConfigResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckConnectionConfigResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckConnectionConfigResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckConnectionConfigResponseValidationError{}

// Validate checks the field values on Connection with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Connection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Connection with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConnectionMultiError, or
// nil if none found.
func (m *Connection) ValidateAll() error {
	return m.validate(true)
}

func (m *Connection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetConnectionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "ConnectionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "ConnectionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConnectionValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConnectionValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConnectionMultiError(errors)
	}

	return nil
}

// ConnectionMultiError is an error wrapping multiple validation errors
// returned by Connection.ValidateAll() if the designated constraints aren't met.
type ConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionMultiError) AllErrors() []error { return m }

// ConnectionValidationError is the validation error returned by
// Connection.Validate if the designated constraints aren't met.
type ConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionValidationError) ErrorName() string { return "ConnectionValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionValidationError{}

// Validate checks the field values on ConnectionConfig with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConnectionConfigMultiError, or nil if none found.
func (m *ConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofConfigPresent := false
	switch v := m.Config.(type) {
	case *ConnectionConfig_PgConfig:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetPgConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "PgConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "PgConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPgConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "PgConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ConnectionConfig_AwsS3Config:
		if v == nil {
			err := ConnectionConfigValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetAwsS3Config()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "AwsS3Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConnectionConfigValidationError{
						field:  "AwsS3Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAwsS3Config()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConnectionConfigValidationError{
					field:  "AwsS3Config",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofConfigPresent {
		err := ConnectionConfigValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConnectionConfigMultiError(errors)
	}

	return nil
}

// ConnectionConfigMultiError is an error wrapping multiple validation errors
// returned by ConnectionConfig.ValidateAll() if the designated constraints
// aren't met.
type ConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConnectionConfigMultiError) AllErrors() []error { return m }

// ConnectionConfigValidationError is the validation error returned by
// ConnectionConfig.Validate if the designated constraints aren't met.
type ConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConnectionConfigValidationError) ErrorName() string { return "ConnectionConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConnectionConfigValidationError{}

// Validate checks the field values on PostgresConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostgresConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostgresConnectionConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostgresConnectionConfigMultiError, or nil if none found.
func (m *PostgresConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PostgresConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofConnectionConfigPresent := false
	switch v := m.ConnectionConfig.(type) {
	case *PostgresConnectionConfig_Url:
		if v == nil {
			err := PostgresConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConnectionConfigPresent = true
		// no validation rules for Url
	case *PostgresConnectionConfig_Connection:
		if v == nil {
			err := PostgresConnectionConfigValidationError{
				field:  "ConnectionConfig",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConnectionConfigPresent = true

		if all {
			switch v := interface{}(m.GetConnection()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PostgresConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PostgresConnectionConfigValidationError{
						field:  "Connection",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PostgresConnectionConfigValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofConnectionConfigPresent {
		err := PostgresConnectionConfigValidationError{
			field:  "ConnectionConfig",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PostgresConnectionConfigMultiError(errors)
	}

	return nil
}

// PostgresConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by PostgresConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type PostgresConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostgresConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostgresConnectionConfigMultiError) AllErrors() []error { return m }

// PostgresConnectionConfigValidationError is the validation error returned by
// PostgresConnectionConfig.Validate if the designated constraints aren't met.
type PostgresConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostgresConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostgresConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostgresConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostgresConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostgresConnectionConfigValidationError) ErrorName() string {
	return "PostgresConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e PostgresConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostgresConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostgresConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostgresConnectionConfigValidationError{}

// Validate checks the field values on PostgresConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostgresConnection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostgresConnection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostgresConnectionMultiError, or nil if none found.
func (m *PostgresConnection) ValidateAll() error {
	return m.validate(true)
}

func (m *PostgresConnection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	// no validation rules for Port

	// no validation rules for Name

	// no validation rules for User

	// no validation rules for Pass

	if m.SslMode != nil {
		// no validation rules for SslMode
	}

	if len(errors) > 0 {
		return PostgresConnectionMultiError(errors)
	}

	return nil
}

// PostgresConnectionMultiError is an error wrapping multiple validation errors
// returned by PostgresConnection.ValidateAll() if the designated constraints
// aren't met.
type PostgresConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostgresConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostgresConnectionMultiError) AllErrors() []error { return m }

// PostgresConnectionValidationError is the validation error returned by
// PostgresConnection.Validate if the designated constraints aren't met.
type PostgresConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostgresConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostgresConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostgresConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostgresConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostgresConnectionValidationError) ErrorName() string {
	return "PostgresConnectionValidationError"
}

// Error satisfies the builtin error interface
func (e PostgresConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostgresConnection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostgresConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostgresConnectionValidationError{}

// Validate checks the field values on AwsS3ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AwsS3ConnectionConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AwsS3ConnectionConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AwsS3ConnectionConfigMultiError, or nil if none found.
func (m *AwsS3ConnectionConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AwsS3ConnectionConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BucketArn

	if m.PathPrefix != nil {
		// no validation rules for PathPrefix
	}

	if len(errors) > 0 {
		return AwsS3ConnectionConfigMultiError(errors)
	}

	return nil
}

// AwsS3ConnectionConfigMultiError is an error wrapping multiple validation
// errors returned by AwsS3ConnectionConfig.ValidateAll() if the designated
// constraints aren't met.
type AwsS3ConnectionConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AwsS3ConnectionConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AwsS3ConnectionConfigMultiError) AllErrors() []error { return m }

// AwsS3ConnectionConfigValidationError is the validation error returned by
// AwsS3ConnectionConfig.Validate if the designated constraints aren't met.
type AwsS3ConnectionConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AwsS3ConnectionConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AwsS3ConnectionConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AwsS3ConnectionConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AwsS3ConnectionConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AwsS3ConnectionConfigValidationError) ErrorName() string {
	return "AwsS3ConnectionConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AwsS3ConnectionConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAwsS3ConnectionConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AwsS3ConnectionConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AwsS3ConnectionConfigValidationError{}

// Validate checks the field values on IsConnectionNameAvailableRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *IsConnectionNameAvailableRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsConnectionNameAvailableRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// IsConnectionNameAvailableRequestMultiError, or nil if none found.
func (m *IsConnectionNameAvailableRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IsConnectionNameAvailableRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_IsConnectionNameAvailableRequest_ConnectionName_Pattern.MatchString(m.GetConnectionName()) {
		err := IsConnectionNameAvailableRequestValidationError{
			field:  "ConnectionName",
			reason: "value does not match regex pattern \"^[a-z0-9-]{3,30}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IsConnectionNameAvailableRequestMultiError(errors)
	}

	return nil
}

// IsConnectionNameAvailableRequestMultiError is an error wrapping multiple
// validation errors returned by
// IsConnectionNameAvailableRequest.ValidateAll() if the designated
// constraints aren't met.
type IsConnectionNameAvailableRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsConnectionNameAvailableRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsConnectionNameAvailableRequestMultiError) AllErrors() []error { return m }

// IsConnectionNameAvailableRequestValidationError is the validation error
// returned by IsConnectionNameAvailableRequest.Validate if the designated
// constraints aren't met.
type IsConnectionNameAvailableRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsConnectionNameAvailableRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsConnectionNameAvailableRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsConnectionNameAvailableRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsConnectionNameAvailableRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsConnectionNameAvailableRequestValidationError) ErrorName() string {
	return "IsConnectionNameAvailableRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsConnectionNameAvailableRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsConnectionNameAvailableRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsConnectionNameAvailableRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsConnectionNameAvailableRequestValidationError{}

var _IsConnectionNameAvailableRequest_ConnectionName_Pattern = regexp.MustCompile("^[a-z0-9-]{3,30}$")

// Validate checks the field values on IsConnectionNameAvailableResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *IsConnectionNameAvailableResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsConnectionNameAvailableResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// IsConnectionNameAvailableResponseMultiError, or nil if none found.
func (m *IsConnectionNameAvailableResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IsConnectionNameAvailableResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsAvailable

	if len(errors) > 0 {
		return IsConnectionNameAvailableResponseMultiError(errors)
	}

	return nil
}

// IsConnectionNameAvailableResponseMultiError is an error wrapping multiple
// validation errors returned by
// IsConnectionNameAvailableResponse.ValidateAll() if the designated
// constraints aren't met.
type IsConnectionNameAvailableResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsConnectionNameAvailableResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsConnectionNameAvailableResponseMultiError) AllErrors() []error { return m }

// IsConnectionNameAvailableResponseValidationError is the validation error
// returned by IsConnectionNameAvailableResponse.Validate if the designated
// constraints aren't met.
type IsConnectionNameAvailableResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsConnectionNameAvailableResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsConnectionNameAvailableResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsConnectionNameAvailableResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsConnectionNameAvailableResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsConnectionNameAvailableResponseValidationError) ErrorName() string {
	return "IsConnectionNameAvailableResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IsConnectionNameAvailableResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsConnectionNameAvailableResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsConnectionNameAvailableResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsConnectionNameAvailableResponseValidationError{}

// Validate checks the field values on DatabaseColumn with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatabaseColumn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatabaseColumn with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatabaseColumnMultiError,
// or nil if none found.
func (m *DatabaseColumn) ValidateAll() error {
	return m.validate(true)
}

func (m *DatabaseColumn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Schema

	// no validation rules for Table

	// no validation rules for Column

	// no validation rules for DataType

	if len(errors) > 0 {
		return DatabaseColumnMultiError(errors)
	}

	return nil
}

// DatabaseColumnMultiError is an error wrapping multiple validation errors
// returned by DatabaseColumn.ValidateAll() if the designated constraints
// aren't met.
type DatabaseColumnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatabaseColumnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatabaseColumnMultiError) AllErrors() []error { return m }

// DatabaseColumnValidationError is the validation error returned by
// DatabaseColumn.Validate if the designated constraints aren't met.
type DatabaseColumnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatabaseColumnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatabaseColumnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatabaseColumnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatabaseColumnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatabaseColumnValidationError) ErrorName() string { return "DatabaseColumnValidationError" }

// Error satisfies the builtin error interface
func (e DatabaseColumnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatabaseColumn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatabaseColumnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatabaseColumnValidationError{}

// Validate checks the field values on GetConnectionSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionSchemaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionSchemaRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionSchemaRequestMultiError, or nil if none found.
func (m *GetConnectionSchemaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionSchemaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetConnectionSchemaRequestMultiError(errors)
	}

	return nil
}

// GetConnectionSchemaRequestMultiError is an error wrapping multiple
// validation errors returned by GetConnectionSchemaRequest.ValidateAll() if
// the designated constraints aren't met.
type GetConnectionSchemaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionSchemaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionSchemaRequestMultiError) AllErrors() []error { return m }

// GetConnectionSchemaRequestValidationError is the validation error returned
// by GetConnectionSchemaRequest.Validate if the designated constraints aren't met.
type GetConnectionSchemaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionSchemaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionSchemaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionSchemaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionSchemaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionSchemaRequestValidationError) ErrorName() string {
	return "GetConnectionSchemaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionSchemaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionSchemaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionSchemaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionSchemaRequestValidationError{}

// Validate checks the field values on GetConnectionSchemaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConnectionSchemaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConnectionSchemaResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConnectionSchemaResponseMultiError, or nil if none found.
func (m *GetConnectionSchemaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConnectionSchemaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSchemas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetConnectionSchemaResponseValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetConnectionSchemaResponseValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetConnectionSchemaResponseValidationError{
					field:  fmt.Sprintf("Schemas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetConnectionSchemaResponseMultiError(errors)
	}

	return nil
}

// GetConnectionSchemaResponseMultiError is an error wrapping multiple
// validation errors returned by GetConnectionSchemaResponse.ValidateAll() if
// the designated constraints aren't met.
type GetConnectionSchemaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConnectionSchemaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConnectionSchemaResponseMultiError) AllErrors() []error { return m }

// GetConnectionSchemaResponseValidationError is the validation error returned
// by GetConnectionSchemaResponse.Validate if the designated constraints
// aren't met.
type GetConnectionSchemaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConnectionSchemaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConnectionSchemaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConnectionSchemaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConnectionSchemaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConnectionSchemaResponseValidationError) ErrorName() string {
	return "GetConnectionSchemaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConnectionSchemaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConnectionSchemaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConnectionSchemaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConnectionSchemaResponseValidationError{}
