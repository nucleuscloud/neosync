// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: system.sql

package pg_queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDatabaseSchema = `-- name: GetDatabaseSchema :many
SELECT
    n.nspname AS table_schema,
    c.relname AS table_name,
    a.attname AS column_name,
    pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type, -- This formats the type into something that should always be a valid postgres type. It also includes constraints if there are any
    COALESCE(
        pg_catalog.pg_get_expr(d.adbin, d.adrelid),
        ''
    ) AS column_default,
    CASE
        WHEN a.attnotnull THEN 'NO'
        ELSE 'YES'
    END AS is_nullable,
    CASE
        WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) LIKE 'character varying%' THEN
            a.atttypmod - 4 -- The -4 removes the extra bits that postgres uses for internal use
        ELSE
            -1
    END AS character_maximum_length,
    CASE
        WHEN a.atttypid = pg_catalog.regtype 'numeric'::regtype THEN
            (a.atttypmod - 4) >> 16
        -- Precision is technically only necessary for numeric values, but we are populating these here for simplicity in knowing what the type of integer is.
        -- This operates similar to the precision column in the information_schema.columns table
        WHEN a.atttypid = pg_catalog.regtype 'smallint'::regtype THEN
            16
        WHEN a.atttypid = pg_catalog.regtype 'integer'::regtype THEN
            32
        WHEN a.atttypid = pg_catalog.regtype 'bigint'::regtype THEN
            64
        ELSE
            -1
    END AS numeric_precision,
    CASE
        WHEN a.atttypid = pg_catalog.regtype 'numeric'::regtype THEN
            (a.atttypmod - 4) & 65535
        -- Scale is technically only necessary for numeric values, but we are populating these here for simplicity in knowing what the type of integer is.
        -- This operates similar to the scake column in the information_schema.columns table
        WHEN a.atttypid = pg_catalog.regtype 'smallint'::regtype THEN
            0
        WHEN a.atttypid = pg_catalog.regtype 'integer'::regtype THEN
            0
        WHEN a.atttypid = pg_catalog.regtype 'bigint'::regtype THEN
            0
        ELSE
            -1
    END AS numeric_scale,
    a.attnum AS ordinal_position
FROM
    pg_catalog.pg_attribute a
    INNER JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
    INNER JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    INNER JOIN pg_catalog.pg_type pgt ON pgt.oid = a.atttypid
    LEFT JOIN pg_catalog.pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
WHERE
    n.nspname NOT IN('pg_catalog', 'pg_toast', 'information_schema')
    AND a.attnum > 0
    AND NOT a.attisdropped
    AND c.relkind = 'r' -- ensures only tables are present
ORDER BY
    a.attnum
`

type GetDatabaseSchemaRow struct {
	TableSchema            string
	TableName              string
	ColumnName             string
	DataType               string
	ColumnDefault          interface{}
	IsNullable             string
	CharacterMaximumLength int32
	NumericPrecision       int32
	NumericScale           int32
	OrdinalPosition        int16
}

func (q *Queries) GetDatabaseSchema(ctx context.Context, db DBTX) ([]*GetDatabaseSchemaRow, error) {
	rows, err := db.Query(ctx, getDatabaseSchema)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDatabaseSchemaRow
	for rows.Next() {
		var i GetDatabaseSchemaRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ColumnName,
			&i.DataType,
			&i.ColumnDefault,
			&i.IsNullable,
			&i.CharacterMaximumLength,
			&i.NumericPrecision,
			&i.NumericScale,
			&i.OrdinalPosition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatabaseTableSchema = `-- name: GetDatabaseTableSchema :many
SELECT
    n.nspname AS schema_name,
    c.relname AS table_name,
    a.attname AS column_name,
    pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,  -- This formats the type into something that should always be a valid postgres type. It also includes constraints if there are any
    COALESCE(
        pg_catalog.pg_get_expr(d.adbin, d.adrelid),
        ''
    ) AS column_default,
    CASE
        WHEN a.attnotnull THEN 'NO'
        ELSE 'YES'
    END AS is_nullable,
    CASE
        WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) LIKE 'character varying%' THEN
            a.atttypmod - 4 -- The -4 removes the extra bits that postgres uses for internal use
        ELSE
            -1
    END AS character_maximum_length,
    CASE
        WHEN a.atttypid = pg_catalog.regtype 'numeric'::regtype THEN
            (a.atttypmod - 4) >> 16
        -- Precision is technically only necessary for numeric values, but we are populating these here for simplicity in knowing what the type of integer is.
        -- This operates similar to the precision column in the information_schema.columns table
        WHEN a.atttypid = pg_catalog.regtype 'smallint'::regtype THEN
            16
        WHEN a.atttypid = pg_catalog.regtype 'integer'::regtype THEN
            32
        WHEN a.atttypid = pg_catalog.regtype 'bigint'::regtype THEN
            64
        ELSE
            -1
    END AS numeric_precision,
    CASE
        WHEN a.atttypid = pg_catalog.regtype 'numeric'::regtype THEN
            (a.atttypmod - 4) & 65535
        -- Scale is technically only necessary for numeric values, but we are populating these here for simplicity in knowing what the type of integer is.
        -- This operates similar to the scake column in the information_schema.columns table
        WHEN a.atttypid = pg_catalog.regtype 'smallint'::regtype THEN
            0
        WHEN a.atttypid = pg_catalog.regtype 'integer'::regtype THEN
            0
        WHEN a.atttypid = pg_catalog.regtype 'bigint'::regtype THEN
            0
        ELSE
            -1
    END AS numeric_scale,
    a.attnum AS ordinal_position
FROM
    pg_catalog.pg_attribute a
    INNER JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
    INNER JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    INNER JOIN pg_catalog.pg_type pgt ON pgt.oid = a.atttypid
    LEFT JOIN pg_catalog.pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
WHERE
    c.relname = $1
    AND n.nspname = $2
    AND a.attnum > 0
    AND NOT a.attisdropped
    AND c.relkind = 'r' -- ensures only tables are present
ORDER BY
    a.attnum
`

type GetDatabaseTableSchemaParams struct {
	Table  string
	Schema string
}

type GetDatabaseTableSchemaRow struct {
	SchemaName             string
	TableName              string
	ColumnName             string
	DataType               string
	ColumnDefault          interface{}
	IsNullable             string
	CharacterMaximumLength int32
	NumericPrecision       int32
	NumericScale           int32
	OrdinalPosition        int16
}

func (q *Queries) GetDatabaseTableSchema(ctx context.Context, db DBTX, arg *GetDatabaseTableSchemaParams) ([]*GetDatabaseTableSchemaRow, error) {
	rows, err := db.Query(ctx, getDatabaseTableSchema, arg.Table, arg.Schema)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDatabaseTableSchemaRow
	for rows.Next() {
		var i GetDatabaseTableSchemaRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.ColumnName,
			&i.DataType,
			&i.ColumnDefault,
			&i.IsNullable,
			&i.CharacterMaximumLength,
			&i.NumericPrecision,
			&i.NumericScale,
			&i.OrdinalPosition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostgresRolePermissions = `-- name: GetPostgresRolePermissions :many




SELECT
    rtg.table_schema as table_schema,
    rtg.table_name as table_name,
    rtg.privilege_type as privilege_type
FROM
    information_schema.role_table_grants as rtg
WHERE
    table_schema NOT IN ('pg_catalog', 'information_schema')
AND grantee =  $1
ORDER BY
    table_schema,
    table_name
`

type GetPostgresRolePermissionsRow struct {
	TableSchema   string
	TableName     string
	PrivilegeType string
}

// -- name: GetForeignKeyConstraints :many
// SELECT
//
//	rc.constraint_name,
//	rc.constraint_schema AS schema_name,
//	fk.table_name,
//	fk.column_name,
//	c.is_nullable,
//	pk.table_schema AS foreign_schema_name,
//	pk.table_name AS foreign_table_name,
//	pk.column_name AS foreign_column_name
//
// FROM
//
//	information_schema.referential_constraints rc
//
// JOIN information_schema.key_column_usage fk ON
//
//	fk.constraint_catalog = rc.constraint_catalog AND
//	fk.constraint_schema = rc.constraint_schema AND
//	fk.constraint_name = rc.constraint_name
//
// JOIN information_schema.key_column_usage pk ON
//
//	pk.constraint_catalog = rc.unique_constraint_catalog AND
//	pk.constraint_schema = rc.unique_constraint_schema AND
//	pk.constraint_name = rc.unique_constraint_name
//
// JOIN information_schema.columns c ON
//
//	c.table_schema = fk.table_schema AND
//	c.table_name = fk.table_name AND
//	c.column_name = fk.column_name
//
// WHERE
//
//	rc.constraint_schema = sqlc.arg('tableSchema')
//
// ORDER BY
//
//	rc.constraint_name,
//	fk.ordinal_position;
//
// -- name: GetPrimaryKeyConstraints :many
// SELECT
//
//	tc.table_schema AS schema_name,
//	tc.table_name as table_name,
//	tc.constraint_name as constraint_name,
//	kcu.column_name as column_name
//
// FROM
//
//	information_schema.table_constraints AS tc
//
// JOIN information_schema.key_column_usage AS kcu
//
//	ON tc.constraint_name = kcu.constraint_name
//	AND tc.table_schema = kcu.table_schema
//
// WHERE
//
//	tc.table_schema = sqlc.arg('tableSchema')
//	AND tc.constraint_type = 'PRIMARY KEY'
//
// ORDER BY
//
//	tc.table_name,
//	kcu.column_name;
//
// -- name: GetUniqueConstraints :many
// SELECT
//
//	tc.table_schema AS schema_name,
//	tc.table_name AS table_name,
//	tc.constraint_name AS constraint_name,
//	kcu.column_name AS column_name
//
// FROM
//
//	information_schema.table_constraints AS tc
//
// JOIN information_schema.key_column_usage AS kcu
//
//	ON tc.constraint_name = kcu.constraint_name
//	AND tc.table_schema = kcu.table_schema
//
// WHERE
//
//	tc.table_schema = sqlc.arg('tableSchema')
//	AND tc.constraint_type = 'UNIQUE'
//
// ORDER BY
//
//	tc.table_name,
//	kcu.column_name;
func (q *Queries) GetPostgresRolePermissions(ctx context.Context, db DBTX, role interface{}) ([]*GetPostgresRolePermissionsRow, error) {
	rows, err := db.Query(ctx, getPostgresRolePermissions, role)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPostgresRolePermissionsRow
	for rows.Next() {
		var i GetPostgresRolePermissionsRow
		if err := rows.Scan(&i.TableSchema, &i.TableName, &i.PrivilegeType); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTableConstraints = `-- name: GetTableConstraints :many
SELECT
    con.oid AS constraint_oid,
    con.conname AS constraint_name,
    con.contype AS constraint_type,
    con.connamespace::regclass AS schema_name,
    con.conrelid::regclass AS table_name,
    CASE
        WHEN con.contype IN ('f', 'p', 'u') THEN array_agg(att.attname)
        ELSE NULL
    END AS constraint_columns,
    array_agg(att.attnotnull) AS notnullable,
    CASE
        WHEN con.contype = 'f' THEN fn_cl.relnamespace::regnamespace
        ELSE NULL
    END AS foreign_schema_name,
    CASE
        WHEN con.contype = 'f' THEN con.confrelid::regclass
        ELSE NULL
    END AS foreign_table_name,
    CASE
        WHEN con.contype = 'f' THEN array_agg(fk_att.attname)
        ELSE NULL
    END AS foreign_column_names,
    pg_get_constraintdef(con.oid) AS constraint_definition
FROM
    pg_catalog.pg_constraint con
LEFT JOIN
    pg_catalog.pg_attribute fk_att ON fk_att.attrelid = con.confrelid AND fk_att.attnum = ANY(con.confkey)
LEFT JOIN
    pg_catalog.pg_attribute att ON att.attrelid = con.conrelid AND att.attnum = ANY(con.conkey)
LEFT JOIN
    pg_catalog.pg_class fn_cl ON fn_cl.oid = con.confrelid
WHERE
    con.connamespace::regnamespace::text = $1 AND con.conrelid::regclass::text = $2
GROUP BY
    con.oid, con.conname, con.conrelid, fn_cl.relnamespace, con.confrelid, con.contype
`

type GetTableConstraintsParams struct {
	Schema string
	Table  string
}

type GetTableConstraintsRow struct {
	ConstraintOid        pgtype.Uint32
	ConstraintName       string
	ConstraintType       string
	SchemaName           interface{}
	TableName            interface{}
	ConstraintColumns    interface{}
	Notnullable          interface{}
	ForeignSchemaName    interface{}
	ForeignTableName     interface{}
	ForeignColumnNames   interface{}
	ConstraintDefinition string
}

func (q *Queries) GetTableConstraints(ctx context.Context, db DBTX, arg *GetTableConstraintsParams) ([]*GetTableConstraintsRow, error) {
	rows, err := db.Query(ctx, getTableConstraints, arg.Schema, arg.Table)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTableConstraintsRow
	for rows.Next() {
		var i GetTableConstraintsRow
		if err := rows.Scan(
			&i.ConstraintOid,
			&i.ConstraintName,
			&i.ConstraintType,
			&i.SchemaName,
			&i.TableName,
			&i.ConstraintColumns,
			&i.Notnullable,
			&i.ForeignSchemaName,
			&i.ForeignTableName,
			&i.ForeignColumnNames,
			&i.ConstraintDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTableConstraintsBySchema = `-- name: GetTableConstraintsBySchema :many
SELECT
    con.oid AS constraint_oid,
    con.conname AS constraint_name,
    con.contype AS constraint_type,
    con.connamespace::regclass AS schema_name,
    con.conrelid::regclass AS table_name,
    CASE
        WHEN con.contype IN ('f', 'p', 'u') THEN array_agg(att.attname)
        ELSE NULL
    END AS constraint_columns,
    array_agg(att.attnotnull) AS notnullable,
    CASE
        WHEN con.contype = 'f' THEN fn_cl.relnamespace::regnamespace
        ELSE NULL
    END AS foreign_schema_name,
    CASE
        WHEN con.contype = 'f' THEN con.confrelid::regclass
        ELSE NULL
    END AS foreign_table_name,
    CASE
        WHEN con.contype = 'f' THEN array_agg(fk_att.attname)
        ELSE NULL
    END AS foreign_column_names,
    pg_get_constraintdef(con.oid) AS constraint_definition
FROM
    pg_catalog.pg_constraint con
LEFT JOIN
    pg_catalog.pg_attribute fk_att ON fk_att.attrelid = con.confrelid AND fk_att.attnum = ANY(con.confkey)
LEFT JOIN
    pg_catalog.pg_attribute att ON att.attrelid = con.conrelid AND att.attnum = ANY(con.conkey)
LEFT JOIN
    pg_catalog.pg_class fn_cl ON fn_cl.oid = con.confrelid
WHERE
    con.connamespace::regnamespace::text = ANY($1::text[])
GROUP BY
    con.oid, con.conname, con.conrelid, fn_cl.relnamespace, con.confrelid, con.contype
`

type GetTableConstraintsBySchemaRow struct {
	ConstraintOid        pgtype.Uint32
	ConstraintName       string
	ConstraintType       string
	SchemaName           interface{}
	TableName            interface{}
	ConstraintColumns    interface{}
	Notnullable          interface{}
	ForeignSchemaName    interface{}
	ForeignTableName     interface{}
	ForeignColumnNames   interface{}
	ConstraintDefinition string
}

func (q *Queries) GetTableConstraintsBySchema(ctx context.Context, db DBTX, schema []string) ([]*GetTableConstraintsBySchemaRow, error) {
	rows, err := db.Query(ctx, getTableConstraintsBySchema, schema)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTableConstraintsBySchemaRow
	for rows.Next() {
		var i GetTableConstraintsBySchemaRow
		if err := rows.Scan(
			&i.ConstraintOid,
			&i.ConstraintName,
			&i.ConstraintType,
			&i.SchemaName,
			&i.TableName,
			&i.ConstraintColumns,
			&i.Notnullable,
			&i.ForeignSchemaName,
			&i.ForeignTableName,
			&i.ForeignColumnNames,
			&i.ConstraintDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
