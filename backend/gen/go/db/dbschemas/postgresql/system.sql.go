// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: system.sql

package pg_queries

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const getCustomFunctionsBySchemaAndTables = `-- name: GetCustomFunctionsBySchemaAndTables :many
WITH relevant_schemas_tables AS (
    SELECT c.oid, n.nspname AS schema_name, c.relname AS table_name
    FROM pg_catalog.pg_class c
    JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
    WHERE n.nspname = $1
    AND c.relname = ANY($2::TEXT[])
),
trigger_functions AS (
    SELECT DISTINCT
        n.nspname AS schema_name,
        p.proname AS function_name,
        pg_catalog.pg_get_functiondef(p.oid) AS definition,
        pg_catalog.pg_get_function_identity_arguments(p.oid) AS function_signature
    FROM pg_catalog.pg_trigger t
    JOIN pg_catalog.pg_proc p ON t.tgfoid = p.oid
    JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE t.tgrelid IN (SELECT oid FROM relevant_schemas_tables)
    AND NOT t.tgisinternal
),
column_default_functions AS (
    SELECT DISTINCT
        n.nspname AS schema_name,
        p.proname AS function_name,
        pg_catalog.pg_get_functiondef(p.oid) AS definition,
        pg_catalog.pg_get_function_identity_arguments(p.oid) AS function_signature
    FROM pg_catalog.pg_attrdef ad
    JOIN pg_catalog.pg_depend d ON ad.oid = d.objid
    JOIN pg_catalog.pg_proc p ON d.refobjid = p.oid
    JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
    WHERE ad.adrelid IN (SELECT oid FROM relevant_schemas_tables)
    AND d.refclassid = 'pg_proc'::regclass
    AND d.classid = 'pg_attrdef'::regclass
    AND p.oid NOT IN(SELECT objid FROM pg_catalog.pg_depend WHERE deptype = 'e') -- excludes extensions
)
SELECT
    schema_name,
    function_name,
    function_signature,
    definition
FROM
    trigger_functions
UNION
SELECT
    schema_name,
    function_name,
    function_signature,
    definition
FROM
    column_default_functions
ORDER BY
    schema_name,
    function_name
`

type GetCustomFunctionsBySchemaAndTablesParams struct {
	Schema string
	Tables []string
}

type GetCustomFunctionsBySchemaAndTablesRow struct {
	SchemaName        string
	FunctionName      string
	FunctionSignature string
	Definition        string
}

func (q *Queries) GetCustomFunctionsBySchemaAndTables(ctx context.Context, db DBTX, arg *GetCustomFunctionsBySchemaAndTablesParams) ([]*GetCustomFunctionsBySchemaAndTablesRow, error) {
	rows, err := db.QueryContext(ctx, getCustomFunctionsBySchemaAndTables, arg.Schema, pq.Array(arg.Tables))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCustomFunctionsBySchemaAndTablesRow
	for rows.Next() {
		var i GetCustomFunctionsBySchemaAndTablesRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.FunctionName,
			&i.FunctionSignature,
			&i.Definition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomSequencesBySchemaAndTables = `-- name: GetCustomSequencesBySchemaAndTables :many
WITH relevant_schemas_tables AS (
    SELECT c.oid AS table_oid, n.nspname AS schema_name, c.relname AS table_name
    FROM pg_catalog.pg_class c
    JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
    WHERE n.nspname = $1
    AND c.relname = ANY($2::TEXT[])
),
columns_with_custom_sequences AS (
  SELECT
		at.attrelid AS table_oid,
		sn.nspname AS sequence_schema_name,
		s.relname AS sequence_name,
		st.nspname AS schema_name,
		t.relname AS table_name,
		at.attname AS column_name
	FROM
		pg_catalog.pg_class s
		JOIN pg_catalog.pg_namespace sn ON sn.oid = s.relnamespace
		JOIN pg_catalog.pg_depend d ON d.refobjid = s.oid
		JOIN pg_catalog.pg_attrdef a ON d.objid = a.oid
		JOIN pg_catalog.pg_attribute at ON at.attrelid = a.adrelid
			AND at.attnum = a.adnum
		JOIN pg_catalog.pg_class t ON t.oid = a.adrelid
		JOIN pg_catalog.pg_namespace st ON st.oid = t.relnamespace
	WHERE
		s.relkind = 'S'
		AND d.classid = 'pg_attrdef'::regclass
		AND d.refclassid = 'pg_class'::regclass
)
SELECT
    rst.schema_name,
    rst.table_name,
    cws.column_name,
    cws.sequence_schema_name,
    cws.sequence_name,
   (
        'CREATE SEQUENCE ' || quote_ident(cws.sequence_schema_name) || '.' || quote_ident(cws.sequence_name) ||
        ' START WITH ' || seqs.start_value ||
        ' INCREMENT BY ' || seqs.increment_by ||
        ' MINVALUE ' || seqs.min_value ||
        ' MAXVALUE ' || seqs.max_value ||
        ' CACHE ' || seqs.cache_size ||
        CASE WHEN seqs.cycle THEN ' CYCLE' ELSE ' NO CYCLE' END || ';'
    )::text AS "definition"
FROM
    relevant_schemas_tables rst
JOIN
    columns_with_custom_sequences cws ON rst.table_oid = cws.table_oid
JOIN
    pg_catalog.pg_sequences seqs ON seqs.schemaname = cws.sequence_schema_name AND seqs.sequencename = cws.sequence_name
ORDER BY
    rst.schema_name,
    rst.table_name,
    cws.column_name
`

type GetCustomSequencesBySchemaAndTablesParams struct {
	Schema string
	Tables []string
}

type GetCustomSequencesBySchemaAndTablesRow struct {
	SchemaName         string
	TableName          string
	ColumnName         string
	SequenceSchemaName string
	SequenceName       string
	Definition         string
}

func (q *Queries) GetCustomSequencesBySchemaAndTables(ctx context.Context, db DBTX, arg *GetCustomSequencesBySchemaAndTablesParams) ([]*GetCustomSequencesBySchemaAndTablesRow, error) {
	rows, err := db.QueryContext(ctx, getCustomSequencesBySchemaAndTables, arg.Schema, pq.Array(arg.Tables))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCustomSequencesBySchemaAndTablesRow
	for rows.Next() {
		var i GetCustomSequencesBySchemaAndTablesRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.ColumnName,
			&i.SequenceSchemaName,
			&i.SequenceName,
			&i.Definition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomTriggersBySchemaAndTables = `-- name: GetCustomTriggersBySchemaAndTables :many
SELECT
    n.nspname AS schema_name,
    c.relname AS table_name,
    t.tgname AS trigger_name,
    pg_catalog.pg_get_triggerdef(t.oid, true) AS definition
FROM pg_catalog.pg_trigger t
JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid
JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE  (n.nspname || '.' || c.relname) = ANY($1::TEXT[])
AND NOT t.tgisinternal
ORDER BY
    schema_name,
    table_name,
    trigger_name
`

type GetCustomTriggersBySchemaAndTablesRow struct {
	SchemaName  string
	TableName   string
	TriggerName string
	Definition  string
}

func (q *Queries) GetCustomTriggersBySchemaAndTables(ctx context.Context, db DBTX, schematables []string) ([]*GetCustomTriggersBySchemaAndTablesRow, error) {
	rows, err := db.QueryContext(ctx, getCustomTriggersBySchemaAndTables, pq.Array(schematables))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCustomTriggersBySchemaAndTablesRow
	for rows.Next() {
		var i GetCustomTriggersBySchemaAndTablesRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.TriggerName,
			&i.Definition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDataTypesBySchemaAndTables = `-- name: GetDataTypesBySchemaAndTables :many
WITH custom_types AS (
    SELECT
        n.nspname AS schema_name,
        t.typname AS type_name,
        t.oid AS type_oid,
        CASE
            WHEN t.typtype = 'd' THEN 'domain'
            WHEN t.typtype = 'e' THEN 'enum'
            WHEN t.typtype = 'c' THEN 'composite'
        END AS type
    FROM
        pg_catalog.pg_type t
    JOIN
        pg_catalog.pg_namespace n ON n.oid = t.typnamespace
    WHERE
        n.nspname NOT IN('pg_catalog', 'pg_toast', 'information_schema')
        AND t.typtype IN ('d', 'e', 'c')
),
table_columns AS (
    SELECT
        c.oid AS table_oid,
       CASE
            WHEN t.typtype = 'b' THEN t.typelem  -- If it's an array, use the element type
            ELSE a.atttypid                      -- Otherwise use the type directly
        END AS type_oid
    FROM
        pg_catalog.pg_class c
    JOIN
        pg_catalog.pg_namespace n ON n.oid = c.relnamespace
    JOIN
        pg_catalog.pg_attribute a ON a.attrelid = c.oid
    JOIN
        pg_catalog.pg_type t ON t.oid = a.atttypid
    WHERE
        n.nspname = $1
        AND c.relname = ANY($2::TEXT[])
        AND a.attnum > 0
        AND NOT a.attisdropped
),
relevant_custom_types AS (
    SELECT DISTINCT
        ct.schema_name,
        ct.type_name,
        ct.type_oid,
        ct.type
    FROM
        custom_types ct
    JOIN
        table_columns tc ON ct.type_oid = tc.type_oid
),
domain_defs AS (
    SELECT
        rct.schema_name,
        rct.type_name,
        rct.type,
        'CREATE DOMAIN ' || quote_ident(rct.schema_name) || '.' || quote_ident(rct.type_name) || ' AS ' ||
        pg_catalog.format_type(t.typbasetype, t.typtypmod) ||
        CASE
            WHEN t.typnotnull THEN ' NOT NULL' ELSE ''
        END || ' ' ||
        COALESCE('CONSTRAINT ' || conname || ' ' || pg_catalog.pg_get_constraintdef(c.oid), '') || ';' AS definition
    FROM
        relevant_custom_types rct
    JOIN
        pg_catalog.pg_type t ON rct.type_oid = t.oid
    LEFT JOIN
        pg_catalog.pg_constraint c ON t.oid = c.contypid
    WHERE
        rct.type = 'domain'
),
enum_defs AS (
    SELECT
        rct.schema_name,
        rct.type_name,
        rct.type,
        'CREATE TYPE ' || quote_ident(rct.schema_name) || '.' || quote_ident(rct.type_name) || ' AS ENUM (' ||
        string_agg('''' || e.enumlabel || '''', ', ') || ');' AS definition
    FROM
        relevant_custom_types rct
    JOIN
        pg_catalog.pg_type t ON rct.type_oid = t.oid
    JOIN
        pg_catalog.pg_enum e ON t.oid = e.enumtypid
    WHERE
        rct.type = 'enum'
    GROUP BY
        rct.schema_name, rct.type_name, rct.type
),
composite_defs AS (
    SELECT
        rct.schema_name,
        rct.type_name,
        rct.type,
        'CREATE TYPE ' || quote_ident(rct.schema_name) || '.' || quote_ident(rct.type_name) || ' AS (' ||
        string_agg(a.attname || ' ' || pg_catalog.format_type(a.atttypid, a.atttypmod), ', ') || ');' AS definition
    FROM
        relevant_custom_types rct
    JOIN
        pg_catalog.pg_type t ON rct.type_oid = t.oid
    JOIN
        pg_catalog.pg_class c ON c.oid = t.typrelid
    JOIN
        pg_catalog.pg_attribute a ON a.attrelid = c.oid
    WHERE
        rct.type = 'composite'
        AND a.attnum > 0
        AND NOT a.attisdropped
    GROUP BY
        rct.schema_name, rct.type_name, rct.type
)
SELECT
    schema_name,
    type_name,
    "type"::text,
    "definition"::text
FROM
    domain_defs
UNION ALL
SELECT
    schema_name,
    type_name,
    "type"::text,
    "definition"::text
FROM
    enum_defs
UNION ALL
SELECT
    schema_name,
    type_name,
    "type"::text,
    "definition"::text
FROM
    composite_defs
`

type GetDataTypesBySchemaAndTablesParams struct {
	Schema string
	Tables []string
}

type GetDataTypesBySchemaAndTablesRow struct {
	SchemaName string
	TypeName   string
	Type       string
	Definition string
}

func (q *Queries) GetDataTypesBySchemaAndTables(ctx context.Context, db DBTX, arg *GetDataTypesBySchemaAndTablesParams) ([]*GetDataTypesBySchemaAndTablesRow, error) {
	rows, err := db.QueryContext(ctx, getDataTypesBySchemaAndTables, arg.Schema, pq.Array(arg.Tables))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDataTypesBySchemaAndTablesRow
	for rows.Next() {
		var i GetDataTypesBySchemaAndTablesRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TypeName,
			&i.Type,
			&i.Definition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatabaseSchema = `-- name: GetDatabaseSchema :many
WITH linked_to_serial AS (
    SELECT
        cl.relname AS sequence_name,
        nsp.nspname AS schema_name,
        cl.oid AS sequence_oid,
        ad.adrelid,
        ad.adnum,
        pg_catalog.pg_get_expr(ad.adbin, ad.adrelid)
    FROM
        pg_catalog.pg_class cl
    JOIN
        pg_catalog.pg_namespace nsp ON cl.relnamespace = nsp.oid
    JOIN
        pg_catalog.pg_depend dep ON dep.objid = cl.oid AND dep.classid = 'pg_catalog.pg_class'::regclass
    JOIN
        pg_catalog.pg_attrdef ad ON dep.refobjid = ad.adrelid AND dep.refobjsubid = ad.adnum
    WHERE
        pg_catalog.pg_get_expr(ad.adbin, ad.adrelid) LIKE 'nextval%' AND cl.relkind = 'S'
),
column_defaults AS (
    SELECT
        n.nspname AS schema_name,
        c.relname AS table_name,
        a.attname AS column_name,
        pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,
        COALESCE(pg_catalog.pg_get_expr(d.adbin, d.adrelid), '')::text AS column_default,
        CASE WHEN a.attnotnull THEN 'NO' ELSE 'YES' END AS is_nullable,
        CASE
            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) LIKE 'character varying%' THEN
                a.atttypmod - 4
            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) LIKE 'character(%' THEN
                a.atttypmod - 4
            ELSE
                -1
        END AS character_maximum_length,
        CASE
            WHEN a.atttypid = pg_catalog.regtype 'numeric'::regtype THEN
                (a.atttypmod - 4) >> 16
            WHEN a.atttypid = pg_catalog.regtype 'smallint'::regtype THEN
                16
            WHEN a.atttypid = pg_catalog.regtype 'integer'::regtype THEN
                32
            WHEN a.atttypid = pg_catalog.regtype 'bigint'::regtype THEN
                64
            ELSE
                -1
        END AS numeric_precision,
        CASE
            WHEN a.atttypid = pg_catalog.regtype 'numeric'::regtype THEN
                CASE
                    WHEN (a.atttypmod) = -1 THEN -1
                    ELSE (a.atttypmod - 4) & 65535
                END
            WHEN a.atttypid = pg_catalog.regtype 'smallint'::regtype THEN
                0
            WHEN a.atttypid = pg_catalog.regtype 'integer'::regtype THEN
                0
            WHEN a.atttypid = pg_catalog.regtype 'bigint'::regtype THEN
                0
            ELSE
                -1
        END AS numeric_scale,
        a.attnum AS ordinal_position,
        a.attgenerated::text as generated_type,
        a.attidentity::text as identity_generation,
        c.oid AS table_oid
    FROM
        pg_catalog.pg_attribute a
    INNER JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
    INNER JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    LEFT JOIN pg_catalog.pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
    WHERE
        n.nspname NOT IN('pg_catalog', 'pg_toast', 'information_schema')
        AND a.attnum > 0
        AND NOT a.attisdropped
        AND c.relkind = 'r'
),
identity_columns AS (
    SELECT
        n.nspname AS schema_name,
        c.relname AS table_name,
        a.attname AS column_name,
        a.attidentity AS identity_generation,
        s.seqincrement AS increment_by,
        s.seqmin AS min_value,
        s.seqmax AS max_value,
        s.seqstart AS start_value,
        s.seqcache AS cache_value,
        s.seqcycle AS cycle_option
    FROM
        pg_catalog.pg_class c
    JOIN
        pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    JOIN
        pg_catalog.pg_attribute a ON a.attrelid = c.oid
    JOIN
        pg_catalog.pg_class seq ON seq.relname = c.relname || '_' || a.attname || '_seq'
        AND seq.relnamespace = c.relnamespace
    JOIN
        pg_catalog.pg_sequence s ON seq.oid = s.seqrelid
    WHERE
        a.attidentity IN ('a', 'd')
)
SELECT
    cd.schema_name, cd.table_name, cd.column_name, cd.data_type, cd.column_default, cd.is_nullable, cd.character_maximum_length, cd.numeric_precision, cd.numeric_scale, cd.ordinal_position, cd.generated_type, cd.identity_generation, cd.table_oid,
    CASE
        WHEN ls.sequence_oid IS NOT NULL THEN 'SERIAL'
        WHEN cd.column_default LIKE 'nextval(%::regclass)' THEN 'USER-DEFINED SEQUENCE'
        WHEN cd.identity_generation != '' THEN 'IDENTITY'
        ELSE ''
    END AS sequence_type,
    ic.increment_by as seq_increment_by,
    ic.min_value as seq_min_value,
    ic.max_value as seq_max_value,
    ic.start_value as seq_start_value,
    ic.cache_value as seq_cache_value,
    ic.cycle_option as seq_cycle_option
FROM
    column_defaults cd
LEFT JOIN linked_to_serial ls
    ON cd.table_oid = ls.adrelid
    AND cd.ordinal_position = ls.adnum
LEFT JOIN identity_columns ic
    ON cd.schema_name = ic.schema_name
    AND cd.table_name = ic.table_name
    AND cd.column_name = ic.column_name
ORDER BY
    cd.ordinal_position
`

type GetDatabaseSchemaRow struct {
	SchemaName             string
	TableName              string
	ColumnName             string
	DataType               string
	ColumnDefault          string
	IsNullable             string
	CharacterMaximumLength int32
	NumericPrecision       int32
	NumericScale           int32
	OrdinalPosition        int16
	GeneratedType          string
	IdentityGeneration     string
	TableOid               interface{}
	SequenceType           string
	SeqIncrementBy         sql.NullInt64
	SeqMinValue            sql.NullInt64
	SeqMaxValue            sql.NullInt64
	SeqStartValue          sql.NullInt64
	SeqCacheValue          sql.NullInt64
	SeqCycleOption         sql.NullBool
}

func (q *Queries) GetDatabaseSchema(ctx context.Context, db DBTX) ([]*GetDatabaseSchemaRow, error) {
	rows, err := db.QueryContext(ctx, getDatabaseSchema)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDatabaseSchemaRow
	for rows.Next() {
		var i GetDatabaseSchemaRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.ColumnName,
			&i.DataType,
			&i.ColumnDefault,
			&i.IsNullable,
			&i.CharacterMaximumLength,
			&i.NumericPrecision,
			&i.NumericScale,
			&i.OrdinalPosition,
			&i.GeneratedType,
			&i.IdentityGeneration,
			&i.TableOid,
			&i.SequenceType,
			&i.SeqIncrementBy,
			&i.SeqMinValue,
			&i.SeqMaxValue,
			&i.SeqStartValue,
			&i.SeqCacheValue,
			&i.SeqCycleOption,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatabaseTableSchemasBySchemasAndTables = `-- name: GetDatabaseTableSchemasBySchemasAndTables :many
WITH linked_to_serial AS (
    SELECT
        cl.relname AS sequence_name,
        nsp.nspname AS schema_name,
        cl.oid AS sequence_oid,
        ad.adrelid,
        ad.adnum,
        pg_catalog.pg_get_expr(ad.adbin, ad.adrelid)
    FROM
        pg_catalog.pg_class cl
    JOIN
        pg_catalog.pg_namespace nsp ON cl.relnamespace = nsp.oid
    JOIN
        pg_catalog.pg_depend dep ON dep.objid = cl.oid AND dep.classid = 'pg_catalog.pg_class'::regclass
    JOIN
        pg_catalog.pg_attrdef ad ON dep.refobjid = ad.adrelid AND dep.refobjsubid = ad.adnum
    WHERE
        pg_catalog.pg_get_expr(ad.adbin, ad.adrelid) LIKE 'nextval%' AND cl.relkind = 'S'
),
column_defaults AS (
    SELECT
        n.nspname AS schema_name,
        c.relname AS table_name,
        a.attname AS column_name,
        pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,
        COALESCE(pg_catalog.pg_get_expr(d.adbin, d.adrelid), '')::text AS column_default,
        CASE WHEN a.attnotnull THEN 'NO' ELSE 'YES' END AS is_nullable,
        CASE
            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) LIKE 'character varying%' THEN
                a.atttypmod - 4
            WHEN pg_catalog.format_type(a.atttypid, a.atttypmod) LIKE 'character(%' THEN
                a.atttypmod - 4
            ELSE
                -1
        END AS character_maximum_length,
        CASE
            WHEN a.atttypid = pg_catalog.regtype 'numeric'::regtype THEN
                (a.atttypmod - 4) >> 16
            WHEN a.atttypid = pg_catalog.regtype 'smallint'::regtype THEN
                16
            WHEN a.atttypid = pg_catalog.regtype 'integer'::regtype THEN
                32
            WHEN a.atttypid = pg_catalog.regtype 'bigint'::regtype THEN
                64
            ELSE
                -1
        END AS numeric_precision,
        CASE
            WHEN a.atttypid = pg_catalog.regtype 'numeric'::regtype THEN
                CASE
                    WHEN (a.atttypmod) = -1 THEN -1
                    ELSE (a.atttypmod - 4) & 65535
                END
            WHEN a.atttypid = pg_catalog.regtype 'smallint'::regtype THEN
                0
            WHEN a.atttypid = pg_catalog.regtype 'integer'::regtype THEN
                0
            WHEN a.atttypid = pg_catalog.regtype 'bigint'::regtype THEN
                0
            ELSE
                -1
        END AS numeric_scale,
        a.attnum AS ordinal_position,
        a.attgenerated::text as generated_type,
        a.attidentity::text as identity_generation,
        c.oid AS table_oid
    FROM
        pg_catalog.pg_attribute a
    INNER JOIN pg_catalog.pg_class c ON a.attrelid = c.oid
    INNER JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    LEFT JOIN pg_catalog.pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
    WHERE
        (n.nspname || '.' || c.relname) = ANY($1::TEXT[])
        AND a.attnum > 0
        AND NOT a.attisdropped
        AND c.relkind = 'r'
),
identity_columns AS (
    SELECT
        n.nspname AS schema_name,
        c.relname AS table_name,
        a.attname AS column_name,
        a.attidentity AS identity_generation,
        s.seqincrement AS increment_by,
        s.seqmin AS min_value,
        s.seqmax AS max_value,
        s.seqstart AS start_value,
        s.seqcache AS cache_value,
        s.seqcycle AS cycle_option
    FROM
        pg_catalog.pg_class c
    JOIN
        pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    JOIN
        pg_catalog.pg_attribute a ON a.attrelid = c.oid
    JOIN
        pg_catalog.pg_class seq ON seq.relname = c.relname || '_' || a.attname || '_seq'
        AND seq.relnamespace = c.relnamespace
    JOIN
        pg_catalog.pg_sequence s ON seq.oid = s.seqrelid
    WHERE
        a.attidentity IN ('a', 'd')
)
SELECT
    cd.schema_name, cd.table_name, cd.column_name, cd.data_type, cd.column_default, cd.is_nullable, cd.character_maximum_length, cd.numeric_precision, cd.numeric_scale, cd.ordinal_position, cd.generated_type, cd.identity_generation, cd.table_oid,
    CASE
        WHEN ls.sequence_oid IS NOT NULL THEN 'SERIAL'
        WHEN cd.column_default LIKE 'nextval(%::regclass)' THEN 'USER-DEFINED SEQUENCE'
        WHEN cd.identity_generation != '' THEN 'IDENTITY'
        ELSE ''
    END AS sequence_type,
    ic.increment_by as seq_increment_by,
    ic.min_value as seq_min_value,
    ic.max_value as seq_max_value,
    ic.start_value as seq_start_value,
    ic.cache_value as seq_cache_value,
    ic.cycle_option as seq_cycle_option
FROM
    column_defaults cd
LEFT JOIN linked_to_serial ls
    ON cd.table_oid = ls.adrelid
    AND cd.ordinal_position = ls.adnum
LEFT JOIN identity_columns ic
    ON cd.schema_name = ic.schema_name
    AND cd.table_name = ic.table_name
    AND cd.column_name = ic.column_name
ORDER BY
    cd.ordinal_position
`

type GetDatabaseTableSchemasBySchemasAndTablesRow struct {
	SchemaName             string
	TableName              string
	ColumnName             string
	DataType               string
	ColumnDefault          string
	IsNullable             string
	CharacterMaximumLength int32
	NumericPrecision       int32
	NumericScale           int32
	OrdinalPosition        int16
	GeneratedType          string
	IdentityGeneration     string
	TableOid               interface{}
	SequenceType           string
	SeqIncrementBy         sql.NullInt64
	SeqMinValue            sql.NullInt64
	SeqMaxValue            sql.NullInt64
	SeqStartValue          sql.NullInt64
	SeqCacheValue          sql.NullInt64
	SeqCycleOption         sql.NullBool
}

func (q *Queries) GetDatabaseTableSchemasBySchemasAndTables(ctx context.Context, db DBTX, schematables []string) ([]*GetDatabaseTableSchemasBySchemasAndTablesRow, error) {
	rows, err := db.QueryContext(ctx, getDatabaseTableSchemasBySchemasAndTables, pq.Array(schematables))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetDatabaseTableSchemasBySchemasAndTablesRow
	for rows.Next() {
		var i GetDatabaseTableSchemasBySchemasAndTablesRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.ColumnName,
			&i.DataType,
			&i.ColumnDefault,
			&i.IsNullable,
			&i.CharacterMaximumLength,
			&i.NumericPrecision,
			&i.NumericScale,
			&i.OrdinalPosition,
			&i.GeneratedType,
			&i.IdentityGeneration,
			&i.TableOid,
			&i.SequenceType,
			&i.SeqIncrementBy,
			&i.SeqMinValue,
			&i.SeqMaxValue,
			&i.SeqStartValue,
			&i.SeqCacheValue,
			&i.SeqCycleOption,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExtensions = `-- name: GetExtensions :many
SELECT
    e.extname AS extension_name,
    e.extversion AS installed_version,
    n.nspname as schema_name
FROM
    pg_catalog.pg_extension e
LEFT JOIN pg_catalog.pg_namespace n ON e.extnamespace = n.oid
WHERE extname != 'plpgsql'
ORDER BY
    extname
`

type GetExtensionsRow struct {
	ExtensionName    string
	InstalledVersion string
	SchemaName       sql.NullString
}

func (q *Queries) GetExtensions(ctx context.Context, db DBTX) ([]*GetExtensionsRow, error) {
	rows, err := db.QueryContext(ctx, getExtensions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetExtensionsRow
	for rows.Next() {
		var i GetExtensionsRow
		if err := rows.Scan(&i.ExtensionName, &i.InstalledVersion, &i.SchemaName); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForeignKeyConstraintsBySchemas = `-- name: GetForeignKeyConstraintsBySchemas :many
SELECT
    con.conname AS constraint_name,
    nsp.nspname AS referencing_schema,
    cls.relname AS referencing_table,
    array_agg(att.attname)::TEXT[] AS referencing_columns,
    array_agg(att.attnotnull)::BOOL[] AS not_nullable,
    fk_nsp.nspname::TEXT AS referenced_schema,
    fn_cl.relname::TEXT referenced_table,
    fk_columns.foreign_column_names::TEXT[]  as referenced_columns
FROM
    pg_catalog.pg_constraint con
JOIN
    pg_catalog.pg_attribute att ON
    att.attrelid = con.conrelid
    AND att.attnum = ANY(con.conkey)
JOIN
    pg_catalog.pg_class cls ON
    con.conrelid = cls.oid
JOIN
    pg_catalog.pg_namespace nsp ON
    cls.relnamespace = nsp.oid
LEFT JOIN
    pg_catalog.pg_class fn_cl ON
    fn_cl.oid = con.confrelid
LEFT JOIN
    pg_catalog.pg_namespace fk_nsp ON
    fn_cl.relnamespace = fk_nsp.oid
LEFT JOIN LATERAL (
        SELECT
            array_agg(fk_att.attname) AS foreign_column_names
        FROM
            pg_catalog.pg_attribute fk_att
        WHERE
            fk_att.attrelid = con.confrelid
            AND fk_att.attnum = ANY(con.confkey)
    ) AS fk_columns ON
    TRUE
WHERE
    nsp.nspname = ANY($1::TEXT[]) 
    /* Limit to FOREIGN KEY constraints */
    AND con.contype = 'f'
GROUP BY
    con.oid,
    nsp.nspname,
    con.conname,
    cls.relname,
    con.contype,
    fk_nsp.nspname,
    fn_cl.relname,
    fk_columns.foreign_column_names
`

type GetForeignKeyConstraintsBySchemasRow struct {
	ConstraintName     string
	ReferencingSchema  string
	ReferencingTable   string
	ReferencingColumns []string
	NotNullable        []bool
	ReferencedSchema   string
	ReferencedTable    string
	ReferencedColumns  []string
}

func (q *Queries) GetForeignKeyConstraintsBySchemas(ctx context.Context, db DBTX, schemas []string) ([]*GetForeignKeyConstraintsBySchemasRow, error) {
	rows, err := db.QueryContext(ctx, getForeignKeyConstraintsBySchemas, pq.Array(schemas))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetForeignKeyConstraintsBySchemasRow
	for rows.Next() {
		var i GetForeignKeyConstraintsBySchemasRow
		if err := rows.Scan(
			&i.ConstraintName,
			&i.ReferencingSchema,
			&i.ReferencingTable,
			pq.Array(&i.ReferencingColumns),
			pq.Array(&i.NotNullable),
			&i.ReferencedSchema,
			&i.ReferencedTable,
			pq.Array(&i.ReferencedColumns),
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndicesBySchemasAndTables = `-- name: GetIndicesBySchemasAndTables :many
SELECT
    ns.nspname AS schema_name,
    t.relname AS table_name,
    i.relname AS index_name,
    pg_get_indexdef(ix.indexrelid) AS index_definition
FROM
    pg_catalog.pg_class t
    JOIN pg_catalog.pg_index ix ON t.oid = ix.indrelid
    JOIN pg_catalog.pg_class i ON i.oid = ix.indexrelid
    JOIN pg_catalog.pg_namespace ns ON t.relnamespace = ns.oid
LEFT JOIN pg_catalog.pg_constraint con ON con.conindid = ix.indexrelid
WHERE
    (ns.nspname || '.' || t.relname) = ANY($1::TEXT[])
GROUP BY
    ns.nspname, t.relname, i.relname, ix.indexrelid
ORDER BY
    schema_name,
    table_name,
    index_name
`

type GetIndicesBySchemasAndTablesRow struct {
	SchemaName      string
	TableName       string
	IndexName       string
	IndexDefinition string
}

func (q *Queries) GetIndicesBySchemasAndTables(ctx context.Context, db DBTX, schematables []string) ([]*GetIndicesBySchemasAndTablesRow, error) {
	rows, err := db.QueryContext(ctx, getIndicesBySchemasAndTables, pq.Array(schematables))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetIndicesBySchemasAndTablesRow
	for rows.Next() {
		var i GetIndicesBySchemasAndTablesRow
		if err := rows.Scan(
			&i.SchemaName,
			&i.TableName,
			&i.IndexName,
			&i.IndexDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonForeignKeyTableConstraintsBySchema = `-- name: GetNonForeignKeyTableConstraintsBySchema :many
SELECT
    tc.constraint_name,
    tc.constraint_type::TEXT AS constraint_type,
    tc.table_schema AS schema_name,
    tc.table_name,
    /* Collect all columns associated with this constraint, if any */
    ARRAY_AGG(kcu.column_name ORDER BY kcu.ordinal_position)
        FILTER (WHERE kcu.column_name IS NOT NULL)::TEXT[]  AS constraint_columns,
    /* Pull the actual definition from pg_get_constraintdef for completeness */
    pg_get_constraintdef(pgcon.oid)::TEXT AS constraint_definition
FROM information_schema.table_constraints AS tc
    /* LEFT JOIN so that constraints without specific columns (e.g. some CHECKs) arenâ€™t lost */
    LEFT JOIN information_schema.key_column_usage AS kcu
        ON  tc.constraint_name = kcu.constraint_name
        AND tc.table_schema = kcu.table_schema
        AND tc.table_name   = kcu.table_name

    /* Map the info_schema schema name to pg_namespace for use in pg_constraint */
    JOIN pg_catalog.pg_namespace AS pn
        ON pn.nspname = tc.table_schema

    /* Retrieve the constraint definition from pg_get_constraintdef() */
    JOIN pg_catalog.pg_constraint AS pgcon
        ON  pgcon.conname     = tc.constraint_name
        AND pgcon.connamespace = pn.oid

WHERE
    tc.table_schema =  ANY($1::TEXT[])
    /* Exclude foreign keys */
    AND tc.constraint_type <> 'FOREIGN KEY'
GROUP BY
    tc.constraint_name,
    tc.constraint_type,
    tc.table_schema,
    tc.table_name,
    pgcon.oid
ORDER BY
    tc.table_name,
    tc.constraint_name
`

type GetNonForeignKeyTableConstraintsBySchemaRow struct {
	ConstraintName       string
	ConstraintType       string
	SchemaName           string
	TableName            string
	ConstraintColumns    []string
	ConstraintDefinition string
}

func (q *Queries) GetNonForeignKeyTableConstraintsBySchema(ctx context.Context, db DBTX, schema []string) ([]*GetNonForeignKeyTableConstraintsBySchemaRow, error) {
	rows, err := db.QueryContext(ctx, getNonForeignKeyTableConstraintsBySchema, pq.Array(schema))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetNonForeignKeyTableConstraintsBySchemaRow
	for rows.Next() {
		var i GetNonForeignKeyTableConstraintsBySchemaRow
		if err := rows.Scan(
			&i.ConstraintName,
			&i.ConstraintType,
			&i.SchemaName,
			&i.TableName,
			pq.Array(&i.ConstraintColumns),
			&i.ConstraintDefinition,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostgresRolePermissions = `-- name: GetPostgresRolePermissions :many
SELECT
    tp.table_schema::text as table_schema,
    tp.table_name::text as table_name,
    tp.privilege_type::text as privilege_type
FROM
    information_schema.table_privileges AS tp
WHERE
    tp.table_schema NOT IN ('pg_catalog', 'information_schema')
AND (tp.grantee = current_user OR tp.grantee = 'PUBLIC')
ORDER BY
    tp.table_schema,
    tp.table_name
`

type GetPostgresRolePermissionsRow struct {
	TableSchema   string
	TableName     string
	PrivilegeType string
}

func (q *Queries) GetPostgresRolePermissions(ctx context.Context, db DBTX) ([]*GetPostgresRolePermissionsRow, error) {
	rows, err := db.QueryContext(ctx, getPostgresRolePermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetPostgresRolePermissionsRow
	for rows.Next() {
		var i GetPostgresRolePermissionsRow
		if err := rows.Scan(&i.TableSchema, &i.TableName, &i.PrivilegeType); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
