// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: account-hooks.sql

package db_queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAccountHook = `-- name: CreateAccountHook :one
INSERT INTO neosync_api.account_hooks (
  name, description, account_id, events, config, created_by_user_id, updated_by_user_id, enabled
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, name, description, account_id, events, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, hook_type
`

type CreateAccountHookParams struct {
	Name            string
	Description     string
	AccountID       pgtype.UUID
	Events          []int32
	Config          []byte
	CreatedByUserID pgtype.UUID
	UpdatedByUserID pgtype.UUID
	Enabled         bool
}

func (q *Queries) CreateAccountHook(ctx context.Context, db DBTX, arg CreateAccountHookParams) (NeosyncApiAccountHook, error) {
	row := db.QueryRow(ctx, createAccountHook,
		arg.Name,
		arg.Description,
		arg.AccountID,
		arg.Events,
		arg.Config,
		arg.CreatedByUserID,
		arg.UpdatedByUserID,
		arg.Enabled,
	)
	var i NeosyncApiAccountHook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccountID,
		&i.Events,
		&i.Config,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedByUserID,
		&i.UpdatedAt,
		&i.Enabled,
		&i.HookType,
	)
	return i, err
}

const createSlackOAuthConnection = `-- name: CreateSlackOAuthConnection :one
INSERT INTO neosync_api.slack_oauth_connections (account_id, oauth_v2_response, created_by_user_id, updated_by_user_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (account_id) DO UPDATE
SET oauth_v2_response = EXCLUDED.oauth_v2_response,
    updated_at = CURRENT_TIMESTAMP,
    updated_by_user_id = $4
RETURNING id, account_id, oauth_v2_response, created_at, updated_at, created_by_user_id, updated_by_user_id
`

type CreateSlackOAuthConnectionParams struct {
	AccountID       pgtype.UUID
	OauthV2Response []byte
	CreatedByUserID pgtype.UUID
	UpdatedByUserID pgtype.UUID
}

func (q *Queries) CreateSlackOAuthConnection(ctx context.Context, db DBTX, arg CreateSlackOAuthConnectionParams) (NeosyncApiSlackOauthConnection, error) {
	row := db.QueryRow(ctx, createSlackOAuthConnection,
		arg.AccountID,
		arg.OauthV2Response,
		arg.CreatedByUserID,
		arg.UpdatedByUserID,
	)
	var i NeosyncApiSlackOauthConnection
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.OauthV2Response,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedByUserID,
		&i.UpdatedByUserID,
	)
	return i, err
}

const deleteSlackOAuthConnection = `-- name: DeleteSlackOAuthConnection :exec
DELETE FROM neosync_api.slack_oauth_connections
WHERE account_id = $1
`

func (q *Queries) DeleteSlackOAuthConnection(ctx context.Context, db DBTX, accountID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteSlackOAuthConnection, accountID)
	return err
}

const getAccountHookById = `-- name: GetAccountHookById :one
SELECT id, name, description, account_id, events, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, hook_type from neosync_api.account_hooks WHERE id = $1
`

func (q *Queries) GetAccountHookById(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiAccountHook, error) {
	row := db.QueryRow(ctx, getAccountHookById, id)
	var i NeosyncApiAccountHook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccountID,
		&i.Events,
		&i.Config,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedByUserID,
		&i.UpdatedAt,
		&i.Enabled,
		&i.HookType,
	)
	return i, err
}

const getAccountHooksByAccount = `-- name: GetAccountHooksByAccount :many
SELECT id, name, description, account_id, events, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, hook_type from neosync_api.account_hooks WHERE account_id = $1
`

func (q *Queries) GetAccountHooksByAccount(ctx context.Context, db DBTX, accountID pgtype.UUID) ([]NeosyncApiAccountHook, error) {
	rows, err := db.Query(ctx, getAccountHooksByAccount, accountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiAccountHook
	for rows.Next() {
		var i NeosyncApiAccountHook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.AccountID,
			&i.Events,
			&i.Config,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedByUserID,
			&i.UpdatedAt,
			&i.Enabled,
			&i.HookType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveAccountHooksByEvent = `-- name: GetActiveAccountHooksByEvent :many
SELECT id, name, description, account_id, events, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, hook_type from neosync_api.account_hooks
WHERE account_id = $1
  AND enabled = true
  AND events && $2::int[]
ORDER BY created_at ASC
`

type GetActiveAccountHooksByEventParams struct {
	AccountID pgtype.UUID
	Events    []int32
}

func (q *Queries) GetActiveAccountHooksByEvent(ctx context.Context, db DBTX, arg GetActiveAccountHooksByEventParams) ([]NeosyncApiAccountHook, error) {
	rows, err := db.Query(ctx, getActiveAccountHooksByEvent, arg.AccountID, arg.Events)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiAccountHook
	for rows.Next() {
		var i NeosyncApiAccountHook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.AccountID,
			&i.Events,
			&i.Config,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedByUserID,
			&i.UpdatedAt,
			&i.Enabled,
			&i.HookType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlackAccessToken = `-- name: GetSlackAccessToken :one
SELECT (oauth_v2_response->>'access_token')::TEXT as access_token
FROM neosync_api.slack_oauth_connections
WHERE account_id = $1
`

func (q *Queries) GetSlackAccessToken(ctx context.Context, db DBTX, accountID pgtype.UUID) (string, error) {
	row := db.QueryRow(ctx, getSlackAccessToken, accountID)
	var access_token string
	err := row.Scan(&access_token)
	return access_token, err
}

const isAccountHookNameAvailable = `-- name: IsAccountHookNameAvailable :one
SELECT NOT EXISTS(
  SELECT 1
  FROM neosync_api.account_hooks
  WHERE account_id = $1 AND name = $2
)
`

type IsAccountHookNameAvailableParams struct {
	AccountID pgtype.UUID
	Name      string
}

func (q *Queries) IsAccountHookNameAvailable(ctx context.Context, db DBTX, arg IsAccountHookNameAvailableParams) (bool, error) {
	row := db.QueryRow(ctx, isAccountHookNameAvailable, arg.AccountID, arg.Name)
	var not_exists bool
	err := row.Scan(&not_exists)
	return not_exists, err
}

const removeAccountHookById = `-- name: RemoveAccountHookById :exec
DELETE FROM neosync_api.account_hooks WHERE id = $1
`

func (q *Queries) RemoveAccountHookById(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, removeAccountHookById, id)
	return err
}

const setAccountHookEnabled = `-- name: SetAccountHookEnabled :one
UPDATE neosync_api.account_hooks
SET enabled = $1,
    updated_by_user_id = $2
WHERE id = $3
RETURNING id, name, description, account_id, events, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, hook_type
`

type SetAccountHookEnabledParams struct {
	Enabled         bool
	UpdatedByUserID pgtype.UUID
	ID              pgtype.UUID
}

func (q *Queries) SetAccountHookEnabled(ctx context.Context, db DBTX, arg SetAccountHookEnabledParams) (NeosyncApiAccountHook, error) {
	row := db.QueryRow(ctx, setAccountHookEnabled, arg.Enabled, arg.UpdatedByUserID, arg.ID)
	var i NeosyncApiAccountHook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccountID,
		&i.Events,
		&i.Config,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedByUserID,
		&i.UpdatedAt,
		&i.Enabled,
		&i.HookType,
	)
	return i, err
}

const updateAccountHook = `-- name: UpdateAccountHook :one
UPDATE neosync_api.account_hooks
SET name = $1,
    description = $2,
    events = $3,
    config = $4,
    enabled = $5,
    updated_by_user_id = $6
WHERE id = $7
RETURNING id, name, description, account_id, events, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, hook_type
`

type UpdateAccountHookParams struct {
	Name            string
	Description     string
	Events          []int32
	Config          []byte
	Enabled         bool
	UpdatedByUserID pgtype.UUID
	ID              pgtype.UUID
}

func (q *Queries) UpdateAccountHook(ctx context.Context, db DBTX, arg UpdateAccountHookParams) (NeosyncApiAccountHook, error) {
	row := db.QueryRow(ctx, updateAccountHook,
		arg.Name,
		arg.Description,
		arg.Events,
		arg.Config,
		arg.Enabled,
		arg.UpdatedByUserID,
		arg.ID,
	)
	var i NeosyncApiAccountHook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.AccountID,
		&i.Events,
		&i.Config,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedByUserID,
		&i.UpdatedAt,
		&i.Enabled,
		&i.HookType,
	)
	return i, err
}
