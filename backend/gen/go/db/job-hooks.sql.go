// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: job-hooks.sql

package db_queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createJobHook = `-- name: CreateJobHook :one
INSERT INTO neosync_api.job_hooks (
  name, description, job_id, config, created_by_user_id, updated_by_user_id, enabled, priority
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, name, description, job_id, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, priority, hook_timing
`

type CreateJobHookParams struct {
	Name            string
	Description     string
	JobID           pgtype.UUID
	Config          []byte
	CreatedByUserID pgtype.UUID
	UpdatedByUserID pgtype.UUID
	Enabled         bool
	Priority        int32
}

func (q *Queries) CreateJobHook(ctx context.Context, db DBTX, arg CreateJobHookParams) (NeosyncApiJobHook, error) {
	row := db.QueryRow(ctx, createJobHook,
		arg.Name,
		arg.Description,
		arg.JobID,
		arg.Config,
		arg.CreatedByUserID,
		arg.UpdatedByUserID,
		arg.Enabled,
		arg.Priority,
	)
	var i NeosyncApiJobHook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.JobID,
		&i.Config,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedByUserID,
		&i.UpdatedAt,
		&i.Enabled,
		&i.Priority,
		&i.HookTiming,
	)
	return i, err
}

const getJobHookById = `-- name: GetJobHookById :one
SELECT id, name, description, job_id, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, priority, hook_timing from neosync_api.job_hooks WHERE id = $1
`

func (q *Queries) GetJobHookById(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiJobHook, error) {
	row := db.QueryRow(ctx, getJobHookById, id)
	var i NeosyncApiJobHook
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.JobID,
		&i.Config,
		&i.CreatedByUserID,
		&i.CreatedAt,
		&i.UpdatedByUserID,
		&i.UpdatedAt,
		&i.Enabled,
		&i.Priority,
		&i.HookTiming,
	)
	return i, err
}

const getJobHooksByJob = `-- name: GetJobHooksByJob :many
SELECT id, name, description, job_id, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, priority, hook_timing from neosync_api.job_hooks WHERE job_id = $1
`

func (q *Queries) GetJobHooksByJob(ctx context.Context, db DBTX, jobID pgtype.UUID) ([]NeosyncApiJobHook, error) {
	rows, err := db.Query(ctx, getJobHooksByJob, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiJobHook
	for rows.Next() {
		var i NeosyncApiJobHook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.JobID,
			&i.Config,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedByUserID,
			&i.UpdatedAt,
			&i.Enabled,
			&i.Priority,
			&i.HookTiming,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostSyncJobHooksToExecute = `-- name: GetPostSyncJobHooksToExecute :many
SELECT id, name, description, job_id, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, priority, hook_timing
FROM neosync_api.job_hooks
WHERE job_id = $1
  AND enabled = true
  AND hook_timing = 'post_sync'
ORDER BY priority, created_at, id ASC
`

func (q *Queries) GetPostSyncJobHooksToExecute(ctx context.Context, db DBTX, jobID pgtype.UUID) ([]NeosyncApiJobHook, error) {
	rows, err := db.Query(ctx, getPostSyncJobHooksToExecute, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiJobHook
	for rows.Next() {
		var i NeosyncApiJobHook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.JobID,
			&i.Config,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedByUserID,
			&i.UpdatedAt,
			&i.Enabled,
			&i.Priority,
			&i.HookTiming,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreSyncJobHooksToExecute = `-- name: GetPreSyncJobHooksToExecute :many
SELECT id, name, description, job_id, config, created_by_user_id, created_at, updated_by_user_id, updated_at, enabled, priority, hook_timing
FROM neosync_api.job_hooks
WHERE job_id = $1
  AND enabled = true
  AND hook_timing = 'pre_sync'
ORDER BY priority, created_at, id ASC
`

func (q *Queries) GetPreSyncJobHooksToExecute(ctx context.Context, db DBTX, jobID pgtype.UUID) ([]NeosyncApiJobHook, error) {
	rows, err := db.Query(ctx, getPreSyncJobHooksToExecute, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiJobHook
	for rows.Next() {
		var i NeosyncApiJobHook
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.JobID,
			&i.Config,
			&i.CreatedByUserID,
			&i.CreatedAt,
			&i.UpdatedByUserID,
			&i.UpdatedAt,
			&i.Enabled,
			&i.Priority,
			&i.HookTiming,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isJobHookNameAvailable = `-- name: IsJobHookNameAvailable :one
SELECT NOT EXISTS(
  SELECT 1
  FROM neosync_api.job_hooks
  WHERE job_id = $1 and name = $2
)
`

type IsJobHookNameAvailableParams struct {
	JobID pgtype.UUID
	Name  string
}

func (q *Queries) IsJobHookNameAvailable(ctx context.Context, db DBTX, arg IsJobHookNameAvailableParams) (bool, error) {
	row := db.QueryRow(ctx, isJobHookNameAvailable, arg.JobID, arg.Name)
	var not_exists bool
	err := row.Scan(&not_exists)
	return not_exists, err
}

const removeJobHookById = `-- name: RemoveJobHookById :exec
DELETE FROM neosync_api.job_hooks WHERE id = $1
`

func (q *Queries) RemoveJobHookById(ctx context.Context, db DBTX, id pgtype.UUID) error {
	_, err := db.Exec(ctx, removeJobHookById, id)
	return err
}
