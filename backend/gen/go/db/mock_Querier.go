// Code generated by mockery. DO NOT EDIT.

package db_queries

import (
	context "context"

	pg_models "github.com/nucleuscloud/neosync/backend/sql/postgresql/models"
	mock "github.com/stretchr/testify/mock"

	pgtype "github.com/jackc/pgx/v5/pgtype"
)

// MockQuerier is an autogenerated mock type for the Querier type
type MockQuerier struct {
	mock.Mock
}

type MockQuerier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQuerier) EXPECT() *MockQuerier_Expecter {
	return &MockQuerier_Expecter{mock: &_m.Mock}
}

// AreConnectionsInAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) AreConnectionsInAccount(ctx context.Context, db DBTX, arg AreConnectionsInAccountParams) (int64, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for AreConnectionsInAccount")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, AreConnectionsInAccountParams) (int64, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, AreConnectionsInAccountParams) int64); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, AreConnectionsInAccountParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_AreConnectionsInAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AreConnectionsInAccount'
type MockQuerier_AreConnectionsInAccount_Call struct {
	*mock.Call
}

// AreConnectionsInAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg AreConnectionsInAccountParams
func (_e *MockQuerier_Expecter) AreConnectionsInAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_AreConnectionsInAccount_Call {
	return &MockQuerier_AreConnectionsInAccount_Call{Call: _e.mock.On("AreConnectionsInAccount", ctx, db, arg)}
}

func (_c *MockQuerier_AreConnectionsInAccount_Call) Run(run func(ctx context.Context, db DBTX, arg AreConnectionsInAccountParams)) *MockQuerier_AreConnectionsInAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(AreConnectionsInAccountParams))
	})
	return _c
}

func (_c *MockQuerier_AreConnectionsInAccount_Call) Return(_a0 int64, _a1 error) *MockQuerier_AreConnectionsInAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_AreConnectionsInAccount_Call) RunAndReturn(run func(context.Context, DBTX, AreConnectionsInAccountParams) (int64, error)) *MockQuerier_AreConnectionsInAccount_Call {
	_c.Call.Return(run)
	return _c
}

// ConvertPersonalAccountToTeam provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) ConvertPersonalAccountToTeam(ctx context.Context, db DBTX, arg ConvertPersonalAccountToTeamParams) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for ConvertPersonalAccountToTeam")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ConvertPersonalAccountToTeamParams) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, ConvertPersonalAccountToTeamParams) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, ConvertPersonalAccountToTeamParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_ConvertPersonalAccountToTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConvertPersonalAccountToTeam'
type MockQuerier_ConvertPersonalAccountToTeam_Call struct {
	*mock.Call
}

// ConvertPersonalAccountToTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg ConvertPersonalAccountToTeamParams
func (_e *MockQuerier_Expecter) ConvertPersonalAccountToTeam(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_ConvertPersonalAccountToTeam_Call {
	return &MockQuerier_ConvertPersonalAccountToTeam_Call{Call: _e.mock.On("ConvertPersonalAccountToTeam", ctx, db, arg)}
}

func (_c *MockQuerier_ConvertPersonalAccountToTeam_Call) Run(run func(ctx context.Context, db DBTX, arg ConvertPersonalAccountToTeamParams)) *MockQuerier_ConvertPersonalAccountToTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(ConvertPersonalAccountToTeamParams))
	})
	return _c
}

func (_c *MockQuerier_ConvertPersonalAccountToTeam_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_ConvertPersonalAccountToTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_ConvertPersonalAccountToTeam_Call) RunAndReturn(run func(context.Context, DBTX, ConvertPersonalAccountToTeamParams) (NeosyncApiAccount, error)) *MockQuerier_ConvertPersonalAccountToTeam_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAccountApiKey provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateAccountApiKey(ctx context.Context, db DBTX, arg CreateAccountApiKeyParams) (NeosyncApiAccountApiKey, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccountApiKey")
	}

	var r0 NeosyncApiAccountApiKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateAccountApiKeyParams) (NeosyncApiAccountApiKey, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateAccountApiKeyParams) NeosyncApiAccountApiKey); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountApiKey)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateAccountApiKeyParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateAccountApiKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccountApiKey'
type MockQuerier_CreateAccountApiKey_Call struct {
	*mock.Call
}

// CreateAccountApiKey is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateAccountApiKeyParams
func (_e *MockQuerier_Expecter) CreateAccountApiKey(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateAccountApiKey_Call {
	return &MockQuerier_CreateAccountApiKey_Call{Call: _e.mock.On("CreateAccountApiKey", ctx, db, arg)}
}

func (_c *MockQuerier_CreateAccountApiKey_Call) Run(run func(ctx context.Context, db DBTX, arg CreateAccountApiKeyParams)) *MockQuerier_CreateAccountApiKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateAccountApiKeyParams))
	})
	return _c
}

func (_c *MockQuerier_CreateAccountApiKey_Call) Return(_a0 NeosyncApiAccountApiKey, _a1 error) *MockQuerier_CreateAccountApiKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateAccountApiKey_Call) RunAndReturn(run func(context.Context, DBTX, CreateAccountApiKeyParams) (NeosyncApiAccountApiKey, error)) *MockQuerier_CreateAccountApiKey_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAccountInvite provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateAccountInvite(ctx context.Context, db DBTX, arg CreateAccountInviteParams) (NeosyncApiAccountInvite, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccountInvite")
	}

	var r0 NeosyncApiAccountInvite
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateAccountInviteParams) (NeosyncApiAccountInvite, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateAccountInviteParams) NeosyncApiAccountInvite); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountInvite)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateAccountInviteParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateAccountInvite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccountInvite'
type MockQuerier_CreateAccountInvite_Call struct {
	*mock.Call
}

// CreateAccountInvite is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateAccountInviteParams
func (_e *MockQuerier_Expecter) CreateAccountInvite(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateAccountInvite_Call {
	return &MockQuerier_CreateAccountInvite_Call{Call: _e.mock.On("CreateAccountInvite", ctx, db, arg)}
}

func (_c *MockQuerier_CreateAccountInvite_Call) Run(run func(ctx context.Context, db DBTX, arg CreateAccountInviteParams)) *MockQuerier_CreateAccountInvite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateAccountInviteParams))
	})
	return _c
}

func (_c *MockQuerier_CreateAccountInvite_Call) Return(_a0 NeosyncApiAccountInvite, _a1 error) *MockQuerier_CreateAccountInvite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateAccountInvite_Call) RunAndReturn(run func(context.Context, DBTX, CreateAccountInviteParams) (NeosyncApiAccountInvite, error)) *MockQuerier_CreateAccountInvite_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAccountUserAssociation provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateAccountUserAssociation(ctx context.Context, db DBTX, arg CreateAccountUserAssociationParams) error {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateAccountUserAssociation")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateAccountUserAssociationParams) error); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_CreateAccountUserAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAccountUserAssociation'
type MockQuerier_CreateAccountUserAssociation_Call struct {
	*mock.Call
}

// CreateAccountUserAssociation is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateAccountUserAssociationParams
func (_e *MockQuerier_Expecter) CreateAccountUserAssociation(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateAccountUserAssociation_Call {
	return &MockQuerier_CreateAccountUserAssociation_Call{Call: _e.mock.On("CreateAccountUserAssociation", ctx, db, arg)}
}

func (_c *MockQuerier_CreateAccountUserAssociation_Call) Run(run func(ctx context.Context, db DBTX, arg CreateAccountUserAssociationParams)) *MockQuerier_CreateAccountUserAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateAccountUserAssociationParams))
	})
	return _c
}

func (_c *MockQuerier_CreateAccountUserAssociation_Call) Return(_a0 error) *MockQuerier_CreateAccountUserAssociation_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_CreateAccountUserAssociation_Call) RunAndReturn(run func(context.Context, DBTX, CreateAccountUserAssociationParams) error) *MockQuerier_CreateAccountUserAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// CreateConnection provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateConnection(ctx context.Context, db DBTX, arg CreateConnectionParams) (NeosyncApiConnection, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateConnection")
	}

	var r0 NeosyncApiConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateConnectionParams) (NeosyncApiConnection, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateConnectionParams) NeosyncApiConnection); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiConnection)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateConnectionParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateConnection'
type MockQuerier_CreateConnection_Call struct {
	*mock.Call
}

// CreateConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateConnectionParams
func (_e *MockQuerier_Expecter) CreateConnection(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateConnection_Call {
	return &MockQuerier_CreateConnection_Call{Call: _e.mock.On("CreateConnection", ctx, db, arg)}
}

func (_c *MockQuerier_CreateConnection_Call) Run(run func(ctx context.Context, db DBTX, arg CreateConnectionParams)) *MockQuerier_CreateConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateConnectionParams))
	})
	return _c
}

func (_c *MockQuerier_CreateConnection_Call) Return(_a0 NeosyncApiConnection, _a1 error) *MockQuerier_CreateConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateConnection_Call) RunAndReturn(run func(context.Context, DBTX, CreateConnectionParams) (NeosyncApiConnection, error)) *MockQuerier_CreateConnection_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIdentityProviderAssociation provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateIdentityProviderAssociation(ctx context.Context, db DBTX, arg CreateIdentityProviderAssociationParams) (NeosyncApiUserIdentityProviderAssociation, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateIdentityProviderAssociation")
	}

	var r0 NeosyncApiUserIdentityProviderAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateIdentityProviderAssociationParams) (NeosyncApiUserIdentityProviderAssociation, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateIdentityProviderAssociationParams) NeosyncApiUserIdentityProviderAssociation); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiUserIdentityProviderAssociation)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateIdentityProviderAssociationParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateIdentityProviderAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIdentityProviderAssociation'
type MockQuerier_CreateIdentityProviderAssociation_Call struct {
	*mock.Call
}

// CreateIdentityProviderAssociation is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateIdentityProviderAssociationParams
func (_e *MockQuerier_Expecter) CreateIdentityProviderAssociation(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateIdentityProviderAssociation_Call {
	return &MockQuerier_CreateIdentityProviderAssociation_Call{Call: _e.mock.On("CreateIdentityProviderAssociation", ctx, db, arg)}
}

func (_c *MockQuerier_CreateIdentityProviderAssociation_Call) Run(run func(ctx context.Context, db DBTX, arg CreateIdentityProviderAssociationParams)) *MockQuerier_CreateIdentityProviderAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateIdentityProviderAssociationParams))
	})
	return _c
}

func (_c *MockQuerier_CreateIdentityProviderAssociation_Call) Return(_a0 NeosyncApiUserIdentityProviderAssociation, _a1 error) *MockQuerier_CreateIdentityProviderAssociation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateIdentityProviderAssociation_Call) RunAndReturn(run func(context.Context, DBTX, CreateIdentityProviderAssociationParams) (NeosyncApiUserIdentityProviderAssociation, error)) *MockQuerier_CreateIdentityProviderAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJob provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateJob(ctx context.Context, db DBTX, arg CreateJobParams) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateJob")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateJobParams) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateJobParams) NeosyncApiJob); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateJobParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJob'
type MockQuerier_CreateJob_Call struct {
	*mock.Call
}

// CreateJob is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateJobParams
func (_e *MockQuerier_Expecter) CreateJob(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateJob_Call {
	return &MockQuerier_CreateJob_Call{Call: _e.mock.On("CreateJob", ctx, db, arg)}
}

func (_c *MockQuerier_CreateJob_Call) Run(run func(ctx context.Context, db DBTX, arg CreateJobParams)) *MockQuerier_CreateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateJobParams))
	})
	return _c
}

func (_c *MockQuerier_CreateJob_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_CreateJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateJob_Call) RunAndReturn(run func(context.Context, DBTX, CreateJobParams) (NeosyncApiJob, error)) *MockQuerier_CreateJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJobConnectionDestination provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateJobConnectionDestination(ctx context.Context, db DBTX, arg CreateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateJobConnectionDestination")
	}

	var r0 NeosyncApiJobDestinationConnectionAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateJobConnectionDestinationParams) NeosyncApiJobDestinationConnectionAssociation); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJobDestinationConnectionAssociation)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateJobConnectionDestinationParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateJobConnectionDestination_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJobConnectionDestination'
type MockQuerier_CreateJobConnectionDestination_Call struct {
	*mock.Call
}

// CreateJobConnectionDestination is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateJobConnectionDestinationParams
func (_e *MockQuerier_Expecter) CreateJobConnectionDestination(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateJobConnectionDestination_Call {
	return &MockQuerier_CreateJobConnectionDestination_Call{Call: _e.mock.On("CreateJobConnectionDestination", ctx, db, arg)}
}

func (_c *MockQuerier_CreateJobConnectionDestination_Call) Run(run func(ctx context.Context, db DBTX, arg CreateJobConnectionDestinationParams)) *MockQuerier_CreateJobConnectionDestination_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateJobConnectionDestinationParams))
	})
	return _c
}

func (_c *MockQuerier_CreateJobConnectionDestination_Call) Return(_a0 NeosyncApiJobDestinationConnectionAssociation, _a1 error) *MockQuerier_CreateJobConnectionDestination_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateJobConnectionDestination_Call) RunAndReturn(run func(context.Context, DBTX, CreateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error)) *MockQuerier_CreateJobConnectionDestination_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJobConnectionDestinations provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateJobConnectionDestinations(ctx context.Context, db DBTX, arg []CreateJobConnectionDestinationsParams) (int64, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateJobConnectionDestinations")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []CreateJobConnectionDestinationsParams) (int64, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []CreateJobConnectionDestinationsParams) int64); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, []CreateJobConnectionDestinationsParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateJobConnectionDestinations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJobConnectionDestinations'
type MockQuerier_CreateJobConnectionDestinations_Call struct {
	*mock.Call
}

// CreateJobConnectionDestinations is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg []CreateJobConnectionDestinationsParams
func (_e *MockQuerier_Expecter) CreateJobConnectionDestinations(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateJobConnectionDestinations_Call {
	return &MockQuerier_CreateJobConnectionDestinations_Call{Call: _e.mock.On("CreateJobConnectionDestinations", ctx, db, arg)}
}

func (_c *MockQuerier_CreateJobConnectionDestinations_Call) Run(run func(ctx context.Context, db DBTX, arg []CreateJobConnectionDestinationsParams)) *MockQuerier_CreateJobConnectionDestinations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].([]CreateJobConnectionDestinationsParams))
	})
	return _c
}

func (_c *MockQuerier_CreateJobConnectionDestinations_Call) Return(_a0 int64, _a1 error) *MockQuerier_CreateJobConnectionDestinations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateJobConnectionDestinations_Call) RunAndReturn(run func(context.Context, DBTX, []CreateJobConnectionDestinationsParams) (int64, error)) *MockQuerier_CreateJobConnectionDestinations_Call {
	_c.Call.Return(run)
	return _c
}

// CreateJobHook provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateJobHook(ctx context.Context, db DBTX, arg CreateJobHookParams) (NeosyncApiJobHook, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateJobHook")
	}

	var r0 NeosyncApiJobHook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateJobHookParams) (NeosyncApiJobHook, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateJobHookParams) NeosyncApiJobHook); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJobHook)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateJobHookParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateJobHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJobHook'
type MockQuerier_CreateJobHook_Call struct {
	*mock.Call
}

// CreateJobHook is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateJobHookParams
func (_e *MockQuerier_Expecter) CreateJobHook(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateJobHook_Call {
	return &MockQuerier_CreateJobHook_Call{Call: _e.mock.On("CreateJobHook", ctx, db, arg)}
}

func (_c *MockQuerier_CreateJobHook_Call) Run(run func(ctx context.Context, db DBTX, arg CreateJobHookParams)) *MockQuerier_CreateJobHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateJobHookParams))
	})
	return _c
}

func (_c *MockQuerier_CreateJobHook_Call) Return(_a0 NeosyncApiJobHook, _a1 error) *MockQuerier_CreateJobHook_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateJobHook_Call) RunAndReturn(run func(context.Context, DBTX, CreateJobHookParams) (NeosyncApiJobHook, error)) *MockQuerier_CreateJobHook_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMachineUser provides a mock function with given fields: ctx, db
func (_m *MockQuerier) CreateMachineUser(ctx context.Context, db DBTX) (NeosyncApiUser, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for CreateMachineUser")
	}

	var r0 NeosyncApiUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) (NeosyncApiUser, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) NeosyncApiUser); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(NeosyncApiUser)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateMachineUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMachineUser'
type MockQuerier_CreateMachineUser_Call struct {
	*mock.Call
}

// CreateMachineUser is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) CreateMachineUser(ctx interface{}, db interface{}) *MockQuerier_CreateMachineUser_Call {
	return &MockQuerier_CreateMachineUser_Call{Call: _e.mock.On("CreateMachineUser", ctx, db)}
}

func (_c *MockQuerier_CreateMachineUser_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_CreateMachineUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_CreateMachineUser_Call) Return(_a0 NeosyncApiUser, _a1 error) *MockQuerier_CreateMachineUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateMachineUser_Call) RunAndReturn(run func(context.Context, DBTX) (NeosyncApiUser, error)) *MockQuerier_CreateMachineUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNonMachineUser provides a mock function with given fields: ctx, db
func (_m *MockQuerier) CreateNonMachineUser(ctx context.Context, db DBTX) (NeosyncApiUser, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for CreateNonMachineUser")
	}

	var r0 NeosyncApiUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) (NeosyncApiUser, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) NeosyncApiUser); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(NeosyncApiUser)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateNonMachineUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNonMachineUser'
type MockQuerier_CreateNonMachineUser_Call struct {
	*mock.Call
}

// CreateNonMachineUser is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) CreateNonMachineUser(ctx interface{}, db interface{}) *MockQuerier_CreateNonMachineUser_Call {
	return &MockQuerier_CreateNonMachineUser_Call{Call: _e.mock.On("CreateNonMachineUser", ctx, db)}
}

func (_c *MockQuerier_CreateNonMachineUser_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_CreateNonMachineUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_CreateNonMachineUser_Call) Return(_a0 NeosyncApiUser, _a1 error) *MockQuerier_CreateNonMachineUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateNonMachineUser_Call) RunAndReturn(run func(context.Context, DBTX) (NeosyncApiUser, error)) *MockQuerier_CreateNonMachineUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePersonalAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreatePersonalAccount(ctx context.Context, db DBTX, arg CreatePersonalAccountParams) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreatePersonalAccount")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreatePersonalAccountParams) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreatePersonalAccountParams) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreatePersonalAccountParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreatePersonalAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePersonalAccount'
type MockQuerier_CreatePersonalAccount_Call struct {
	*mock.Call
}

// CreatePersonalAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreatePersonalAccountParams
func (_e *MockQuerier_Expecter) CreatePersonalAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreatePersonalAccount_Call {
	return &MockQuerier_CreatePersonalAccount_Call{Call: _e.mock.On("CreatePersonalAccount", ctx, db, arg)}
}

func (_c *MockQuerier_CreatePersonalAccount_Call) Run(run func(ctx context.Context, db DBTX, arg CreatePersonalAccountParams)) *MockQuerier_CreatePersonalAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreatePersonalAccountParams))
	})
	return _c
}

func (_c *MockQuerier_CreatePersonalAccount_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_CreatePersonalAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreatePersonalAccount_Call) RunAndReturn(run func(context.Context, DBTX, CreatePersonalAccountParams) (NeosyncApiAccount, error)) *MockQuerier_CreatePersonalAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTeamAccount provides a mock function with given fields: ctx, db, accountSlug
func (_m *MockQuerier) CreateTeamAccount(ctx context.Context, db DBTX, accountSlug string) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, accountSlug)

	if len(ret) == 0 {
		panic("no return value specified for CreateTeamAccount")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, accountSlug)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, accountSlug)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, string) error); ok {
		r1 = rf(ctx, db, accountSlug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateTeamAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTeamAccount'
type MockQuerier_CreateTeamAccount_Call struct {
	*mock.Call
}

// CreateTeamAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountSlug string
func (_e *MockQuerier_Expecter) CreateTeamAccount(ctx interface{}, db interface{}, accountSlug interface{}) *MockQuerier_CreateTeamAccount_Call {
	return &MockQuerier_CreateTeamAccount_Call{Call: _e.mock.On("CreateTeamAccount", ctx, db, accountSlug)}
}

func (_c *MockQuerier_CreateTeamAccount_Call) Run(run func(ctx context.Context, db DBTX, accountSlug string)) *MockQuerier_CreateTeamAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_CreateTeamAccount_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_CreateTeamAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateTeamAccount_Call) RunAndReturn(run func(context.Context, DBTX, string) (NeosyncApiAccount, error)) *MockQuerier_CreateTeamAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUserDefinedTransformer provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) CreateUserDefinedTransformer(ctx context.Context, db DBTX, arg CreateUserDefinedTransformerParams) (NeosyncApiTransformer, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateUserDefinedTransformer")
	}

	var r0 NeosyncApiTransformer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateUserDefinedTransformerParams) (NeosyncApiTransformer, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, CreateUserDefinedTransformerParams) NeosyncApiTransformer); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiTransformer)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, CreateUserDefinedTransformerParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_CreateUserDefinedTransformer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUserDefinedTransformer'
type MockQuerier_CreateUserDefinedTransformer_Call struct {
	*mock.Call
}

// CreateUserDefinedTransformer is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg CreateUserDefinedTransformerParams
func (_e *MockQuerier_Expecter) CreateUserDefinedTransformer(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_CreateUserDefinedTransformer_Call {
	return &MockQuerier_CreateUserDefinedTransformer_Call{Call: _e.mock.On("CreateUserDefinedTransformer", ctx, db, arg)}
}

func (_c *MockQuerier_CreateUserDefinedTransformer_Call) Run(run func(ctx context.Context, db DBTX, arg CreateUserDefinedTransformerParams)) *MockQuerier_CreateUserDefinedTransformer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(CreateUserDefinedTransformerParams))
	})
	return _c
}

func (_c *MockQuerier_CreateUserDefinedTransformer_Call) Return(_a0 NeosyncApiTransformer, _a1 error) *MockQuerier_CreateUserDefinedTransformer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_CreateUserDefinedTransformer_Call) RunAndReturn(run func(context.Context, DBTX, CreateUserDefinedTransformerParams) (NeosyncApiTransformer, error)) *MockQuerier_CreateUserDefinedTransformer_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteJob provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) DeleteJob(ctx context.Context, db DBTX, id pgtype.UUID) error {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_DeleteJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteJob'
type MockQuerier_DeleteJob_Call struct {
	*mock.Call
}

// DeleteJob is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) DeleteJob(ctx interface{}, db interface{}, id interface{}) *MockQuerier_DeleteJob_Call {
	return &MockQuerier_DeleteJob_Call{Call: _e.mock.On("DeleteJob", ctx, db, id)}
}

func (_c *MockQuerier_DeleteJob_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_DeleteJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_DeleteJob_Call) Return(_a0 error) *MockQuerier_DeleteJob_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_DeleteJob_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) error) *MockQuerier_DeleteJob_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUserDefinedTransformerById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) DeleteUserDefinedTransformerById(ctx context.Context, db DBTX, id pgtype.UUID) error {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserDefinedTransformerById")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_DeleteUserDefinedTransformerById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUserDefinedTransformerById'
type MockQuerier_DeleteUserDefinedTransformerById_Call struct {
	*mock.Call
}

// DeleteUserDefinedTransformerById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) DeleteUserDefinedTransformerById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_DeleteUserDefinedTransformerById_Call {
	return &MockQuerier_DeleteUserDefinedTransformerById_Call{Call: _e.mock.On("DeleteUserDefinedTransformerById", ctx, db, id)}
}

func (_c *MockQuerier_DeleteUserDefinedTransformerById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_DeleteUserDefinedTransformerById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_DeleteUserDefinedTransformerById_Call) Return(_a0 error) *MockQuerier_DeleteUserDefinedTransformerById_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_DeleteUserDefinedTransformerById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) error) *MockQuerier_DeleteUserDefinedTransformerById_Call {
	_c.Call.Return(run)
	return _c
}

// DoesJobHaveConnectionId provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) DoesJobHaveConnectionId(ctx context.Context, db DBTX, arg DoesJobHaveConnectionIdParams) (bool, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for DoesJobHaveConnectionId")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, DoesJobHaveConnectionIdParams) (bool, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, DoesJobHaveConnectionIdParams) bool); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, DoesJobHaveConnectionIdParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_DoesJobHaveConnectionId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesJobHaveConnectionId'
type MockQuerier_DoesJobHaveConnectionId_Call struct {
	*mock.Call
}

// DoesJobHaveConnectionId is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg DoesJobHaveConnectionIdParams
func (_e *MockQuerier_Expecter) DoesJobHaveConnectionId(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_DoesJobHaveConnectionId_Call {
	return &MockQuerier_DoesJobHaveConnectionId_Call{Call: _e.mock.On("DoesJobHaveConnectionId", ctx, db, arg)}
}

func (_c *MockQuerier_DoesJobHaveConnectionId_Call) Run(run func(ctx context.Context, db DBTX, arg DoesJobHaveConnectionIdParams)) *MockQuerier_DoesJobHaveConnectionId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(DoesJobHaveConnectionIdParams))
	})
	return _c
}

func (_c *MockQuerier_DoesJobHaveConnectionId_Call) Return(_a0 bool, _a1 error) *MockQuerier_DoesJobHaveConnectionId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_DoesJobHaveConnectionId_Call) RunAndReturn(run func(context.Context, DBTX, DoesJobHaveConnectionIdParams) (bool, error)) *MockQuerier_DoesJobHaveConnectionId_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccount provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetAccount(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccount")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccount'
type MockQuerier_GetAccount_Call struct {
	*mock.Call
}

// GetAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetAccount(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetAccount_Call {
	return &MockQuerier_GetAccount_Call{Call: _e.mock.On("GetAccount", ctx, db, id)}
}

func (_c *MockQuerier_GetAccount_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetAccount_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_GetAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccount_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccount, error)) *MockQuerier_GetAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountApiKeyById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetAccountApiKeyById(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiAccountApiKey, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountApiKeyById")
	}

	var r0 NeosyncApiAccountApiKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccountApiKey, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiAccountApiKey); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountApiKey)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountApiKeyById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountApiKeyById'
type MockQuerier_GetAccountApiKeyById_Call struct {
	*mock.Call
}

// GetAccountApiKeyById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetAccountApiKeyById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetAccountApiKeyById_Call {
	return &MockQuerier_GetAccountApiKeyById_Call{Call: _e.mock.On("GetAccountApiKeyById", ctx, db, id)}
}

func (_c *MockQuerier_GetAccountApiKeyById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetAccountApiKeyById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetAccountApiKeyById_Call) Return(_a0 NeosyncApiAccountApiKey, _a1 error) *MockQuerier_GetAccountApiKeyById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountApiKeyById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccountApiKey, error)) *MockQuerier_GetAccountApiKeyById_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountApiKeyByKeyValue provides a mock function with given fields: ctx, db, keyValue
func (_m *MockQuerier) GetAccountApiKeyByKeyValue(ctx context.Context, db DBTX, keyValue string) (NeosyncApiAccountApiKey, error) {
	ret := _m.Called(ctx, db, keyValue)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountApiKeyByKeyValue")
	}

	var r0 NeosyncApiAccountApiKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) (NeosyncApiAccountApiKey, error)); ok {
		return rf(ctx, db, keyValue)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) NeosyncApiAccountApiKey); ok {
		r0 = rf(ctx, db, keyValue)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountApiKey)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, string) error); ok {
		r1 = rf(ctx, db, keyValue)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountApiKeyByKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountApiKeyByKeyValue'
type MockQuerier_GetAccountApiKeyByKeyValue_Call struct {
	*mock.Call
}

// GetAccountApiKeyByKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - keyValue string
func (_e *MockQuerier_Expecter) GetAccountApiKeyByKeyValue(ctx interface{}, db interface{}, keyValue interface{}) *MockQuerier_GetAccountApiKeyByKeyValue_Call {
	return &MockQuerier_GetAccountApiKeyByKeyValue_Call{Call: _e.mock.On("GetAccountApiKeyByKeyValue", ctx, db, keyValue)}
}

func (_c *MockQuerier_GetAccountApiKeyByKeyValue_Call) Run(run func(ctx context.Context, db DBTX, keyValue string)) *MockQuerier_GetAccountApiKeyByKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_GetAccountApiKeyByKeyValue_Call) Return(_a0 NeosyncApiAccountApiKey, _a1 error) *MockQuerier_GetAccountApiKeyByKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountApiKeyByKeyValue_Call) RunAndReturn(run func(context.Context, DBTX, string) (NeosyncApiAccountApiKey, error)) *MockQuerier_GetAccountApiKeyByKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountApiKeys provides a mock function with given fields: ctx, db, accountid
func (_m *MockQuerier) GetAccountApiKeys(ctx context.Context, db DBTX, accountid pgtype.UUID) ([]NeosyncApiAccountApiKey, error) {
	ret := _m.Called(ctx, db, accountid)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountApiKeys")
	}

	var r0 []NeosyncApiAccountApiKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiAccountApiKey, error)); ok {
		return rf(ctx, db, accountid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiAccountApiKey); ok {
		r0 = rf(ctx, db, accountid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiAccountApiKey)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, accountid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountApiKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountApiKeys'
type MockQuerier_GetAccountApiKeys_Call struct {
	*mock.Call
}

// GetAccountApiKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountid pgtype.UUID
func (_e *MockQuerier_Expecter) GetAccountApiKeys(ctx interface{}, db interface{}, accountid interface{}) *MockQuerier_GetAccountApiKeys_Call {
	return &MockQuerier_GetAccountApiKeys_Call{Call: _e.mock.On("GetAccountApiKeys", ctx, db, accountid)}
}

func (_c *MockQuerier_GetAccountApiKeys_Call) Run(run func(ctx context.Context, db DBTX, accountid pgtype.UUID)) *MockQuerier_GetAccountApiKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetAccountApiKeys_Call) Return(_a0 []NeosyncApiAccountApiKey, _a1 error) *MockQuerier_GetAccountApiKeys_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountApiKeys_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiAccountApiKey, error)) *MockQuerier_GetAccountApiKeys_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountIdFromJobId provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetAccountIdFromJobId(ctx context.Context, db DBTX, id pgtype.UUID) (pgtype.UUID, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountIdFromJobId")
	}

	var r0 pgtype.UUID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (pgtype.UUID, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) pgtype.UUID); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(pgtype.UUID)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountIdFromJobId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountIdFromJobId'
type MockQuerier_GetAccountIdFromJobId_Call struct {
	*mock.Call
}

// GetAccountIdFromJobId is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetAccountIdFromJobId(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetAccountIdFromJobId_Call {
	return &MockQuerier_GetAccountIdFromJobId_Call{Call: _e.mock.On("GetAccountIdFromJobId", ctx, db, id)}
}

func (_c *MockQuerier_GetAccountIdFromJobId_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetAccountIdFromJobId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetAccountIdFromJobId_Call) Return(_a0 pgtype.UUID, _a1 error) *MockQuerier_GetAccountIdFromJobId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountIdFromJobId_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (pgtype.UUID, error)) *MockQuerier_GetAccountIdFromJobId_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountIds provides a mock function with given fields: ctx, db
func (_m *MockQuerier) GetAccountIds(ctx context.Context, db DBTX) ([]pgtype.UUID, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountIds")
	}

	var r0 []pgtype.UUID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) ([]pgtype.UUID, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) []pgtype.UUID); ok {
		r0 = rf(ctx, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]pgtype.UUID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountIds'
type MockQuerier_GetAccountIds_Call struct {
	*mock.Call
}

// GetAccountIds is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) GetAccountIds(ctx interface{}, db interface{}) *MockQuerier_GetAccountIds_Call {
	return &MockQuerier_GetAccountIds_Call{Call: _e.mock.On("GetAccountIds", ctx, db)}
}

func (_c *MockQuerier_GetAccountIds_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_GetAccountIds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_GetAccountIds_Call) Return(_a0 []pgtype.UUID, _a1 error) *MockQuerier_GetAccountIds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountIds_Call) RunAndReturn(run func(context.Context, DBTX) ([]pgtype.UUID, error)) *MockQuerier_GetAccountIds_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountInvite provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetAccountInvite(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiAccountInvite, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountInvite")
	}

	var r0 NeosyncApiAccountInvite
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccountInvite, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiAccountInvite); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountInvite)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountInvite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountInvite'
type MockQuerier_GetAccountInvite_Call struct {
	*mock.Call
}

// GetAccountInvite is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetAccountInvite(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetAccountInvite_Call {
	return &MockQuerier_GetAccountInvite_Call{Call: _e.mock.On("GetAccountInvite", ctx, db, id)}
}

func (_c *MockQuerier_GetAccountInvite_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetAccountInvite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetAccountInvite_Call) Return(_a0 NeosyncApiAccountInvite, _a1 error) *MockQuerier_GetAccountInvite_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountInvite_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccountInvite, error)) *MockQuerier_GetAccountInvite_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountInviteByToken provides a mock function with given fields: ctx, db, token
func (_m *MockQuerier) GetAccountInviteByToken(ctx context.Context, db DBTX, token string) (NeosyncApiAccountInvite, error) {
	ret := _m.Called(ctx, db, token)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountInviteByToken")
	}

	var r0 NeosyncApiAccountInvite
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) (NeosyncApiAccountInvite, error)); ok {
		return rf(ctx, db, token)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) NeosyncApiAccountInvite); ok {
		r0 = rf(ctx, db, token)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountInvite)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, string) error); ok {
		r1 = rf(ctx, db, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountInviteByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountInviteByToken'
type MockQuerier_GetAccountInviteByToken_Call struct {
	*mock.Call
}

// GetAccountInviteByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - token string
func (_e *MockQuerier_Expecter) GetAccountInviteByToken(ctx interface{}, db interface{}, token interface{}) *MockQuerier_GetAccountInviteByToken_Call {
	return &MockQuerier_GetAccountInviteByToken_Call{Call: _e.mock.On("GetAccountInviteByToken", ctx, db, token)}
}

func (_c *MockQuerier_GetAccountInviteByToken_Call) Run(run func(ctx context.Context, db DBTX, token string)) *MockQuerier_GetAccountInviteByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_GetAccountInviteByToken_Call) Return(_a0 NeosyncApiAccountInvite, _a1 error) *MockQuerier_GetAccountInviteByToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountInviteByToken_Call) RunAndReturn(run func(context.Context, DBTX, string) (NeosyncApiAccountInvite, error)) *MockQuerier_GetAccountInviteByToken_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountOnboardingConfig provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetAccountOnboardingConfig(ctx context.Context, db DBTX, id pgtype.UUID) (*pg_models.AccountOnboardingConfig, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountOnboardingConfig")
	}

	var r0 *pg_models.AccountOnboardingConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (*pg_models.AccountOnboardingConfig, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) *pg_models.AccountOnboardingConfig); ok {
		r0 = rf(ctx, db, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pg_models.AccountOnboardingConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountOnboardingConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountOnboardingConfig'
type MockQuerier_GetAccountOnboardingConfig_Call struct {
	*mock.Call
}

// GetAccountOnboardingConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetAccountOnboardingConfig(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetAccountOnboardingConfig_Call {
	return &MockQuerier_GetAccountOnboardingConfig_Call{Call: _e.mock.On("GetAccountOnboardingConfig", ctx, db, id)}
}

func (_c *MockQuerier_GetAccountOnboardingConfig_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetAccountOnboardingConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetAccountOnboardingConfig_Call) Return(_a0 *pg_models.AccountOnboardingConfig, _a1 error) *MockQuerier_GetAccountOnboardingConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountOnboardingConfig_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (*pg_models.AccountOnboardingConfig, error)) *MockQuerier_GetAccountOnboardingConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountUserAssociation provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) GetAccountUserAssociation(ctx context.Context, db DBTX, arg GetAccountUserAssociationParams) (NeosyncApiAccountUserAssociation, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountUserAssociation")
	}

	var r0 NeosyncApiAccountUserAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetAccountUserAssociationParams) (NeosyncApiAccountUserAssociation, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetAccountUserAssociationParams) NeosyncApiAccountUserAssociation); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountUserAssociation)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, GetAccountUserAssociationParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountUserAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountUserAssociation'
type MockQuerier_GetAccountUserAssociation_Call struct {
	*mock.Call
}

// GetAccountUserAssociation is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg GetAccountUserAssociationParams
func (_e *MockQuerier_Expecter) GetAccountUserAssociation(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_GetAccountUserAssociation_Call {
	return &MockQuerier_GetAccountUserAssociation_Call{Call: _e.mock.On("GetAccountUserAssociation", ctx, db, arg)}
}

func (_c *MockQuerier_GetAccountUserAssociation_Call) Run(run func(ctx context.Context, db DBTX, arg GetAccountUserAssociationParams)) *MockQuerier_GetAccountUserAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(GetAccountUserAssociationParams))
	})
	return _c
}

func (_c *MockQuerier_GetAccountUserAssociation_Call) Return(_a0 NeosyncApiAccountUserAssociation, _a1 error) *MockQuerier_GetAccountUserAssociation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountUserAssociation_Call) RunAndReturn(run func(context.Context, DBTX, GetAccountUserAssociationParams) (NeosyncApiAccountUserAssociation, error)) *MockQuerier_GetAccountUserAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountUsers provides a mock function with given fields: ctx, db, accountid
func (_m *MockQuerier) GetAccountUsers(ctx context.Context, db DBTX, accountid pgtype.UUID) ([]pgtype.UUID, error) {
	ret := _m.Called(ctx, db, accountid)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountUsers")
	}

	var r0 []pgtype.UUID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]pgtype.UUID, error)); ok {
		return rf(ctx, db, accountid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []pgtype.UUID); ok {
		r0 = rf(ctx, db, accountid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]pgtype.UUID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, accountid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountUsers'
type MockQuerier_GetAccountUsers_Call struct {
	*mock.Call
}

// GetAccountUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountid pgtype.UUID
func (_e *MockQuerier_Expecter) GetAccountUsers(ctx interface{}, db interface{}, accountid interface{}) *MockQuerier_GetAccountUsers_Call {
	return &MockQuerier_GetAccountUsers_Call{Call: _e.mock.On("GetAccountUsers", ctx, db, accountid)}
}

func (_c *MockQuerier_GetAccountUsers_Call) Run(run func(ctx context.Context, db DBTX, accountid pgtype.UUID)) *MockQuerier_GetAccountUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetAccountUsers_Call) Return(_a0 []pgtype.UUID, _a1 error) *MockQuerier_GetAccountUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountUsers_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]pgtype.UUID, error)) *MockQuerier_GetAccountUsers_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountsByUser provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetAccountsByUser(ctx context.Context, db DBTX, id pgtype.UUID) ([]NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountsByUser")
	}

	var r0 []NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiAccount, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiAccount); ok {
		r0 = rf(ctx, db, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAccountsByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountsByUser'
type MockQuerier_GetAccountsByUser_Call struct {
	*mock.Call
}

// GetAccountsByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetAccountsByUser(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetAccountsByUser_Call {
	return &MockQuerier_GetAccountsByUser_Call{Call: _e.mock.On("GetAccountsByUser", ctx, db, id)}
}

func (_c *MockQuerier_GetAccountsByUser_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetAccountsByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetAccountsByUser_Call) Return(_a0 []NeosyncApiAccount, _a1 error) *MockQuerier_GetAccountsByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAccountsByUser_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiAccount, error)) *MockQuerier_GetAccountsByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveAccountInvites provides a mock function with given fields: ctx, db, accountid
func (_m *MockQuerier) GetActiveAccountInvites(ctx context.Context, db DBTX, accountid pgtype.UUID) ([]NeosyncApiAccountInvite, error) {
	ret := _m.Called(ctx, db, accountid)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveAccountInvites")
	}

	var r0 []NeosyncApiAccountInvite
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiAccountInvite, error)); ok {
		return rf(ctx, db, accountid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiAccountInvite); ok {
		r0 = rf(ctx, db, accountid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiAccountInvite)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, accountid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetActiveAccountInvites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveAccountInvites'
type MockQuerier_GetActiveAccountInvites_Call struct {
	*mock.Call
}

// GetActiveAccountInvites is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountid pgtype.UUID
func (_e *MockQuerier_Expecter) GetActiveAccountInvites(ctx interface{}, db interface{}, accountid interface{}) *MockQuerier_GetActiveAccountInvites_Call {
	return &MockQuerier_GetActiveAccountInvites_Call{Call: _e.mock.On("GetActiveAccountInvites", ctx, db, accountid)}
}

func (_c *MockQuerier_GetActiveAccountInvites_Call) Run(run func(ctx context.Context, db DBTX, accountid pgtype.UUID)) *MockQuerier_GetActiveAccountInvites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetActiveAccountInvites_Call) Return(_a0 []NeosyncApiAccountInvite, _a1 error) *MockQuerier_GetActiveAccountInvites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetActiveAccountInvites_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiAccountInvite, error)) *MockQuerier_GetActiveAccountInvites_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveJobHooks provides a mock function with given fields: ctx, db, jobID
func (_m *MockQuerier) GetActiveJobHooks(ctx context.Context, db DBTX, jobID pgtype.UUID) ([]NeosyncApiJobHook, error) {
	ret := _m.Called(ctx, db, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveJobHooks")
	}

	var r0 []NeosyncApiJobHook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobHook, error)); ok {
		return rf(ctx, db, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiJobHook); ok {
		r0 = rf(ctx, db, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiJobHook)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetActiveJobHooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveJobHooks'
type MockQuerier_GetActiveJobHooks_Call struct {
	*mock.Call
}

// GetActiveJobHooks is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - jobID pgtype.UUID
func (_e *MockQuerier_Expecter) GetActiveJobHooks(ctx interface{}, db interface{}, jobID interface{}) *MockQuerier_GetActiveJobHooks_Call {
	return &MockQuerier_GetActiveJobHooks_Call{Call: _e.mock.On("GetActiveJobHooks", ctx, db, jobID)}
}

func (_c *MockQuerier_GetActiveJobHooks_Call) Run(run func(ctx context.Context, db DBTX, jobID pgtype.UUID)) *MockQuerier_GetActiveJobHooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetActiveJobHooks_Call) Return(_a0 []NeosyncApiJobHook, _a1 error) *MockQuerier_GetActiveJobHooks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetActiveJobHooks_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobHook, error)) *MockQuerier_GetActiveJobHooks_Call {
	_c.Call.Return(run)
	return _c
}

// GetActivePostSyncJobHooks provides a mock function with given fields: ctx, db, jobID
func (_m *MockQuerier) GetActivePostSyncJobHooks(ctx context.Context, db DBTX, jobID pgtype.UUID) ([]NeosyncApiJobHook, error) {
	ret := _m.Called(ctx, db, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetActivePostSyncJobHooks")
	}

	var r0 []NeosyncApiJobHook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobHook, error)); ok {
		return rf(ctx, db, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiJobHook); ok {
		r0 = rf(ctx, db, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiJobHook)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetActivePostSyncJobHooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActivePostSyncJobHooks'
type MockQuerier_GetActivePostSyncJobHooks_Call struct {
	*mock.Call
}

// GetActivePostSyncJobHooks is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - jobID pgtype.UUID
func (_e *MockQuerier_Expecter) GetActivePostSyncJobHooks(ctx interface{}, db interface{}, jobID interface{}) *MockQuerier_GetActivePostSyncJobHooks_Call {
	return &MockQuerier_GetActivePostSyncJobHooks_Call{Call: _e.mock.On("GetActivePostSyncJobHooks", ctx, db, jobID)}
}

func (_c *MockQuerier_GetActivePostSyncJobHooks_Call) Run(run func(ctx context.Context, db DBTX, jobID pgtype.UUID)) *MockQuerier_GetActivePostSyncJobHooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetActivePostSyncJobHooks_Call) Return(_a0 []NeosyncApiJobHook, _a1 error) *MockQuerier_GetActivePostSyncJobHooks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetActivePostSyncJobHooks_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobHook, error)) *MockQuerier_GetActivePostSyncJobHooks_Call {
	_c.Call.Return(run)
	return _c
}

// GetActivePreSyncJobHooks provides a mock function with given fields: ctx, db, jobID
func (_m *MockQuerier) GetActivePreSyncJobHooks(ctx context.Context, db DBTX, jobID pgtype.UUID) ([]NeosyncApiJobHook, error) {
	ret := _m.Called(ctx, db, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetActivePreSyncJobHooks")
	}

	var r0 []NeosyncApiJobHook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobHook, error)); ok {
		return rf(ctx, db, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiJobHook); ok {
		r0 = rf(ctx, db, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiJobHook)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetActivePreSyncJobHooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActivePreSyncJobHooks'
type MockQuerier_GetActivePreSyncJobHooks_Call struct {
	*mock.Call
}

// GetActivePreSyncJobHooks is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - jobID pgtype.UUID
func (_e *MockQuerier_Expecter) GetActivePreSyncJobHooks(ctx interface{}, db interface{}, jobID interface{}) *MockQuerier_GetActivePreSyncJobHooks_Call {
	return &MockQuerier_GetActivePreSyncJobHooks_Call{Call: _e.mock.On("GetActivePreSyncJobHooks", ctx, db, jobID)}
}

func (_c *MockQuerier_GetActivePreSyncJobHooks_Call) Run(run func(ctx context.Context, db DBTX, jobID pgtype.UUID)) *MockQuerier_GetActivePreSyncJobHooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetActivePreSyncJobHooks_Call) Return(_a0 []NeosyncApiJobHook, _a1 error) *MockQuerier_GetActivePreSyncJobHooks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetActivePreSyncJobHooks_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobHook, error)) *MockQuerier_GetActivePreSyncJobHooks_Call {
	_c.Call.Return(run)
	return _c
}

// GetAnonymousUser provides a mock function with given fields: ctx, db
func (_m *MockQuerier) GetAnonymousUser(ctx context.Context, db DBTX) (NeosyncApiUser, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for GetAnonymousUser")
	}

	var r0 NeosyncApiUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) (NeosyncApiUser, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) NeosyncApiUser); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(NeosyncApiUser)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetAnonymousUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAnonymousUser'
type MockQuerier_GetAnonymousUser_Call struct {
	*mock.Call
}

// GetAnonymousUser is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) GetAnonymousUser(ctx interface{}, db interface{}) *MockQuerier_GetAnonymousUser_Call {
	return &MockQuerier_GetAnonymousUser_Call{Call: _e.mock.On("GetAnonymousUser", ctx, db)}
}

func (_c *MockQuerier_GetAnonymousUser_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_GetAnonymousUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_GetAnonymousUser_Call) Return(_a0 NeosyncApiUser, _a1 error) *MockQuerier_GetAnonymousUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetAnonymousUser_Call) RunAndReturn(run func(context.Context, DBTX) (NeosyncApiUser, error)) *MockQuerier_GetAnonymousUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetBilledAccounts provides a mock function with given fields: ctx, db, accountids
func (_m *MockQuerier) GetBilledAccounts(ctx context.Context, db DBTX, accountids []pgtype.UUID) ([]NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, accountids)

	if len(ret) == 0 {
		panic("no return value specified for GetBilledAccounts")
	}

	var r0 []NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) ([]NeosyncApiAccount, error)); ok {
		return rf(ctx, db, accountids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) []NeosyncApiAccount); ok {
		r0 = rf(ctx, db, accountids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, []pgtype.UUID) error); ok {
		r1 = rf(ctx, db, accountids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetBilledAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBilledAccounts'
type MockQuerier_GetBilledAccounts_Call struct {
	*mock.Call
}

// GetBilledAccounts is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountids []pgtype.UUID
func (_e *MockQuerier_Expecter) GetBilledAccounts(ctx interface{}, db interface{}, accountids interface{}) *MockQuerier_GetBilledAccounts_Call {
	return &MockQuerier_GetBilledAccounts_Call{Call: _e.mock.On("GetBilledAccounts", ctx, db, accountids)}
}

func (_c *MockQuerier_GetBilledAccounts_Call) Run(run func(ctx context.Context, db DBTX, accountids []pgtype.UUID)) *MockQuerier_GetBilledAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].([]pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetBilledAccounts_Call) Return(_a0 []NeosyncApiAccount, _a1 error) *MockQuerier_GetBilledAccounts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetBilledAccounts_Call) RunAndReturn(run func(context.Context, DBTX, []pgtype.UUID) ([]NeosyncApiAccount, error)) *MockQuerier_GetBilledAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// GetConnectionById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetConnectionById(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiConnection, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetConnectionById")
	}

	var r0 NeosyncApiConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiConnection, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiConnection); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiConnection)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetConnectionById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConnectionById'
type MockQuerier_GetConnectionById_Call struct {
	*mock.Call
}

// GetConnectionById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetConnectionById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetConnectionById_Call {
	return &MockQuerier_GetConnectionById_Call{Call: _e.mock.On("GetConnectionById", ctx, db, id)}
}

func (_c *MockQuerier_GetConnectionById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetConnectionById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetConnectionById_Call) Return(_a0 NeosyncApiConnection, _a1 error) *MockQuerier_GetConnectionById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetConnectionById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiConnection, error)) *MockQuerier_GetConnectionById_Call {
	_c.Call.Return(run)
	return _c
}

// GetConnectionByNameAndAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) GetConnectionByNameAndAccount(ctx context.Context, db DBTX, arg GetConnectionByNameAndAccountParams) (NeosyncApiConnection, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetConnectionByNameAndAccount")
	}

	var r0 NeosyncApiConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetConnectionByNameAndAccountParams) (NeosyncApiConnection, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetConnectionByNameAndAccountParams) NeosyncApiConnection); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiConnection)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, GetConnectionByNameAndAccountParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetConnectionByNameAndAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConnectionByNameAndAccount'
type MockQuerier_GetConnectionByNameAndAccount_Call struct {
	*mock.Call
}

// GetConnectionByNameAndAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg GetConnectionByNameAndAccountParams
func (_e *MockQuerier_Expecter) GetConnectionByNameAndAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_GetConnectionByNameAndAccount_Call {
	return &MockQuerier_GetConnectionByNameAndAccount_Call{Call: _e.mock.On("GetConnectionByNameAndAccount", ctx, db, arg)}
}

func (_c *MockQuerier_GetConnectionByNameAndAccount_Call) Run(run func(ctx context.Context, db DBTX, arg GetConnectionByNameAndAccountParams)) *MockQuerier_GetConnectionByNameAndAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(GetConnectionByNameAndAccountParams))
	})
	return _c
}

func (_c *MockQuerier_GetConnectionByNameAndAccount_Call) Return(_a0 NeosyncApiConnection, _a1 error) *MockQuerier_GetConnectionByNameAndAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetConnectionByNameAndAccount_Call) RunAndReturn(run func(context.Context, DBTX, GetConnectionByNameAndAccountParams) (NeosyncApiConnection, error)) *MockQuerier_GetConnectionByNameAndAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetConnectionsByAccount provides a mock function with given fields: ctx, db, accountid
func (_m *MockQuerier) GetConnectionsByAccount(ctx context.Context, db DBTX, accountid pgtype.UUID) ([]NeosyncApiConnection, error) {
	ret := _m.Called(ctx, db, accountid)

	if len(ret) == 0 {
		panic("no return value specified for GetConnectionsByAccount")
	}

	var r0 []NeosyncApiConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiConnection, error)); ok {
		return rf(ctx, db, accountid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiConnection); ok {
		r0 = rf(ctx, db, accountid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, accountid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetConnectionsByAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConnectionsByAccount'
type MockQuerier_GetConnectionsByAccount_Call struct {
	*mock.Call
}

// GetConnectionsByAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountid pgtype.UUID
func (_e *MockQuerier_Expecter) GetConnectionsByAccount(ctx interface{}, db interface{}, accountid interface{}) *MockQuerier_GetConnectionsByAccount_Call {
	return &MockQuerier_GetConnectionsByAccount_Call{Call: _e.mock.On("GetConnectionsByAccount", ctx, db, accountid)}
}

func (_c *MockQuerier_GetConnectionsByAccount_Call) Run(run func(ctx context.Context, db DBTX, accountid pgtype.UUID)) *MockQuerier_GetConnectionsByAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetConnectionsByAccount_Call) Return(_a0 []NeosyncApiConnection, _a1 error) *MockQuerier_GetConnectionsByAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetConnectionsByAccount_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiConnection, error)) *MockQuerier_GetConnectionsByAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetConnectionsByIds provides a mock function with given fields: ctx, db, dollar_1
func (_m *MockQuerier) GetConnectionsByIds(ctx context.Context, db DBTX, dollar_1 []pgtype.UUID) ([]NeosyncApiConnection, error) {
	ret := _m.Called(ctx, db, dollar_1)

	if len(ret) == 0 {
		panic("no return value specified for GetConnectionsByIds")
	}

	var r0 []NeosyncApiConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) ([]NeosyncApiConnection, error)); ok {
		return rf(ctx, db, dollar_1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) []NeosyncApiConnection); ok {
		r0 = rf(ctx, db, dollar_1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiConnection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, []pgtype.UUID) error); ok {
		r1 = rf(ctx, db, dollar_1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetConnectionsByIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConnectionsByIds'
type MockQuerier_GetConnectionsByIds_Call struct {
	*mock.Call
}

// GetConnectionsByIds is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - dollar_1 []pgtype.UUID
func (_e *MockQuerier_Expecter) GetConnectionsByIds(ctx interface{}, db interface{}, dollar_1 interface{}) *MockQuerier_GetConnectionsByIds_Call {
	return &MockQuerier_GetConnectionsByIds_Call{Call: _e.mock.On("GetConnectionsByIds", ctx, db, dollar_1)}
}

func (_c *MockQuerier_GetConnectionsByIds_Call) Run(run func(ctx context.Context, db DBTX, dollar_1 []pgtype.UUID)) *MockQuerier_GetConnectionsByIds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].([]pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetConnectionsByIds_Call) Return(_a0 []NeosyncApiConnection, _a1 error) *MockQuerier_GetConnectionsByIds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetConnectionsByIds_Call) RunAndReturn(run func(context.Context, DBTX, []pgtype.UUID) ([]NeosyncApiConnection, error)) *MockQuerier_GetConnectionsByIds_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetJobById(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetJobById")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiJob); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetJobById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobById'
type MockQuerier_GetJobById_Call struct {
	*mock.Call
}

// GetJobById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetJobById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetJobById_Call {
	return &MockQuerier_GetJobById_Call{Call: _e.mock.On("GetJobById", ctx, db, id)}
}

func (_c *MockQuerier_GetJobById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetJobById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetJobById_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_GetJobById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetJobById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiJob, error)) *MockQuerier_GetJobById_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobByNameAndAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) GetJobByNameAndAccount(ctx context.Context, db DBTX, arg GetJobByNameAndAccountParams) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetJobByNameAndAccount")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetJobByNameAndAccountParams) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetJobByNameAndAccountParams) NeosyncApiJob); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, GetJobByNameAndAccountParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetJobByNameAndAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobByNameAndAccount'
type MockQuerier_GetJobByNameAndAccount_Call struct {
	*mock.Call
}

// GetJobByNameAndAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg GetJobByNameAndAccountParams
func (_e *MockQuerier_Expecter) GetJobByNameAndAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_GetJobByNameAndAccount_Call {
	return &MockQuerier_GetJobByNameAndAccount_Call{Call: _e.mock.On("GetJobByNameAndAccount", ctx, db, arg)}
}

func (_c *MockQuerier_GetJobByNameAndAccount_Call) Run(run func(ctx context.Context, db DBTX, arg GetJobByNameAndAccountParams)) *MockQuerier_GetJobByNameAndAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(GetJobByNameAndAccountParams))
	})
	return _c
}

func (_c *MockQuerier_GetJobByNameAndAccount_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_GetJobByNameAndAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetJobByNameAndAccount_Call) RunAndReturn(run func(context.Context, DBTX, GetJobByNameAndAccountParams) (NeosyncApiJob, error)) *MockQuerier_GetJobByNameAndAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobConnectionDestination provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetJobConnectionDestination(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiJobDestinationConnectionAssociation, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetJobConnectionDestination")
	}

	var r0 NeosyncApiJobDestinationConnectionAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiJobDestinationConnectionAssociation, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiJobDestinationConnectionAssociation); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiJobDestinationConnectionAssociation)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetJobConnectionDestination_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobConnectionDestination'
type MockQuerier_GetJobConnectionDestination_Call struct {
	*mock.Call
}

// GetJobConnectionDestination is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetJobConnectionDestination(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetJobConnectionDestination_Call {
	return &MockQuerier_GetJobConnectionDestination_Call{Call: _e.mock.On("GetJobConnectionDestination", ctx, db, id)}
}

func (_c *MockQuerier_GetJobConnectionDestination_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetJobConnectionDestination_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetJobConnectionDestination_Call) Return(_a0 NeosyncApiJobDestinationConnectionAssociation, _a1 error) *MockQuerier_GetJobConnectionDestination_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetJobConnectionDestination_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiJobDestinationConnectionAssociation, error)) *MockQuerier_GetJobConnectionDestination_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobConnectionDestinations provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetJobConnectionDestinations(ctx context.Context, db DBTX, id pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetJobConnectionDestinations")
	}

	var r0 []NeosyncApiJobDestinationConnectionAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiJobDestinationConnectionAssociation); ok {
		r0 = rf(ctx, db, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiJobDestinationConnectionAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetJobConnectionDestinations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobConnectionDestinations'
type MockQuerier_GetJobConnectionDestinations_Call struct {
	*mock.Call
}

// GetJobConnectionDestinations is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetJobConnectionDestinations(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetJobConnectionDestinations_Call {
	return &MockQuerier_GetJobConnectionDestinations_Call{Call: _e.mock.On("GetJobConnectionDestinations", ctx, db, id)}
}

func (_c *MockQuerier_GetJobConnectionDestinations_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetJobConnectionDestinations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetJobConnectionDestinations_Call) Return(_a0 []NeosyncApiJobDestinationConnectionAssociation, _a1 error) *MockQuerier_GetJobConnectionDestinations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetJobConnectionDestinations_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error)) *MockQuerier_GetJobConnectionDestinations_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobConnectionDestinationsByJobIds provides a mock function with given fields: ctx, db, jobids
func (_m *MockQuerier) GetJobConnectionDestinationsByJobIds(ctx context.Context, db DBTX, jobids []pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error) {
	ret := _m.Called(ctx, db, jobids)

	if len(ret) == 0 {
		panic("no return value specified for GetJobConnectionDestinationsByJobIds")
	}

	var r0 []NeosyncApiJobDestinationConnectionAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error)); ok {
		return rf(ctx, db, jobids)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) []NeosyncApiJobDestinationConnectionAssociation); ok {
		r0 = rf(ctx, db, jobids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiJobDestinationConnectionAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, []pgtype.UUID) error); ok {
		r1 = rf(ctx, db, jobids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetJobConnectionDestinationsByJobIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobConnectionDestinationsByJobIds'
type MockQuerier_GetJobConnectionDestinationsByJobIds_Call struct {
	*mock.Call
}

// GetJobConnectionDestinationsByJobIds is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - jobids []pgtype.UUID
func (_e *MockQuerier_Expecter) GetJobConnectionDestinationsByJobIds(ctx interface{}, db interface{}, jobids interface{}) *MockQuerier_GetJobConnectionDestinationsByJobIds_Call {
	return &MockQuerier_GetJobConnectionDestinationsByJobIds_Call{Call: _e.mock.On("GetJobConnectionDestinationsByJobIds", ctx, db, jobids)}
}

func (_c *MockQuerier_GetJobConnectionDestinationsByJobIds_Call) Run(run func(ctx context.Context, db DBTX, jobids []pgtype.UUID)) *MockQuerier_GetJobConnectionDestinationsByJobIds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].([]pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetJobConnectionDestinationsByJobIds_Call) Return(_a0 []NeosyncApiJobDestinationConnectionAssociation, _a1 error) *MockQuerier_GetJobConnectionDestinationsByJobIds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetJobConnectionDestinationsByJobIds_Call) RunAndReturn(run func(context.Context, DBTX, []pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error)) *MockQuerier_GetJobConnectionDestinationsByJobIds_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobHookById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetJobHookById(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiJobHook, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetJobHookById")
	}

	var r0 NeosyncApiJobHook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiJobHook, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiJobHook); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiJobHook)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetJobHookById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobHookById'
type MockQuerier_GetJobHookById_Call struct {
	*mock.Call
}

// GetJobHookById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetJobHookById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetJobHookById_Call {
	return &MockQuerier_GetJobHookById_Call{Call: _e.mock.On("GetJobHookById", ctx, db, id)}
}

func (_c *MockQuerier_GetJobHookById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetJobHookById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetJobHookById_Call) Return(_a0 NeosyncApiJobHook, _a1 error) *MockQuerier_GetJobHookById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetJobHookById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiJobHook, error)) *MockQuerier_GetJobHookById_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobHooksByJob provides a mock function with given fields: ctx, db, jobID
func (_m *MockQuerier) GetJobHooksByJob(ctx context.Context, db DBTX, jobID pgtype.UUID) ([]NeosyncApiJobHook, error) {
	ret := _m.Called(ctx, db, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobHooksByJob")
	}

	var r0 []NeosyncApiJobHook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobHook, error)); ok {
		return rf(ctx, db, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiJobHook); ok {
		r0 = rf(ctx, db, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiJobHook)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetJobHooksByJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobHooksByJob'
type MockQuerier_GetJobHooksByJob_Call struct {
	*mock.Call
}

// GetJobHooksByJob is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - jobID pgtype.UUID
func (_e *MockQuerier_Expecter) GetJobHooksByJob(ctx interface{}, db interface{}, jobID interface{}) *MockQuerier_GetJobHooksByJob_Call {
	return &MockQuerier_GetJobHooksByJob_Call{Call: _e.mock.On("GetJobHooksByJob", ctx, db, jobID)}
}

func (_c *MockQuerier_GetJobHooksByJob_Call) Run(run func(ctx context.Context, db DBTX, jobID pgtype.UUID)) *MockQuerier_GetJobHooksByJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetJobHooksByJob_Call) Return(_a0 []NeosyncApiJobHook, _a1 error) *MockQuerier_GetJobHooksByJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetJobHooksByJob_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJobHook, error)) *MockQuerier_GetJobHooksByJob_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobsByAccount provides a mock function with given fields: ctx, db, accountid
func (_m *MockQuerier) GetJobsByAccount(ctx context.Context, db DBTX, accountid pgtype.UUID) ([]NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, accountid)

	if len(ret) == 0 {
		panic("no return value specified for GetJobsByAccount")
	}

	var r0 []NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJob, error)); ok {
		return rf(ctx, db, accountid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiJob); ok {
		r0 = rf(ctx, db, accountid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiJob)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, accountid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetJobsByAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobsByAccount'
type MockQuerier_GetJobsByAccount_Call struct {
	*mock.Call
}

// GetJobsByAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountid pgtype.UUID
func (_e *MockQuerier_Expecter) GetJobsByAccount(ctx interface{}, db interface{}, accountid interface{}) *MockQuerier_GetJobsByAccount_Call {
	return &MockQuerier_GetJobsByAccount_Call{Call: _e.mock.On("GetJobsByAccount", ctx, db, accountid)}
}

func (_c *MockQuerier_GetJobsByAccount_Call) Run(run func(ctx context.Context, db DBTX, accountid pgtype.UUID)) *MockQuerier_GetJobsByAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetJobsByAccount_Call) Return(_a0 []NeosyncApiJob, _a1 error) *MockQuerier_GetJobsByAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetJobsByAccount_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiJob, error)) *MockQuerier_GetJobsByAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetPersonalAccountByUserId provides a mock function with given fields: ctx, db, userid
func (_m *MockQuerier) GetPersonalAccountByUserId(ctx context.Context, db DBTX, userid pgtype.UUID) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, userid)

	if len(ret) == 0 {
		panic("no return value specified for GetPersonalAccountByUserId")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, userid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, userid)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, userid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetPersonalAccountByUserId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPersonalAccountByUserId'
type MockQuerier_GetPersonalAccountByUserId_Call struct {
	*mock.Call
}

// GetPersonalAccountByUserId is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - userid pgtype.UUID
func (_e *MockQuerier_Expecter) GetPersonalAccountByUserId(ctx interface{}, db interface{}, userid interface{}) *MockQuerier_GetPersonalAccountByUserId_Call {
	return &MockQuerier_GetPersonalAccountByUserId_Call{Call: _e.mock.On("GetPersonalAccountByUserId", ctx, db, userid)}
}

func (_c *MockQuerier_GetPersonalAccountByUserId_Call) Run(run func(ctx context.Context, db DBTX, userid pgtype.UUID)) *MockQuerier_GetPersonalAccountByUserId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetPersonalAccountByUserId_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_GetPersonalAccountByUserId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetPersonalAccountByUserId_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccount, error)) *MockQuerier_GetPersonalAccountByUserId_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunContextByKey provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) GetRunContextByKey(ctx context.Context, db DBTX, arg GetRunContextByKeyParams) (NeosyncApiRuncontext, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetRunContextByKey")
	}

	var r0 NeosyncApiRuncontext
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetRunContextByKeyParams) (NeosyncApiRuncontext, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetRunContextByKeyParams) NeosyncApiRuncontext); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiRuncontext)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, GetRunContextByKeyParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetRunContextByKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunContextByKey'
type MockQuerier_GetRunContextByKey_Call struct {
	*mock.Call
}

// GetRunContextByKey is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg GetRunContextByKeyParams
func (_e *MockQuerier_Expecter) GetRunContextByKey(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_GetRunContextByKey_Call {
	return &MockQuerier_GetRunContextByKey_Call{Call: _e.mock.On("GetRunContextByKey", ctx, db, arg)}
}

func (_c *MockQuerier_GetRunContextByKey_Call) Run(run func(ctx context.Context, db DBTX, arg GetRunContextByKeyParams)) *MockQuerier_GetRunContextByKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(GetRunContextByKeyParams))
	})
	return _c
}

func (_c *MockQuerier_GetRunContextByKey_Call) Return(_a0 NeosyncApiRuncontext, _a1 error) *MockQuerier_GetRunContextByKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetRunContextByKey_Call) RunAndReturn(run func(context.Context, DBTX, GetRunContextByKeyParams) (NeosyncApiRuncontext, error)) *MockQuerier_GetRunContextByKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetTeamAccountsByUserId provides a mock function with given fields: ctx, db, userid
func (_m *MockQuerier) GetTeamAccountsByUserId(ctx context.Context, db DBTX, userid pgtype.UUID) ([]NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, userid)

	if len(ret) == 0 {
		panic("no return value specified for GetTeamAccountsByUserId")
	}

	var r0 []NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiAccount, error)); ok {
		return rf(ctx, db, userid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiAccount); ok {
		r0 = rf(ctx, db, userid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, userid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetTeamAccountsByUserId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTeamAccountsByUserId'
type MockQuerier_GetTeamAccountsByUserId_Call struct {
	*mock.Call
}

// GetTeamAccountsByUserId is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - userid pgtype.UUID
func (_e *MockQuerier_Expecter) GetTeamAccountsByUserId(ctx interface{}, db interface{}, userid interface{}) *MockQuerier_GetTeamAccountsByUserId_Call {
	return &MockQuerier_GetTeamAccountsByUserId_Call{Call: _e.mock.On("GetTeamAccountsByUserId", ctx, db, userid)}
}

func (_c *MockQuerier_GetTeamAccountsByUserId_Call) Run(run func(ctx context.Context, db DBTX, userid pgtype.UUID)) *MockQuerier_GetTeamAccountsByUserId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetTeamAccountsByUserId_Call) Return(_a0 []NeosyncApiAccount, _a1 error) *MockQuerier_GetTeamAccountsByUserId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetTeamAccountsByUserId_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiAccount, error)) *MockQuerier_GetTeamAccountsByUserId_Call {
	_c.Call.Return(run)
	return _c
}

// GetTemporalConfigByAccount provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetTemporalConfigByAccount(ctx context.Context, db DBTX, id pgtype.UUID) (*pg_models.TemporalConfig, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTemporalConfigByAccount")
	}

	var r0 *pg_models.TemporalConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (*pg_models.TemporalConfig, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) *pg_models.TemporalConfig); ok {
		r0 = rf(ctx, db, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pg_models.TemporalConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetTemporalConfigByAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTemporalConfigByAccount'
type MockQuerier_GetTemporalConfigByAccount_Call struct {
	*mock.Call
}

// GetTemporalConfigByAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetTemporalConfigByAccount(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetTemporalConfigByAccount_Call {
	return &MockQuerier_GetTemporalConfigByAccount_Call{Call: _e.mock.On("GetTemporalConfigByAccount", ctx, db, id)}
}

func (_c *MockQuerier_GetTemporalConfigByAccount_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetTemporalConfigByAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetTemporalConfigByAccount_Call) Return(_a0 *pg_models.TemporalConfig, _a1 error) *MockQuerier_GetTemporalConfigByAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetTemporalConfigByAccount_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (*pg_models.TemporalConfig, error)) *MockQuerier_GetTemporalConfigByAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetTemporalConfigByUserAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) GetTemporalConfigByUserAccount(ctx context.Context, db DBTX, arg GetTemporalConfigByUserAccountParams) (*pg_models.TemporalConfig, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for GetTemporalConfigByUserAccount")
	}

	var r0 *pg_models.TemporalConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetTemporalConfigByUserAccountParams) (*pg_models.TemporalConfig, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, GetTemporalConfigByUserAccountParams) *pg_models.TemporalConfig); ok {
		r0 = rf(ctx, db, arg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pg_models.TemporalConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, GetTemporalConfigByUserAccountParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetTemporalConfigByUserAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTemporalConfigByUserAccount'
type MockQuerier_GetTemporalConfigByUserAccount_Call struct {
	*mock.Call
}

// GetTemporalConfigByUserAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg GetTemporalConfigByUserAccountParams
func (_e *MockQuerier_Expecter) GetTemporalConfigByUserAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_GetTemporalConfigByUserAccount_Call {
	return &MockQuerier_GetTemporalConfigByUserAccount_Call{Call: _e.mock.On("GetTemporalConfigByUserAccount", ctx, db, arg)}
}

func (_c *MockQuerier_GetTemporalConfigByUserAccount_Call) Run(run func(ctx context.Context, db DBTX, arg GetTemporalConfigByUserAccountParams)) *MockQuerier_GetTemporalConfigByUserAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(GetTemporalConfigByUserAccountParams))
	})
	return _c
}

func (_c *MockQuerier_GetTemporalConfigByUserAccount_Call) Return(_a0 *pg_models.TemporalConfig, _a1 error) *MockQuerier_GetTemporalConfigByUserAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetTemporalConfigByUserAccount_Call) RunAndReturn(run func(context.Context, DBTX, GetTemporalConfigByUserAccountParams) (*pg_models.TemporalConfig, error)) *MockQuerier_GetTemporalConfigByUserAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetUser(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiUser, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 NeosyncApiUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiUser, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiUser); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiUser)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type MockQuerier_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetUser(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetUser_Call {
	return &MockQuerier_GetUser_Call{Call: _e.mock.On("GetUser", ctx, db, id)}
}

func (_c *MockQuerier_GetUser_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetUser_Call) Return(_a0 NeosyncApiUser, _a1 error) *MockQuerier_GetUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetUser_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiUser, error)) *MockQuerier_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAssociationByProviderSub provides a mock function with given fields: ctx, db, providerSub
func (_m *MockQuerier) GetUserAssociationByProviderSub(ctx context.Context, db DBTX, providerSub string) (NeosyncApiUserIdentityProviderAssociation, error) {
	ret := _m.Called(ctx, db, providerSub)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAssociationByProviderSub")
	}

	var r0 NeosyncApiUserIdentityProviderAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) (NeosyncApiUserIdentityProviderAssociation, error)); ok {
		return rf(ctx, db, providerSub)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) NeosyncApiUserIdentityProviderAssociation); ok {
		r0 = rf(ctx, db, providerSub)
	} else {
		r0 = ret.Get(0).(NeosyncApiUserIdentityProviderAssociation)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, string) error); ok {
		r1 = rf(ctx, db, providerSub)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetUserAssociationByProviderSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAssociationByProviderSub'
type MockQuerier_GetUserAssociationByProviderSub_Call struct {
	*mock.Call
}

// GetUserAssociationByProviderSub is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - providerSub string
func (_e *MockQuerier_Expecter) GetUserAssociationByProviderSub(ctx interface{}, db interface{}, providerSub interface{}) *MockQuerier_GetUserAssociationByProviderSub_Call {
	return &MockQuerier_GetUserAssociationByProviderSub_Call{Call: _e.mock.On("GetUserAssociationByProviderSub", ctx, db, providerSub)}
}

func (_c *MockQuerier_GetUserAssociationByProviderSub_Call) Run(run func(ctx context.Context, db DBTX, providerSub string)) *MockQuerier_GetUserAssociationByProviderSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_GetUserAssociationByProviderSub_Call) Return(_a0 NeosyncApiUserIdentityProviderAssociation, _a1 error) *MockQuerier_GetUserAssociationByProviderSub_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetUserAssociationByProviderSub_Call) RunAndReturn(run func(context.Context, DBTX, string) (NeosyncApiUserIdentityProviderAssociation, error)) *MockQuerier_GetUserAssociationByProviderSub_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByProviderSub provides a mock function with given fields: ctx, db, providerSub
func (_m *MockQuerier) GetUserByProviderSub(ctx context.Context, db DBTX, providerSub string) (NeosyncApiUser, error) {
	ret := _m.Called(ctx, db, providerSub)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByProviderSub")
	}

	var r0 NeosyncApiUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) (NeosyncApiUser, error)); ok {
		return rf(ctx, db, providerSub)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, string) NeosyncApiUser); ok {
		r0 = rf(ctx, db, providerSub)
	} else {
		r0 = ret.Get(0).(NeosyncApiUser)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, string) error); ok {
		r1 = rf(ctx, db, providerSub)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetUserByProviderSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByProviderSub'
type MockQuerier_GetUserByProviderSub_Call struct {
	*mock.Call
}

// GetUserByProviderSub is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - providerSub string
func (_e *MockQuerier_Expecter) GetUserByProviderSub(ctx interface{}, db interface{}, providerSub interface{}) *MockQuerier_GetUserByProviderSub_Call {
	return &MockQuerier_GetUserByProviderSub_Call{Call: _e.mock.On("GetUserByProviderSub", ctx, db, providerSub)}
}

func (_c *MockQuerier_GetUserByProviderSub_Call) Run(run func(ctx context.Context, db DBTX, providerSub string)) *MockQuerier_GetUserByProviderSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(string))
	})
	return _c
}

func (_c *MockQuerier_GetUserByProviderSub_Call) Return(_a0 NeosyncApiUser, _a1 error) *MockQuerier_GetUserByProviderSub_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetUserByProviderSub_Call) RunAndReturn(run func(context.Context, DBTX, string) (NeosyncApiUser, error)) *MockQuerier_GetUserByProviderSub_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserDefinedTransformerById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) GetUserDefinedTransformerById(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiTransformer, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for GetUserDefinedTransformerById")
	}

	var r0 NeosyncApiTransformer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiTransformer, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiTransformer); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiTransformer)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetUserDefinedTransformerById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserDefinedTransformerById'
type MockQuerier_GetUserDefinedTransformerById_Call struct {
	*mock.Call
}

// GetUserDefinedTransformerById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) GetUserDefinedTransformerById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_GetUserDefinedTransformerById_Call {
	return &MockQuerier_GetUserDefinedTransformerById_Call{Call: _e.mock.On("GetUserDefinedTransformerById", ctx, db, id)}
}

func (_c *MockQuerier_GetUserDefinedTransformerById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_GetUserDefinedTransformerById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetUserDefinedTransformerById_Call) Return(_a0 NeosyncApiTransformer, _a1 error) *MockQuerier_GetUserDefinedTransformerById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetUserDefinedTransformerById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiTransformer, error)) *MockQuerier_GetUserDefinedTransformerById_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserDefinedTransformersByAccount provides a mock function with given fields: ctx, db, accountid
func (_m *MockQuerier) GetUserDefinedTransformersByAccount(ctx context.Context, db DBTX, accountid pgtype.UUID) ([]NeosyncApiTransformer, error) {
	ret := _m.Called(ctx, db, accountid)

	if len(ret) == 0 {
		panic("no return value specified for GetUserDefinedTransformersByAccount")
	}

	var r0 []NeosyncApiTransformer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiTransformer, error)); ok {
		return rf(ctx, db, accountid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiTransformer); ok {
		r0 = rf(ctx, db, accountid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiTransformer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, accountid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetUserDefinedTransformersByAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserDefinedTransformersByAccount'
type MockQuerier_GetUserDefinedTransformersByAccount_Call struct {
	*mock.Call
}

// GetUserDefinedTransformersByAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountid pgtype.UUID
func (_e *MockQuerier_Expecter) GetUserDefinedTransformersByAccount(ctx interface{}, db interface{}, accountid interface{}) *MockQuerier_GetUserDefinedTransformersByAccount_Call {
	return &MockQuerier_GetUserDefinedTransformersByAccount_Call{Call: _e.mock.On("GetUserDefinedTransformersByAccount", ctx, db, accountid)}
}

func (_c *MockQuerier_GetUserDefinedTransformersByAccount_Call) Run(run func(ctx context.Context, db DBTX, accountid pgtype.UUID)) *MockQuerier_GetUserDefinedTransformersByAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetUserDefinedTransformersByAccount_Call) Return(_a0 []NeosyncApiTransformer, _a1 error) *MockQuerier_GetUserDefinedTransformersByAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetUserDefinedTransformersByAccount_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiTransformer, error)) *MockQuerier_GetUserDefinedTransformersByAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserIdentitiesByTeamAccount provides a mock function with given fields: ctx, db, accountid
func (_m *MockQuerier) GetUserIdentitiesByTeamAccount(ctx context.Context, db DBTX, accountid pgtype.UUID) ([]NeosyncApiUserIdentityProviderAssociation, error) {
	ret := _m.Called(ctx, db, accountid)

	if len(ret) == 0 {
		panic("no return value specified for GetUserIdentitiesByTeamAccount")
	}

	var r0 []NeosyncApiUserIdentityProviderAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiUserIdentityProviderAssociation, error)); ok {
		return rf(ctx, db, accountid)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) []NeosyncApiUserIdentityProviderAssociation); ok {
		r0 = rf(ctx, db, accountid)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiUserIdentityProviderAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, accountid)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetUserIdentitiesByTeamAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserIdentitiesByTeamAccount'
type MockQuerier_GetUserIdentitiesByTeamAccount_Call struct {
	*mock.Call
}

// GetUserIdentitiesByTeamAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - accountid pgtype.UUID
func (_e *MockQuerier_Expecter) GetUserIdentitiesByTeamAccount(ctx interface{}, db interface{}, accountid interface{}) *MockQuerier_GetUserIdentitiesByTeamAccount_Call {
	return &MockQuerier_GetUserIdentitiesByTeamAccount_Call{Call: _e.mock.On("GetUserIdentitiesByTeamAccount", ctx, db, accountid)}
}

func (_c *MockQuerier_GetUserIdentitiesByTeamAccount_Call) Run(run func(ctx context.Context, db DBTX, accountid pgtype.UUID)) *MockQuerier_GetUserIdentitiesByTeamAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetUserIdentitiesByTeamAccount_Call) Return(_a0 []NeosyncApiUserIdentityProviderAssociation, _a1 error) *MockQuerier_GetUserIdentitiesByTeamAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetUserIdentitiesByTeamAccount_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) ([]NeosyncApiUserIdentityProviderAssociation, error)) *MockQuerier_GetUserIdentitiesByTeamAccount_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserIdentityAssociationsByUserIds provides a mock function with given fields: ctx, db, dollar_1
func (_m *MockQuerier) GetUserIdentityAssociationsByUserIds(ctx context.Context, db DBTX, dollar_1 []pgtype.UUID) ([]NeosyncApiUserIdentityProviderAssociation, error) {
	ret := _m.Called(ctx, db, dollar_1)

	if len(ret) == 0 {
		panic("no return value specified for GetUserIdentityAssociationsByUserIds")
	}

	var r0 []NeosyncApiUserIdentityProviderAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) ([]NeosyncApiUserIdentityProviderAssociation, error)); ok {
		return rf(ctx, db, dollar_1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) []NeosyncApiUserIdentityProviderAssociation); ok {
		r0 = rf(ctx, db, dollar_1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]NeosyncApiUserIdentityProviderAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, []pgtype.UUID) error); ok {
		r1 = rf(ctx, db, dollar_1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetUserIdentityAssociationsByUserIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserIdentityAssociationsByUserIds'
type MockQuerier_GetUserIdentityAssociationsByUserIds_Call struct {
	*mock.Call
}

// GetUserIdentityAssociationsByUserIds is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - dollar_1 []pgtype.UUID
func (_e *MockQuerier_Expecter) GetUserIdentityAssociationsByUserIds(ctx interface{}, db interface{}, dollar_1 interface{}) *MockQuerier_GetUserIdentityAssociationsByUserIds_Call {
	return &MockQuerier_GetUserIdentityAssociationsByUserIds_Call{Call: _e.mock.On("GetUserIdentityAssociationsByUserIds", ctx, db, dollar_1)}
}

func (_c *MockQuerier_GetUserIdentityAssociationsByUserIds_Call) Run(run func(ctx context.Context, db DBTX, dollar_1 []pgtype.UUID)) *MockQuerier_GetUserIdentityAssociationsByUserIds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].([]pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetUserIdentityAssociationsByUserIds_Call) Return(_a0 []NeosyncApiUserIdentityProviderAssociation, _a1 error) *MockQuerier_GetUserIdentityAssociationsByUserIds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetUserIdentityAssociationsByUserIds_Call) RunAndReturn(run func(context.Context, DBTX, []pgtype.UUID) ([]NeosyncApiUserIdentityProviderAssociation, error)) *MockQuerier_GetUserIdentityAssociationsByUserIds_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserIdentityByUserId provides a mock function with given fields: ctx, db, userID
func (_m *MockQuerier) GetUserIdentityByUserId(ctx context.Context, db DBTX, userID pgtype.UUID) (NeosyncApiUserIdentityProviderAssociation, error) {
	ret := _m.Called(ctx, db, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserIdentityByUserId")
	}

	var r0 NeosyncApiUserIdentityProviderAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiUserIdentityProviderAssociation, error)); ok {
		return rf(ctx, db, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiUserIdentityProviderAssociation); ok {
		r0 = rf(ctx, db, userID)
	} else {
		r0 = ret.Get(0).(NeosyncApiUserIdentityProviderAssociation)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_GetUserIdentityByUserId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserIdentityByUserId'
type MockQuerier_GetUserIdentityByUserId_Call struct {
	*mock.Call
}

// GetUserIdentityByUserId is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - userID pgtype.UUID
func (_e *MockQuerier_Expecter) GetUserIdentityByUserId(ctx interface{}, db interface{}, userID interface{}) *MockQuerier_GetUserIdentityByUserId_Call {
	return &MockQuerier_GetUserIdentityByUserId_Call{Call: _e.mock.On("GetUserIdentityByUserId", ctx, db, userID)}
}

func (_c *MockQuerier_GetUserIdentityByUserId_Call) Run(run func(ctx context.Context, db DBTX, userID pgtype.UUID)) *MockQuerier_GetUserIdentityByUserId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_GetUserIdentityByUserId_Call) Return(_a0 NeosyncApiUserIdentityProviderAssociation, _a1 error) *MockQuerier_GetUserIdentityByUserId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_GetUserIdentityByUserId_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiUserIdentityProviderAssociation, error)) *MockQuerier_GetUserIdentityByUserId_Call {
	_c.Call.Return(run)
	return _c
}

// IsConnectionInAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) IsConnectionInAccount(ctx context.Context, db DBTX, arg IsConnectionInAccountParams) (int64, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for IsConnectionInAccount")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsConnectionInAccountParams) (int64, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsConnectionInAccountParams) int64); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, IsConnectionInAccountParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_IsConnectionInAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsConnectionInAccount'
type MockQuerier_IsConnectionInAccount_Call struct {
	*mock.Call
}

// IsConnectionInAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg IsConnectionInAccountParams
func (_e *MockQuerier_Expecter) IsConnectionInAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_IsConnectionInAccount_Call {
	return &MockQuerier_IsConnectionInAccount_Call{Call: _e.mock.On("IsConnectionInAccount", ctx, db, arg)}
}

func (_c *MockQuerier_IsConnectionInAccount_Call) Run(run func(ctx context.Context, db DBTX, arg IsConnectionInAccountParams)) *MockQuerier_IsConnectionInAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(IsConnectionInAccountParams))
	})
	return _c
}

func (_c *MockQuerier_IsConnectionInAccount_Call) Return(_a0 int64, _a1 error) *MockQuerier_IsConnectionInAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_IsConnectionInAccount_Call) RunAndReturn(run func(context.Context, DBTX, IsConnectionInAccountParams) (int64, error)) *MockQuerier_IsConnectionInAccount_Call {
	_c.Call.Return(run)
	return _c
}

// IsConnectionNameAvailable provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) IsConnectionNameAvailable(ctx context.Context, db DBTX, arg IsConnectionNameAvailableParams) (int64, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for IsConnectionNameAvailable")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsConnectionNameAvailableParams) (int64, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsConnectionNameAvailableParams) int64); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, IsConnectionNameAvailableParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_IsConnectionNameAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsConnectionNameAvailable'
type MockQuerier_IsConnectionNameAvailable_Call struct {
	*mock.Call
}

// IsConnectionNameAvailable is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg IsConnectionNameAvailableParams
func (_e *MockQuerier_Expecter) IsConnectionNameAvailable(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_IsConnectionNameAvailable_Call {
	return &MockQuerier_IsConnectionNameAvailable_Call{Call: _e.mock.On("IsConnectionNameAvailable", ctx, db, arg)}
}

func (_c *MockQuerier_IsConnectionNameAvailable_Call) Run(run func(ctx context.Context, db DBTX, arg IsConnectionNameAvailableParams)) *MockQuerier_IsConnectionNameAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(IsConnectionNameAvailableParams))
	})
	return _c
}

func (_c *MockQuerier_IsConnectionNameAvailable_Call) Return(_a0 int64, _a1 error) *MockQuerier_IsConnectionNameAvailable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_IsConnectionNameAvailable_Call) RunAndReturn(run func(context.Context, DBTX, IsConnectionNameAvailableParams) (int64, error)) *MockQuerier_IsConnectionNameAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// IsJobHookNameAvailable provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) IsJobHookNameAvailable(ctx context.Context, db DBTX, arg IsJobHookNameAvailableParams) (bool, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for IsJobHookNameAvailable")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsJobHookNameAvailableParams) (bool, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsJobHookNameAvailableParams) bool); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, IsJobHookNameAvailableParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_IsJobHookNameAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsJobHookNameAvailable'
type MockQuerier_IsJobHookNameAvailable_Call struct {
	*mock.Call
}

// IsJobHookNameAvailable is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg IsJobHookNameAvailableParams
func (_e *MockQuerier_Expecter) IsJobHookNameAvailable(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_IsJobHookNameAvailable_Call {
	return &MockQuerier_IsJobHookNameAvailable_Call{Call: _e.mock.On("IsJobHookNameAvailable", ctx, db, arg)}
}

func (_c *MockQuerier_IsJobHookNameAvailable_Call) Run(run func(ctx context.Context, db DBTX, arg IsJobHookNameAvailableParams)) *MockQuerier_IsJobHookNameAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(IsJobHookNameAvailableParams))
	})
	return _c
}

func (_c *MockQuerier_IsJobHookNameAvailable_Call) Return(_a0 bool, _a1 error) *MockQuerier_IsJobHookNameAvailable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_IsJobHookNameAvailable_Call) RunAndReturn(run func(context.Context, DBTX, IsJobHookNameAvailableParams) (bool, error)) *MockQuerier_IsJobHookNameAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// IsJobNameAvailable provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) IsJobNameAvailable(ctx context.Context, db DBTX, arg IsJobNameAvailableParams) (int64, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for IsJobNameAvailable")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsJobNameAvailableParams) (int64, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsJobNameAvailableParams) int64); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, IsJobNameAvailableParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_IsJobNameAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsJobNameAvailable'
type MockQuerier_IsJobNameAvailable_Call struct {
	*mock.Call
}

// IsJobNameAvailable is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg IsJobNameAvailableParams
func (_e *MockQuerier_Expecter) IsJobNameAvailable(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_IsJobNameAvailable_Call {
	return &MockQuerier_IsJobNameAvailable_Call{Call: _e.mock.On("IsJobNameAvailable", ctx, db, arg)}
}

func (_c *MockQuerier_IsJobNameAvailable_Call) Run(run func(ctx context.Context, db DBTX, arg IsJobNameAvailableParams)) *MockQuerier_IsJobNameAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(IsJobNameAvailableParams))
	})
	return _c
}

func (_c *MockQuerier_IsJobNameAvailable_Call) Return(_a0 int64, _a1 error) *MockQuerier_IsJobNameAvailable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_IsJobNameAvailable_Call) RunAndReturn(run func(context.Context, DBTX, IsJobNameAvailableParams) (int64, error)) *MockQuerier_IsJobNameAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// IsTransformerNameAvailable provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) IsTransformerNameAvailable(ctx context.Context, db DBTX, arg IsTransformerNameAvailableParams) (int64, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for IsTransformerNameAvailable")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsTransformerNameAvailableParams) (int64, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsTransformerNameAvailableParams) int64); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, IsTransformerNameAvailableParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_IsTransformerNameAvailable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsTransformerNameAvailable'
type MockQuerier_IsTransformerNameAvailable_Call struct {
	*mock.Call
}

// IsTransformerNameAvailable is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg IsTransformerNameAvailableParams
func (_e *MockQuerier_Expecter) IsTransformerNameAvailable(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_IsTransformerNameAvailable_Call {
	return &MockQuerier_IsTransformerNameAvailable_Call{Call: _e.mock.On("IsTransformerNameAvailable", ctx, db, arg)}
}

func (_c *MockQuerier_IsTransformerNameAvailable_Call) Run(run func(ctx context.Context, db DBTX, arg IsTransformerNameAvailableParams)) *MockQuerier_IsTransformerNameAvailable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(IsTransformerNameAvailableParams))
	})
	return _c
}

func (_c *MockQuerier_IsTransformerNameAvailable_Call) Return(_a0 int64, _a1 error) *MockQuerier_IsTransformerNameAvailable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_IsTransformerNameAvailable_Call) RunAndReturn(run func(context.Context, DBTX, IsTransformerNameAvailableParams) (int64, error)) *MockQuerier_IsTransformerNameAvailable_Call {
	_c.Call.Return(run)
	return _c
}

// IsUserInAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) IsUserInAccount(ctx context.Context, db DBTX, arg IsUserInAccountParams) (int64, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for IsUserInAccount")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsUserInAccountParams) (int64, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsUserInAccountParams) int64); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, IsUserInAccountParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_IsUserInAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsUserInAccount'
type MockQuerier_IsUserInAccount_Call struct {
	*mock.Call
}

// IsUserInAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg IsUserInAccountParams
func (_e *MockQuerier_Expecter) IsUserInAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_IsUserInAccount_Call {
	return &MockQuerier_IsUserInAccount_Call{Call: _e.mock.On("IsUserInAccount", ctx, db, arg)}
}

func (_c *MockQuerier_IsUserInAccount_Call) Run(run func(ctx context.Context, db DBTX, arg IsUserInAccountParams)) *MockQuerier_IsUserInAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(IsUserInAccountParams))
	})
	return _c
}

func (_c *MockQuerier_IsUserInAccount_Call) Return(_a0 int64, _a1 error) *MockQuerier_IsUserInAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_IsUserInAccount_Call) RunAndReturn(run func(context.Context, DBTX, IsUserInAccountParams) (int64, error)) *MockQuerier_IsUserInAccount_Call {
	_c.Call.Return(run)
	return _c
}

// IsUserInAccountApiKey provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) IsUserInAccountApiKey(ctx context.Context, db DBTX, arg IsUserInAccountApiKeyParams) (int64, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for IsUserInAccountApiKey")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsUserInAccountApiKeyParams) (int64, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, IsUserInAccountApiKeyParams) int64); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, IsUserInAccountApiKeyParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_IsUserInAccountApiKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsUserInAccountApiKey'
type MockQuerier_IsUserInAccountApiKey_Call struct {
	*mock.Call
}

// IsUserInAccountApiKey is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg IsUserInAccountApiKeyParams
func (_e *MockQuerier_Expecter) IsUserInAccountApiKey(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_IsUserInAccountApiKey_Call {
	return &MockQuerier_IsUserInAccountApiKey_Call{Call: _e.mock.On("IsUserInAccountApiKey", ctx, db, arg)}
}

func (_c *MockQuerier_IsUserInAccountApiKey_Call) Run(run func(ctx context.Context, db DBTX, arg IsUserInAccountApiKeyParams)) *MockQuerier_IsUserInAccountApiKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(IsUserInAccountApiKeyParams))
	})
	return _c
}

func (_c *MockQuerier_IsUserInAccountApiKey_Call) Return(_a0 int64, _a1 error) *MockQuerier_IsUserInAccountApiKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_IsUserInAccountApiKey_Call) RunAndReturn(run func(context.Context, DBTX, IsUserInAccountApiKeyParams) (int64, error)) *MockQuerier_IsUserInAccountApiKey_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveAccountApiKey provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) RemoveAccountApiKey(ctx context.Context, db DBTX, id pgtype.UUID) error {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAccountApiKey")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveAccountApiKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveAccountApiKey'
type MockQuerier_RemoveAccountApiKey_Call struct {
	*mock.Call
}

// RemoveAccountApiKey is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) RemoveAccountApiKey(ctx interface{}, db interface{}, id interface{}) *MockQuerier_RemoveAccountApiKey_Call {
	return &MockQuerier_RemoveAccountApiKey_Call{Call: _e.mock.On("RemoveAccountApiKey", ctx, db, id)}
}

func (_c *MockQuerier_RemoveAccountApiKey_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_RemoveAccountApiKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_RemoveAccountApiKey_Call) Return(_a0 error) *MockQuerier_RemoveAccountApiKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveAccountApiKey_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) error) *MockQuerier_RemoveAccountApiKey_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveAccountInvite provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) RemoveAccountInvite(ctx context.Context, db DBTX, id pgtype.UUID) error {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAccountInvite")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveAccountInvite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveAccountInvite'
type MockQuerier_RemoveAccountInvite_Call struct {
	*mock.Call
}

// RemoveAccountInvite is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) RemoveAccountInvite(ctx interface{}, db interface{}, id interface{}) *MockQuerier_RemoveAccountInvite_Call {
	return &MockQuerier_RemoveAccountInvite_Call{Call: _e.mock.On("RemoveAccountInvite", ctx, db, id)}
}

func (_c *MockQuerier_RemoveAccountInvite_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_RemoveAccountInvite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_RemoveAccountInvite_Call) Return(_a0 error) *MockQuerier_RemoveAccountInvite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveAccountInvite_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) error) *MockQuerier_RemoveAccountInvite_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveAccountUser provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) RemoveAccountUser(ctx context.Context, db DBTX, arg RemoveAccountUserParams) error {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAccountUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, RemoveAccountUserParams) error); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveAccountUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveAccountUser'
type MockQuerier_RemoveAccountUser_Call struct {
	*mock.Call
}

// RemoveAccountUser is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg RemoveAccountUserParams
func (_e *MockQuerier_Expecter) RemoveAccountUser(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_RemoveAccountUser_Call {
	return &MockQuerier_RemoveAccountUser_Call{Call: _e.mock.On("RemoveAccountUser", ctx, db, arg)}
}

func (_c *MockQuerier_RemoveAccountUser_Call) Run(run func(ctx context.Context, db DBTX, arg RemoveAccountUserParams)) *MockQuerier_RemoveAccountUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(RemoveAccountUserParams))
	})
	return _c
}

func (_c *MockQuerier_RemoveAccountUser_Call) Return(_a0 error) *MockQuerier_RemoveAccountUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveAccountUser_Call) RunAndReturn(run func(context.Context, DBTX, RemoveAccountUserParams) error) *MockQuerier_RemoveAccountUser_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveConnectionById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) RemoveConnectionById(ctx context.Context, db DBTX, id pgtype.UUID) error {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveConnectionById")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveConnectionById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveConnectionById'
type MockQuerier_RemoveConnectionById_Call struct {
	*mock.Call
}

// RemoveConnectionById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) RemoveConnectionById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_RemoveConnectionById_Call {
	return &MockQuerier_RemoveConnectionById_Call{Call: _e.mock.On("RemoveConnectionById", ctx, db, id)}
}

func (_c *MockQuerier_RemoveConnectionById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_RemoveConnectionById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_RemoveConnectionById_Call) Return(_a0 error) *MockQuerier_RemoveConnectionById_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveConnectionById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) error) *MockQuerier_RemoveConnectionById_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveConnectionByNameAndAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) RemoveConnectionByNameAndAccount(ctx context.Context, db DBTX, arg RemoveConnectionByNameAndAccountParams) error {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for RemoveConnectionByNameAndAccount")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, RemoveConnectionByNameAndAccountParams) error); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveConnectionByNameAndAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveConnectionByNameAndAccount'
type MockQuerier_RemoveConnectionByNameAndAccount_Call struct {
	*mock.Call
}

// RemoveConnectionByNameAndAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg RemoveConnectionByNameAndAccountParams
func (_e *MockQuerier_Expecter) RemoveConnectionByNameAndAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_RemoveConnectionByNameAndAccount_Call {
	return &MockQuerier_RemoveConnectionByNameAndAccount_Call{Call: _e.mock.On("RemoveConnectionByNameAndAccount", ctx, db, arg)}
}

func (_c *MockQuerier_RemoveConnectionByNameAndAccount_Call) Run(run func(ctx context.Context, db DBTX, arg RemoveConnectionByNameAndAccountParams)) *MockQuerier_RemoveConnectionByNameAndAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(RemoveConnectionByNameAndAccountParams))
	})
	return _c
}

func (_c *MockQuerier_RemoveConnectionByNameAndAccount_Call) Return(_a0 error) *MockQuerier_RemoveConnectionByNameAndAccount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveConnectionByNameAndAccount_Call) RunAndReturn(run func(context.Context, DBTX, RemoveConnectionByNameAndAccountParams) error) *MockQuerier_RemoveConnectionByNameAndAccount_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveJobById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) RemoveJobById(ctx context.Context, db DBTX, id pgtype.UUID) error {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveJobById")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveJobById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveJobById'
type MockQuerier_RemoveJobById_Call struct {
	*mock.Call
}

// RemoveJobById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) RemoveJobById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_RemoveJobById_Call {
	return &MockQuerier_RemoveJobById_Call{Call: _e.mock.On("RemoveJobById", ctx, db, id)}
}

func (_c *MockQuerier_RemoveJobById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_RemoveJobById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_RemoveJobById_Call) Return(_a0 error) *MockQuerier_RemoveJobById_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveJobById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) error) *MockQuerier_RemoveJobById_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveJobConnectionDestination provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) RemoveJobConnectionDestination(ctx context.Context, db DBTX, id pgtype.UUID) error {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveJobConnectionDestination")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveJobConnectionDestination_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveJobConnectionDestination'
type MockQuerier_RemoveJobConnectionDestination_Call struct {
	*mock.Call
}

// RemoveJobConnectionDestination is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) RemoveJobConnectionDestination(ctx interface{}, db interface{}, id interface{}) *MockQuerier_RemoveJobConnectionDestination_Call {
	return &MockQuerier_RemoveJobConnectionDestination_Call{Call: _e.mock.On("RemoveJobConnectionDestination", ctx, db, id)}
}

func (_c *MockQuerier_RemoveJobConnectionDestination_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_RemoveJobConnectionDestination_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_RemoveJobConnectionDestination_Call) Return(_a0 error) *MockQuerier_RemoveJobConnectionDestination_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveJobConnectionDestination_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) error) *MockQuerier_RemoveJobConnectionDestination_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveJobConnectionDestinations provides a mock function with given fields: ctx, db, jobids
func (_m *MockQuerier) RemoveJobConnectionDestinations(ctx context.Context, db DBTX, jobids []pgtype.UUID) error {
	ret := _m.Called(ctx, db, jobids)

	if len(ret) == 0 {
		panic("no return value specified for RemoveJobConnectionDestinations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, []pgtype.UUID) error); ok {
		r0 = rf(ctx, db, jobids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveJobConnectionDestinations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveJobConnectionDestinations'
type MockQuerier_RemoveJobConnectionDestinations_Call struct {
	*mock.Call
}

// RemoveJobConnectionDestinations is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - jobids []pgtype.UUID
func (_e *MockQuerier_Expecter) RemoveJobConnectionDestinations(ctx interface{}, db interface{}, jobids interface{}) *MockQuerier_RemoveJobConnectionDestinations_Call {
	return &MockQuerier_RemoveJobConnectionDestinations_Call{Call: _e.mock.On("RemoveJobConnectionDestinations", ctx, db, jobids)}
}

func (_c *MockQuerier_RemoveJobConnectionDestinations_Call) Run(run func(ctx context.Context, db DBTX, jobids []pgtype.UUID)) *MockQuerier_RemoveJobConnectionDestinations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].([]pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_RemoveJobConnectionDestinations_Call) Return(_a0 error) *MockQuerier_RemoveJobConnectionDestinations_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveJobConnectionDestinations_Call) RunAndReturn(run func(context.Context, DBTX, []pgtype.UUID) error) *MockQuerier_RemoveJobConnectionDestinations_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveJobHookById provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) RemoveJobHookById(ctx context.Context, db DBTX, id pgtype.UUID) error {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for RemoveJobHookById")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_RemoveJobHookById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveJobHookById'
type MockQuerier_RemoveJobHookById_Call struct {
	*mock.Call
}

// RemoveJobHookById is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) RemoveJobHookById(ctx interface{}, db interface{}, id interface{}) *MockQuerier_RemoveJobHookById_Call {
	return &MockQuerier_RemoveJobHookById_Call{Call: _e.mock.On("RemoveJobHookById", ctx, db, id)}
}

func (_c *MockQuerier_RemoveJobHookById_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_RemoveJobHookById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_RemoveJobHookById_Call) Return(_a0 error) *MockQuerier_RemoveJobHookById_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_RemoveJobHookById_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) error) *MockQuerier_RemoveJobHookById_Call {
	_c.Call.Return(run)
	return _c
}

// SetAccountCreatedAt provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) SetAccountCreatedAt(ctx context.Context, db DBTX, arg SetAccountCreatedAtParams) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for SetAccountCreatedAt")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetAccountCreatedAtParams) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetAccountCreatedAtParams) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, SetAccountCreatedAtParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_SetAccountCreatedAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAccountCreatedAt'
type MockQuerier_SetAccountCreatedAt_Call struct {
	*mock.Call
}

// SetAccountCreatedAt is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg SetAccountCreatedAtParams
func (_e *MockQuerier_Expecter) SetAccountCreatedAt(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_SetAccountCreatedAt_Call {
	return &MockQuerier_SetAccountCreatedAt_Call{Call: _e.mock.On("SetAccountCreatedAt", ctx, db, arg)}
}

func (_c *MockQuerier_SetAccountCreatedAt_Call) Run(run func(ctx context.Context, db DBTX, arg SetAccountCreatedAtParams)) *MockQuerier_SetAccountCreatedAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(SetAccountCreatedAtParams))
	})
	return _c
}

func (_c *MockQuerier_SetAccountCreatedAt_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_SetAccountCreatedAt_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_SetAccountCreatedAt_Call) RunAndReturn(run func(context.Context, DBTX, SetAccountCreatedAtParams) (NeosyncApiAccount, error)) *MockQuerier_SetAccountCreatedAt_Call {
	_c.Call.Return(run)
	return _c
}

// SetAnonymousUser provides a mock function with given fields: ctx, db
func (_m *MockQuerier) SetAnonymousUser(ctx context.Context, db DBTX) (NeosyncApiUser, error) {
	ret := _m.Called(ctx, db)

	if len(ret) == 0 {
		panic("no return value specified for SetAnonymousUser")
	}

	var r0 NeosyncApiUser
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) (NeosyncApiUser, error)); ok {
		return rf(ctx, db)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX) NeosyncApiUser); ok {
		r0 = rf(ctx, db)
	} else {
		r0 = ret.Get(0).(NeosyncApiUser)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX) error); ok {
		r1 = rf(ctx, db)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_SetAnonymousUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetAnonymousUser'
type MockQuerier_SetAnonymousUser_Call struct {
	*mock.Call
}

// SetAnonymousUser is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
func (_e *MockQuerier_Expecter) SetAnonymousUser(ctx interface{}, db interface{}) *MockQuerier_SetAnonymousUser_Call {
	return &MockQuerier_SetAnonymousUser_Call{Call: _e.mock.On("SetAnonymousUser", ctx, db)}
}

func (_c *MockQuerier_SetAnonymousUser_Call) Run(run func(ctx context.Context, db DBTX)) *MockQuerier_SetAnonymousUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX))
	})
	return _c
}

func (_c *MockQuerier_SetAnonymousUser_Call) Return(_a0 NeosyncApiUser, _a1 error) *MockQuerier_SetAnonymousUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_SetAnonymousUser_Call) RunAndReturn(run func(context.Context, DBTX) (NeosyncApiUser, error)) *MockQuerier_SetAnonymousUser_Call {
	_c.Call.Return(run)
	return _c
}

// SetJobHookEnabled provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) SetJobHookEnabled(ctx context.Context, db DBTX, arg SetJobHookEnabledParams) (NeosyncApiJobHook, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for SetJobHookEnabled")
	}

	var r0 NeosyncApiJobHook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetJobHookEnabledParams) (NeosyncApiJobHook, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetJobHookEnabledParams) NeosyncApiJobHook); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJobHook)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, SetJobHookEnabledParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_SetJobHookEnabled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetJobHookEnabled'
type MockQuerier_SetJobHookEnabled_Call struct {
	*mock.Call
}

// SetJobHookEnabled is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg SetJobHookEnabledParams
func (_e *MockQuerier_Expecter) SetJobHookEnabled(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_SetJobHookEnabled_Call {
	return &MockQuerier_SetJobHookEnabled_Call{Call: _e.mock.On("SetJobHookEnabled", ctx, db, arg)}
}

func (_c *MockQuerier_SetJobHookEnabled_Call) Run(run func(ctx context.Context, db DBTX, arg SetJobHookEnabledParams)) *MockQuerier_SetJobHookEnabled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(SetJobHookEnabledParams))
	})
	return _c
}

func (_c *MockQuerier_SetJobHookEnabled_Call) Return(_a0 NeosyncApiJobHook, _a1 error) *MockQuerier_SetJobHookEnabled_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_SetJobHookEnabled_Call) RunAndReturn(run func(context.Context, DBTX, SetJobHookEnabledParams) (NeosyncApiJobHook, error)) *MockQuerier_SetJobHookEnabled_Call {
	_c.Call.Return(run)
	return _c
}

// SetJobSyncOptions provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) SetJobSyncOptions(ctx context.Context, db DBTX, arg SetJobSyncOptionsParams) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for SetJobSyncOptions")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetJobSyncOptionsParams) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetJobSyncOptionsParams) NeosyncApiJob); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, SetJobSyncOptionsParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_SetJobSyncOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetJobSyncOptions'
type MockQuerier_SetJobSyncOptions_Call struct {
	*mock.Call
}

// SetJobSyncOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg SetJobSyncOptionsParams
func (_e *MockQuerier_Expecter) SetJobSyncOptions(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_SetJobSyncOptions_Call {
	return &MockQuerier_SetJobSyncOptions_Call{Call: _e.mock.On("SetJobSyncOptions", ctx, db, arg)}
}

func (_c *MockQuerier_SetJobSyncOptions_Call) Run(run func(ctx context.Context, db DBTX, arg SetJobSyncOptionsParams)) *MockQuerier_SetJobSyncOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(SetJobSyncOptionsParams))
	})
	return _c
}

func (_c *MockQuerier_SetJobSyncOptions_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_SetJobSyncOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_SetJobSyncOptions_Call) RunAndReturn(run func(context.Context, DBTX, SetJobSyncOptionsParams) (NeosyncApiJob, error)) *MockQuerier_SetJobSyncOptions_Call {
	_c.Call.Return(run)
	return _c
}

// SetJobWorkflowOptions provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) SetJobWorkflowOptions(ctx context.Context, db DBTX, arg SetJobWorkflowOptionsParams) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for SetJobWorkflowOptions")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetJobWorkflowOptionsParams) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetJobWorkflowOptionsParams) NeosyncApiJob); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, SetJobWorkflowOptionsParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_SetJobWorkflowOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetJobWorkflowOptions'
type MockQuerier_SetJobWorkflowOptions_Call struct {
	*mock.Call
}

// SetJobWorkflowOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg SetJobWorkflowOptionsParams
func (_e *MockQuerier_Expecter) SetJobWorkflowOptions(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_SetJobWorkflowOptions_Call {
	return &MockQuerier_SetJobWorkflowOptions_Call{Call: _e.mock.On("SetJobWorkflowOptions", ctx, db, arg)}
}

func (_c *MockQuerier_SetJobWorkflowOptions_Call) Run(run func(ctx context.Context, db DBTX, arg SetJobWorkflowOptionsParams)) *MockQuerier_SetJobWorkflowOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(SetJobWorkflowOptionsParams))
	})
	return _c
}

func (_c *MockQuerier_SetJobWorkflowOptions_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_SetJobWorkflowOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_SetJobWorkflowOptions_Call) RunAndReturn(run func(context.Context, DBTX, SetJobWorkflowOptionsParams) (NeosyncApiJob, error)) *MockQuerier_SetJobWorkflowOptions_Call {
	_c.Call.Return(run)
	return _c
}

// SetNewAccountStripeCustomerId provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) SetNewAccountStripeCustomerId(ctx context.Context, db DBTX, arg SetNewAccountStripeCustomerIdParams) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for SetNewAccountStripeCustomerId")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetNewAccountStripeCustomerIdParams) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetNewAccountStripeCustomerIdParams) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, SetNewAccountStripeCustomerIdParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_SetNewAccountStripeCustomerId_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNewAccountStripeCustomerId'
type MockQuerier_SetNewAccountStripeCustomerId_Call struct {
	*mock.Call
}

// SetNewAccountStripeCustomerId is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg SetNewAccountStripeCustomerIdParams
func (_e *MockQuerier_Expecter) SetNewAccountStripeCustomerId(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_SetNewAccountStripeCustomerId_Call {
	return &MockQuerier_SetNewAccountStripeCustomerId_Call{Call: _e.mock.On("SetNewAccountStripeCustomerId", ctx, db, arg)}
}

func (_c *MockQuerier_SetNewAccountStripeCustomerId_Call) Run(run func(ctx context.Context, db DBTX, arg SetNewAccountStripeCustomerIdParams)) *MockQuerier_SetNewAccountStripeCustomerId_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(SetNewAccountStripeCustomerIdParams))
	})
	return _c
}

func (_c *MockQuerier_SetNewAccountStripeCustomerId_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_SetNewAccountStripeCustomerId_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_SetNewAccountStripeCustomerId_Call) RunAndReturn(run func(context.Context, DBTX, SetNewAccountStripeCustomerIdParams) (NeosyncApiAccount, error)) *MockQuerier_SetNewAccountStripeCustomerId_Call {
	_c.Call.Return(run)
	return _c
}

// SetRunContext provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) SetRunContext(ctx context.Context, db DBTX, arg SetRunContextParams) error {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for SetRunContext")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, SetRunContextParams) error); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQuerier_SetRunContext_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRunContext'
type MockQuerier_SetRunContext_Call struct {
	*mock.Call
}

// SetRunContext is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg SetRunContextParams
func (_e *MockQuerier_Expecter) SetRunContext(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_SetRunContext_Call {
	return &MockQuerier_SetRunContext_Call{Call: _e.mock.On("SetRunContext", ctx, db, arg)}
}

func (_c *MockQuerier_SetRunContext_Call) Run(run func(ctx context.Context, db DBTX, arg SetRunContextParams)) *MockQuerier_SetRunContext_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(SetRunContextParams))
	})
	return _c
}

func (_c *MockQuerier_SetRunContext_Call) Return(_a0 error) *MockQuerier_SetRunContext_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQuerier_SetRunContext_Call) RunAndReturn(run func(context.Context, DBTX, SetRunContextParams) error) *MockQuerier_SetRunContext_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAccountApiKeyValue provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateAccountApiKeyValue(ctx context.Context, db DBTX, arg UpdateAccountApiKeyValueParams) (NeosyncApiAccountApiKey, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccountApiKeyValue")
	}

	var r0 NeosyncApiAccountApiKey
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateAccountApiKeyValueParams) (NeosyncApiAccountApiKey, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateAccountApiKeyValueParams) NeosyncApiAccountApiKey); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountApiKey)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateAccountApiKeyValueParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateAccountApiKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAccountApiKeyValue'
type MockQuerier_UpdateAccountApiKeyValue_Call struct {
	*mock.Call
}

// UpdateAccountApiKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateAccountApiKeyValueParams
func (_e *MockQuerier_Expecter) UpdateAccountApiKeyValue(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateAccountApiKeyValue_Call {
	return &MockQuerier_UpdateAccountApiKeyValue_Call{Call: _e.mock.On("UpdateAccountApiKeyValue", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateAccountApiKeyValue_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateAccountApiKeyValueParams)) *MockQuerier_UpdateAccountApiKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateAccountApiKeyValueParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateAccountApiKeyValue_Call) Return(_a0 NeosyncApiAccountApiKey, _a1 error) *MockQuerier_UpdateAccountApiKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateAccountApiKeyValue_Call) RunAndReturn(run func(context.Context, DBTX, UpdateAccountApiKeyValueParams) (NeosyncApiAccountApiKey, error)) *MockQuerier_UpdateAccountApiKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAccountInviteToAccepted provides a mock function with given fields: ctx, db, id
func (_m *MockQuerier) UpdateAccountInviteToAccepted(ctx context.Context, db DBTX, id pgtype.UUID) (NeosyncApiAccountInvite, error) {
	ret := _m.Called(ctx, db, id)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccountInviteToAccepted")
	}

	var r0 NeosyncApiAccountInvite
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccountInvite, error)); ok {
		return rf(ctx, db, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, pgtype.UUID) NeosyncApiAccountInvite); ok {
		r0 = rf(ctx, db, id)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountInvite)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, pgtype.UUID) error); ok {
		r1 = rf(ctx, db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateAccountInviteToAccepted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAccountInviteToAccepted'
type MockQuerier_UpdateAccountInviteToAccepted_Call struct {
	*mock.Call
}

// UpdateAccountInviteToAccepted is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - id pgtype.UUID
func (_e *MockQuerier_Expecter) UpdateAccountInviteToAccepted(ctx interface{}, db interface{}, id interface{}) *MockQuerier_UpdateAccountInviteToAccepted_Call {
	return &MockQuerier_UpdateAccountInviteToAccepted_Call{Call: _e.mock.On("UpdateAccountInviteToAccepted", ctx, db, id)}
}

func (_c *MockQuerier_UpdateAccountInviteToAccepted_Call) Run(run func(ctx context.Context, db DBTX, id pgtype.UUID)) *MockQuerier_UpdateAccountInviteToAccepted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(pgtype.UUID))
	})
	return _c
}

func (_c *MockQuerier_UpdateAccountInviteToAccepted_Call) Return(_a0 NeosyncApiAccountInvite, _a1 error) *MockQuerier_UpdateAccountInviteToAccepted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateAccountInviteToAccepted_Call) RunAndReturn(run func(context.Context, DBTX, pgtype.UUID) (NeosyncApiAccountInvite, error)) *MockQuerier_UpdateAccountInviteToAccepted_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateAccountOnboardingConfig provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateAccountOnboardingConfig(ctx context.Context, db DBTX, arg UpdateAccountOnboardingConfigParams) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAccountOnboardingConfig")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateAccountOnboardingConfigParams) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateAccountOnboardingConfigParams) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateAccountOnboardingConfigParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateAccountOnboardingConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateAccountOnboardingConfig'
type MockQuerier_UpdateAccountOnboardingConfig_Call struct {
	*mock.Call
}

// UpdateAccountOnboardingConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateAccountOnboardingConfigParams
func (_e *MockQuerier_Expecter) UpdateAccountOnboardingConfig(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateAccountOnboardingConfig_Call {
	return &MockQuerier_UpdateAccountOnboardingConfig_Call{Call: _e.mock.On("UpdateAccountOnboardingConfig", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateAccountOnboardingConfig_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateAccountOnboardingConfigParams)) *MockQuerier_UpdateAccountOnboardingConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateAccountOnboardingConfigParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateAccountOnboardingConfig_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_UpdateAccountOnboardingConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateAccountOnboardingConfig_Call) RunAndReturn(run func(context.Context, DBTX, UpdateAccountOnboardingConfigParams) (NeosyncApiAccount, error)) *MockQuerier_UpdateAccountOnboardingConfig_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateActiveAccountInvitesToExpired provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateActiveAccountInvitesToExpired(ctx context.Context, db DBTX, arg UpdateActiveAccountInvitesToExpiredParams) (NeosyncApiAccountInvite, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateActiveAccountInvitesToExpired")
	}

	var r0 NeosyncApiAccountInvite
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateActiveAccountInvitesToExpiredParams) (NeosyncApiAccountInvite, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateActiveAccountInvitesToExpiredParams) NeosyncApiAccountInvite); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccountInvite)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateActiveAccountInvitesToExpiredParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateActiveAccountInvitesToExpired_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateActiveAccountInvitesToExpired'
type MockQuerier_UpdateActiveAccountInvitesToExpired_Call struct {
	*mock.Call
}

// UpdateActiveAccountInvitesToExpired is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateActiveAccountInvitesToExpiredParams
func (_e *MockQuerier_Expecter) UpdateActiveAccountInvitesToExpired(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateActiveAccountInvitesToExpired_Call {
	return &MockQuerier_UpdateActiveAccountInvitesToExpired_Call{Call: _e.mock.On("UpdateActiveAccountInvitesToExpired", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateActiveAccountInvitesToExpired_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateActiveAccountInvitesToExpiredParams)) *MockQuerier_UpdateActiveAccountInvitesToExpired_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateActiveAccountInvitesToExpiredParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateActiveAccountInvitesToExpired_Call) Return(_a0 NeosyncApiAccountInvite, _a1 error) *MockQuerier_UpdateActiveAccountInvitesToExpired_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateActiveAccountInvitesToExpired_Call) RunAndReturn(run func(context.Context, DBTX, UpdateActiveAccountInvitesToExpiredParams) (NeosyncApiAccountInvite, error)) *MockQuerier_UpdateActiveAccountInvitesToExpired_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConnection provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateConnection(ctx context.Context, db DBTX, arg UpdateConnectionParams) (NeosyncApiConnection, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConnection")
	}

	var r0 NeosyncApiConnection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateConnectionParams) (NeosyncApiConnection, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateConnectionParams) NeosyncApiConnection); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiConnection)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateConnectionParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConnection'
type MockQuerier_UpdateConnection_Call struct {
	*mock.Call
}

// UpdateConnection is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateConnectionParams
func (_e *MockQuerier_Expecter) UpdateConnection(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateConnection_Call {
	return &MockQuerier_UpdateConnection_Call{Call: _e.mock.On("UpdateConnection", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateConnection_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateConnectionParams)) *MockQuerier_UpdateConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateConnectionParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateConnection_Call) Return(_a0 NeosyncApiConnection, _a1 error) *MockQuerier_UpdateConnection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateConnection_Call) RunAndReturn(run func(context.Context, DBTX, UpdateConnectionParams) (NeosyncApiConnection, error)) *MockQuerier_UpdateConnection_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobConnectionDestination provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateJobConnectionDestination(ctx context.Context, db DBTX, arg UpdateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobConnectionDestination")
	}

	var r0 NeosyncApiJobDestinationConnectionAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobConnectionDestinationParams) NeosyncApiJobDestinationConnectionAssociation); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJobDestinationConnectionAssociation)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateJobConnectionDestinationParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateJobConnectionDestination_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobConnectionDestination'
type MockQuerier_UpdateJobConnectionDestination_Call struct {
	*mock.Call
}

// UpdateJobConnectionDestination is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateJobConnectionDestinationParams
func (_e *MockQuerier_Expecter) UpdateJobConnectionDestination(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateJobConnectionDestination_Call {
	return &MockQuerier_UpdateJobConnectionDestination_Call{Call: _e.mock.On("UpdateJobConnectionDestination", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateJobConnectionDestination_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateJobConnectionDestinationParams)) *MockQuerier_UpdateJobConnectionDestination_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateJobConnectionDestinationParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateJobConnectionDestination_Call) Return(_a0 NeosyncApiJobDestinationConnectionAssociation, _a1 error) *MockQuerier_UpdateJobConnectionDestination_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateJobConnectionDestination_Call) RunAndReturn(run func(context.Context, DBTX, UpdateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error)) *MockQuerier_UpdateJobConnectionDestination_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobHook provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateJobHook(ctx context.Context, db DBTX, arg UpdateJobHookParams) (NeosyncApiJobHook, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobHook")
	}

	var r0 NeosyncApiJobHook
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobHookParams) (NeosyncApiJobHook, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobHookParams) NeosyncApiJobHook); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJobHook)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateJobHookParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateJobHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobHook'
type MockQuerier_UpdateJobHook_Call struct {
	*mock.Call
}

// UpdateJobHook is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateJobHookParams
func (_e *MockQuerier_Expecter) UpdateJobHook(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateJobHook_Call {
	return &MockQuerier_UpdateJobHook_Call{Call: _e.mock.On("UpdateJobHook", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateJobHook_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateJobHookParams)) *MockQuerier_UpdateJobHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateJobHookParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateJobHook_Call) Return(_a0 NeosyncApiJobHook, _a1 error) *MockQuerier_UpdateJobHook_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateJobHook_Call) RunAndReturn(run func(context.Context, DBTX, UpdateJobHookParams) (NeosyncApiJobHook, error)) *MockQuerier_UpdateJobHook_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobMappings provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateJobMappings(ctx context.Context, db DBTX, arg UpdateJobMappingsParams) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobMappings")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobMappingsParams) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobMappingsParams) NeosyncApiJob); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateJobMappingsParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateJobMappings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobMappings'
type MockQuerier_UpdateJobMappings_Call struct {
	*mock.Call
}

// UpdateJobMappings is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateJobMappingsParams
func (_e *MockQuerier_Expecter) UpdateJobMappings(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateJobMappings_Call {
	return &MockQuerier_UpdateJobMappings_Call{Call: _e.mock.On("UpdateJobMappings", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateJobMappings_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateJobMappingsParams)) *MockQuerier_UpdateJobMappings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateJobMappingsParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateJobMappings_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_UpdateJobMappings_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateJobMappings_Call) RunAndReturn(run func(context.Context, DBTX, UpdateJobMappingsParams) (NeosyncApiJob, error)) *MockQuerier_UpdateJobMappings_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobSchedule provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateJobSchedule(ctx context.Context, db DBTX, arg UpdateJobScheduleParams) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobSchedule")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobScheduleParams) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobScheduleParams) NeosyncApiJob); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateJobScheduleParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateJobSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobSchedule'
type MockQuerier_UpdateJobSchedule_Call struct {
	*mock.Call
}

// UpdateJobSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateJobScheduleParams
func (_e *MockQuerier_Expecter) UpdateJobSchedule(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateJobSchedule_Call {
	return &MockQuerier_UpdateJobSchedule_Call{Call: _e.mock.On("UpdateJobSchedule", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateJobSchedule_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateJobScheduleParams)) *MockQuerier_UpdateJobSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateJobScheduleParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateJobSchedule_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_UpdateJobSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateJobSchedule_Call) RunAndReturn(run func(context.Context, DBTX, UpdateJobScheduleParams) (NeosyncApiJob, error)) *MockQuerier_UpdateJobSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobSource provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateJobSource(ctx context.Context, db DBTX, arg UpdateJobSourceParams) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobSource")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobSourceParams) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobSourceParams) NeosyncApiJob); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateJobSourceParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateJobSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobSource'
type MockQuerier_UpdateJobSource_Call struct {
	*mock.Call
}

// UpdateJobSource is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateJobSourceParams
func (_e *MockQuerier_Expecter) UpdateJobSource(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateJobSource_Call {
	return &MockQuerier_UpdateJobSource_Call{Call: _e.mock.On("UpdateJobSource", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateJobSource_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateJobSourceParams)) *MockQuerier_UpdateJobSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateJobSourceParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateJobSource_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_UpdateJobSource_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateJobSource_Call) RunAndReturn(run func(context.Context, DBTX, UpdateJobSourceParams) (NeosyncApiJob, error)) *MockQuerier_UpdateJobSource_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobVirtualForeignKeys provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateJobVirtualForeignKeys(ctx context.Context, db DBTX, arg UpdateJobVirtualForeignKeysParams) (NeosyncApiJob, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobVirtualForeignKeys")
	}

	var r0 NeosyncApiJob
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobVirtualForeignKeysParams) (NeosyncApiJob, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateJobVirtualForeignKeysParams) NeosyncApiJob); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiJob)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateJobVirtualForeignKeysParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateJobVirtualForeignKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobVirtualForeignKeys'
type MockQuerier_UpdateJobVirtualForeignKeys_Call struct {
	*mock.Call
}

// UpdateJobVirtualForeignKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateJobVirtualForeignKeysParams
func (_e *MockQuerier_Expecter) UpdateJobVirtualForeignKeys(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateJobVirtualForeignKeys_Call {
	return &MockQuerier_UpdateJobVirtualForeignKeys_Call{Call: _e.mock.On("UpdateJobVirtualForeignKeys", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateJobVirtualForeignKeys_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateJobVirtualForeignKeysParams)) *MockQuerier_UpdateJobVirtualForeignKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateJobVirtualForeignKeysParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateJobVirtualForeignKeys_Call) Return(_a0 NeosyncApiJob, _a1 error) *MockQuerier_UpdateJobVirtualForeignKeys_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateJobVirtualForeignKeys_Call) RunAndReturn(run func(context.Context, DBTX, UpdateJobVirtualForeignKeysParams) (NeosyncApiJob, error)) *MockQuerier_UpdateJobVirtualForeignKeys_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTemporalConfigByAccount provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateTemporalConfigByAccount(ctx context.Context, db DBTX, arg UpdateTemporalConfigByAccountParams) (NeosyncApiAccount, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTemporalConfigByAccount")
	}

	var r0 NeosyncApiAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateTemporalConfigByAccountParams) (NeosyncApiAccount, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateTemporalConfigByAccountParams) NeosyncApiAccount); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiAccount)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateTemporalConfigByAccountParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateTemporalConfigByAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTemporalConfigByAccount'
type MockQuerier_UpdateTemporalConfigByAccount_Call struct {
	*mock.Call
}

// UpdateTemporalConfigByAccount is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateTemporalConfigByAccountParams
func (_e *MockQuerier_Expecter) UpdateTemporalConfigByAccount(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateTemporalConfigByAccount_Call {
	return &MockQuerier_UpdateTemporalConfigByAccount_Call{Call: _e.mock.On("UpdateTemporalConfigByAccount", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateTemporalConfigByAccount_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateTemporalConfigByAccountParams)) *MockQuerier_UpdateTemporalConfigByAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateTemporalConfigByAccountParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateTemporalConfigByAccount_Call) Return(_a0 NeosyncApiAccount, _a1 error) *MockQuerier_UpdateTemporalConfigByAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateTemporalConfigByAccount_Call) RunAndReturn(run func(context.Context, DBTX, UpdateTemporalConfigByAccountParams) (NeosyncApiAccount, error)) *MockQuerier_UpdateTemporalConfigByAccount_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserDefinedTransformer provides a mock function with given fields: ctx, db, arg
func (_m *MockQuerier) UpdateUserDefinedTransformer(ctx context.Context, db DBTX, arg UpdateUserDefinedTransformerParams) (NeosyncApiTransformer, error) {
	ret := _m.Called(ctx, db, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserDefinedTransformer")
	}

	var r0 NeosyncApiTransformer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateUserDefinedTransformerParams) (NeosyncApiTransformer, error)); ok {
		return rf(ctx, db, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, DBTX, UpdateUserDefinedTransformerParams) NeosyncApiTransformer); ok {
		r0 = rf(ctx, db, arg)
	} else {
		r0 = ret.Get(0).(NeosyncApiTransformer)
	}

	if rf, ok := ret.Get(1).(func(context.Context, DBTX, UpdateUserDefinedTransformerParams) error); ok {
		r1 = rf(ctx, db, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQuerier_UpdateUserDefinedTransformer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserDefinedTransformer'
type MockQuerier_UpdateUserDefinedTransformer_Call struct {
	*mock.Call
}

// UpdateUserDefinedTransformer is a helper method to define mock.On call
//   - ctx context.Context
//   - db DBTX
//   - arg UpdateUserDefinedTransformerParams
func (_e *MockQuerier_Expecter) UpdateUserDefinedTransformer(ctx interface{}, db interface{}, arg interface{}) *MockQuerier_UpdateUserDefinedTransformer_Call {
	return &MockQuerier_UpdateUserDefinedTransformer_Call{Call: _e.mock.On("UpdateUserDefinedTransformer", ctx, db, arg)}
}

func (_c *MockQuerier_UpdateUserDefinedTransformer_Call) Run(run func(ctx context.Context, db DBTX, arg UpdateUserDefinedTransformerParams)) *MockQuerier_UpdateUserDefinedTransformer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(DBTX), args[2].(UpdateUserDefinedTransformerParams))
	})
	return _c
}

func (_c *MockQuerier_UpdateUserDefinedTransformer_Call) Return(_a0 NeosyncApiTransformer, _a1 error) *MockQuerier_UpdateUserDefinedTransformer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQuerier_UpdateUserDefinedTransformer_Call) RunAndReturn(run func(context.Context, DBTX, UpdateUserDefinedTransformerParams) (NeosyncApiTransformer, error)) *MockQuerier_UpdateUserDefinedTransformer_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQuerier creates a new instance of MockQuerier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQuerier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQuerier {
	mock := &MockQuerier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
