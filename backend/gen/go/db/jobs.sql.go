// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: jobs.sql

package db_queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	jsonmodels "github.com/nucleuscloud/neosync/backend/internal/nucleusdb/json-models"
)

const createJob = `-- name: CreateJob :one
INSERT INTO neosync_api.jobs (
  name, account_id, status, connection_source_id, mappings,
  cron_schedule, halt_on_new_column_addition, created_by_id, updated_by_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, created_at, updated_at, name, account_id, status, connection_source_id, mappings, cron_schedule, halt_on_new_column_addition, created_by_id, updated_by_id
`

type CreateJobParams struct {
	Name                    string
	AccountID               pgtype.UUID
	Status                  int16
	ConnectionSourceID      pgtype.UUID
	Mappings                []*jsonmodels.JobMapping
	CronSchedule            pgtype.Text
	HaltOnNewColumnAddition int16
	CreatedByID             pgtype.UUID
	UpdatedByID             pgtype.UUID
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.Name,
		arg.AccountID,
		arg.Status,
		arg.ConnectionSourceID,
		arg.Mappings,
		arg.CronSchedule,
		arg.HaltOnNewColumnAddition,
		arg.CreatedByID,
		arg.UpdatedByID,
	)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.Mappings,
		&i.CronSchedule,
		&i.HaltOnNewColumnAddition,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const createJobConnectionDestination = `-- name: CreateJobConnectionDestination :one
INSERT INTO neosync_api.job_destination_connection_associations (
  job_id, connection_id
) VALUES (
  $1, $2
)
ON CONFLICT(job_id, connection_id)
DO NOTHING
RETURNING id, created_at, updated_at, job_id, connection_id
`

type CreateJobConnectionDestinationParams struct {
	JobID        pgtype.UUID
	ConnectionID pgtype.UUID
}

func (q *Queries) CreateJobConnectionDestination(ctx context.Context, arg CreateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error) {
	row := q.db.QueryRow(ctx, createJobConnectionDestination, arg.JobID, arg.ConnectionID)
	var i NeosyncApiJobDestinationConnectionAssociation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JobID,
		&i.ConnectionID,
	)
	return i, err
}

type CreateJobConnectionDestinationsParams struct {
	JobID        pgtype.UUID
	ConnectionID pgtype.UUID
}

const getJobById = `-- name: GetJobById :one
SELECT id, created_at, updated_at, name, account_id, status, connection_source_id, mappings, cron_schedule, halt_on_new_column_addition, created_by_id, updated_by_id from neosync_api.jobs WHERE id = $1
`

func (q *Queries) GetJobById(ctx context.Context, id pgtype.UUID) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, getJobById, id)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.Mappings,
		&i.CronSchedule,
		&i.HaltOnNewColumnAddition,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const getJobByNameAndAccount = `-- name: GetJobByNameAndAccount :one
SELECT j.id, j.created_at, j.updated_at, j.name, j.account_id, j.status, j.connection_source_id, j.mappings, j.cron_schedule, j.halt_on_new_column_addition, j.created_by_id, j.updated_by_id from neosync_api.jobs j
INNER JOIN neosync_api.accounts a ON a.id = j.account_id
WHERE a.id = $1 AND j.name = $2
`

type GetJobByNameAndAccountParams struct {
	AccountId pgtype.UUID
	JobName   string
}

func (q *Queries) GetJobByNameAndAccount(ctx context.Context, arg GetJobByNameAndAccountParams) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, getJobByNameAndAccount, arg.AccountId, arg.JobName)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.Mappings,
		&i.CronSchedule,
		&i.HaltOnNewColumnAddition,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const getJobConnectionDestinations = `-- name: GetJobConnectionDestinations :many
SELECT jdca.connection_id from neosync_api.job_destination_connection_associations jdca
INNER JOIN neosync_api.jobs j ON j.id = jdca.job_id
WHERE j.id = $1
`

func (q *Queries) GetJobConnectionDestinations(ctx context.Context, id pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getJobConnectionDestinations, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var connection_id pgtype.UUID
		if err := rows.Scan(&connection_id); err != nil {
			return nil, err
		}
		items = append(items, connection_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobConnectionDestinationsByJobIds = `-- name: GetJobConnectionDestinationsByJobIds :many
SELECT jdca.id, jdca.created_at, jdca.updated_at, jdca.job_id, jdca.connection_id from neosync_api.job_destination_connection_associations jdca
INNER JOIN neosync_api.jobs j ON j.id = jdca.job_id
WHERE j.id = ANY($1::uuid[])
`

func (q *Queries) GetJobConnectionDestinationsByJobIds(ctx context.Context, jobids []pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error) {
	rows, err := q.db.Query(ctx, getJobConnectionDestinationsByJobIds, jobids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiJobDestinationConnectionAssociation
	for rows.Next() {
		var i NeosyncApiJobDestinationConnectionAssociation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JobID,
			&i.ConnectionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobsByAccount = `-- name: GetJobsByAccount :many
SELECT j.id, j.created_at, j.updated_at, j.name, j.account_id, j.status, j.connection_source_id, j.mappings, j.cron_schedule, j.halt_on_new_column_addition, j.created_by_id, j.updated_by_id from neosync_api.jobs j
INNER JOIN neosync_api.accounts a ON a.id = j.account_id
WHERE a.id = $1
ORDER BY j.created_at DESC
`

func (q *Queries) GetJobsByAccount(ctx context.Context, accountid pgtype.UUID) ([]NeosyncApiJob, error) {
	rows, err := q.db.Query(ctx, getJobsByAccount, accountid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiJob
	for rows.Next() {
		var i NeosyncApiJob
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.AccountID,
			&i.Status,
			&i.ConnectionSourceID,
			&i.Mappings,
			&i.CronSchedule,
			&i.HaltOnNewColumnAddition,
			&i.CreatedByID,
			&i.UpdatedByID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isJobNameAvailable = `-- name: IsJobNameAvailable :one
SELECT count(j.id) from neosync_api.jobs j
INNER JOIN neosync_api.accounts a ON a.id = j.account_id
WHERE a.id = $1 AND j.name = $2
`

type IsJobNameAvailableParams struct {
	AccountId pgtype.UUID
	JobName   string
}

func (q *Queries) IsJobNameAvailable(ctx context.Context, arg IsJobNameAvailableParams) (int64, error) {
	row := q.db.QueryRow(ctx, isJobNameAvailable, arg.AccountId, arg.JobName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removeJobById = `-- name: RemoveJobById :exec
DELETE FROM neosync_api.jobs WHERE id = $1
`

func (q *Queries) RemoveJobById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeJobById, id)
	return err
}

const removeJobConnectionDestinations = `-- name: RemoveJobConnectionDestinations :exec
DELETE FROM neosync_api.job_destination_connection_associations
WHERE id = ANY($1::uuid[])
`

func (q *Queries) RemoveJobConnectionDestinations(ctx context.Context, jobids []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeJobConnectionDestinations, jobids)
	return err
}
