// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: jobs.sql

package db_queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	jsonmodels "github.com/nucleuscloud/neosync/backend/internal/nucleusdb/json-models"
)

const createJob = `-- name: CreateJob :one
INSERT INTO neosync_api.jobs (
  name, account_id, status, connection_source_id, connection_options, mappings,
  cron_schedule, created_by_id, updated_by_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, created_at, updated_at, name, account_id, status, connection_source_id, connection_options, mappings, cron_schedule, created_by_id, updated_by_id
`

type CreateJobParams struct {
	Name               string
	AccountID          pgtype.UUID
	Status             int16
	ConnectionSourceID pgtype.UUID
	ConnectionOptions  *jsonmodels.JobSourceOptions
	Mappings           []*jsonmodels.JobMapping
	CronSchedule       pgtype.Text
	CreatedByID        pgtype.UUID
	UpdatedByID        pgtype.UUID
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.Name,
		arg.AccountID,
		arg.Status,
		arg.ConnectionSourceID,
		arg.ConnectionOptions,
		arg.Mappings,
		arg.CronSchedule,
		arg.CreatedByID,
		arg.UpdatedByID,
	)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.ConnectionOptions,
		&i.Mappings,
		&i.CronSchedule,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const createJobConnectionDestination = `-- name: CreateJobConnectionDestination :one
INSERT INTO neosync_api.job_destination_connection_associations (
  job_id, connection_id, options
) VALUES (
  $1, $2, $3
)
ON CONFLICT(job_id, connection_id)
DO NOTHING
RETURNING id, created_at, updated_at, job_id, connection_id, options
`

type CreateJobConnectionDestinationParams struct {
	JobID        pgtype.UUID
	ConnectionID pgtype.UUID
	Options      *jsonmodels.JobDestinationOptions
}

func (q *Queries) CreateJobConnectionDestination(ctx context.Context, arg CreateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error) {
	row := q.db.QueryRow(ctx, createJobConnectionDestination, arg.JobID, arg.ConnectionID, arg.Options)
	var i NeosyncApiJobDestinationConnectionAssociation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JobID,
		&i.ConnectionID,
		&i.Options,
	)
	return i, err
}

type CreateJobConnectionDestinationsParams struct {
	JobID        pgtype.UUID
	ConnectionID pgtype.UUID
	Options      *jsonmodels.JobDestinationOptions
}

const getJobById = `-- name: GetJobById :one
SELECT id, created_at, updated_at, name, account_id, status, connection_source_id, connection_options, mappings, cron_schedule, created_by_id, updated_by_id from neosync_api.jobs WHERE id = $1
`

func (q *Queries) GetJobById(ctx context.Context, id pgtype.UUID) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, getJobById, id)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.ConnectionOptions,
		&i.Mappings,
		&i.CronSchedule,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const getJobByNameAndAccount = `-- name: GetJobByNameAndAccount :one
SELECT j.id, j.created_at, j.updated_at, j.name, j.account_id, j.status, j.connection_source_id, j.connection_options, j.mappings, j.cron_schedule, j.created_by_id, j.updated_by_id from neosync_api.jobs j
INNER JOIN neosync_api.accounts a ON a.id = j.account_id
WHERE a.id = $1 AND j.name = $2
`

type GetJobByNameAndAccountParams struct {
	AccountId pgtype.UUID
	JobName   string
}

func (q *Queries) GetJobByNameAndAccount(ctx context.Context, arg GetJobByNameAndAccountParams) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, getJobByNameAndAccount, arg.AccountId, arg.JobName)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.ConnectionOptions,
		&i.Mappings,
		&i.CronSchedule,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const getJobConnectionDestination = `-- name: GetJobConnectionDestination :one
SELECT jdca.id, jdca.created_at, jdca.updated_at, jdca.job_id, jdca.connection_id, jdca.options from neosync_api.job_destination_connection_associations jdca
INNER JOIN neosync_api.jobs j ON j.id = jdca.job_id
WHERE j.id = $1 AND jdca.connection_id = $2
`

type GetJobConnectionDestinationParams struct {
	ID           pgtype.UUID
	ConnectionID pgtype.UUID
}

func (q *Queries) GetJobConnectionDestination(ctx context.Context, arg GetJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error) {
	row := q.db.QueryRow(ctx, getJobConnectionDestination, arg.ID, arg.ConnectionID)
	var i NeosyncApiJobDestinationConnectionAssociation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JobID,
		&i.ConnectionID,
		&i.Options,
	)
	return i, err
}

const getJobConnectionDestinations = `-- name: GetJobConnectionDestinations :many
SELECT jdca.id, jdca.created_at, jdca.updated_at, jdca.job_id, jdca.connection_id, jdca.options from neosync_api.job_destination_connection_associations jdca
INNER JOIN neosync_api.jobs j ON j.id = jdca.job_id
WHERE j.id = $1
`

func (q *Queries) GetJobConnectionDestinations(ctx context.Context, id pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error) {
	rows, err := q.db.Query(ctx, getJobConnectionDestinations, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiJobDestinationConnectionAssociation
	for rows.Next() {
		var i NeosyncApiJobDestinationConnectionAssociation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JobID,
			&i.ConnectionID,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobConnectionDestinationsByJobIds = `-- name: GetJobConnectionDestinationsByJobIds :many
SELECT jdca.id, jdca.created_at, jdca.updated_at, jdca.job_id, jdca.connection_id, jdca.options from neosync_api.job_destination_connection_associations jdca
INNER JOIN neosync_api.jobs j ON j.id = jdca.job_id
WHERE j.id = ANY($1::uuid[])
`

func (q *Queries) GetJobConnectionDestinationsByJobIds(ctx context.Context, jobids []pgtype.UUID) ([]NeosyncApiJobDestinationConnectionAssociation, error) {
	rows, err := q.db.Query(ctx, getJobConnectionDestinationsByJobIds, jobids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiJobDestinationConnectionAssociation
	for rows.Next() {
		var i NeosyncApiJobDestinationConnectionAssociation
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JobID,
			&i.ConnectionID,
			&i.Options,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobsByAccount = `-- name: GetJobsByAccount :many
SELECT j.id, j.created_at, j.updated_at, j.name, j.account_id, j.status, j.connection_source_id, j.connection_options, j.mappings, j.cron_schedule, j.created_by_id, j.updated_by_id from neosync_api.jobs j
INNER JOIN neosync_api.accounts a ON a.id = j.account_id
WHERE a.id = $1
ORDER BY j.created_at DESC
`

func (q *Queries) GetJobsByAccount(ctx context.Context, accountid pgtype.UUID) ([]NeosyncApiJob, error) {
	rows, err := q.db.Query(ctx, getJobsByAccount, accountid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NeosyncApiJob
	for rows.Next() {
		var i NeosyncApiJob
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.AccountID,
			&i.Status,
			&i.ConnectionSourceID,
			&i.ConnectionOptions,
			&i.Mappings,
			&i.CronSchedule,
			&i.CreatedByID,
			&i.UpdatedByID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isJobNameAvailable = `-- name: IsJobNameAvailable :one
SELECT count(j.id) from neosync_api.jobs j
INNER JOIN neosync_api.accounts a ON a.id = j.account_id
WHERE a.id = $1 AND j.name = $2
`

type IsJobNameAvailableParams struct {
	AccountId pgtype.UUID
	JobName   string
}

func (q *Queries) IsJobNameAvailable(ctx context.Context, arg IsJobNameAvailableParams) (int64, error) {
	row := q.db.QueryRow(ctx, isJobNameAvailable, arg.AccountId, arg.JobName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removeJobById = `-- name: RemoveJobById :exec
DELETE FROM neosync_api.jobs WHERE id = $1
`

func (q *Queries) RemoveJobById(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeJobById, id)
	return err
}

const removeJobConnectionDestination = `-- name: RemoveJobConnectionDestination :exec
DELETE FROM neosync_api.job_destination_connection_associations WHERE job_id = $1 AND connection_id = $2
`

type RemoveJobConnectionDestinationParams struct {
	JobID        pgtype.UUID
	ConnectionID pgtype.UUID
}

func (q *Queries) RemoveJobConnectionDestination(ctx context.Context, arg RemoveJobConnectionDestinationParams) error {
	_, err := q.db.Exec(ctx, removeJobConnectionDestination, arg.JobID, arg.ConnectionID)
	return err
}

const removeJobConnectionDestinations = `-- name: RemoveJobConnectionDestinations :exec
DELETE FROM neosync_api.job_destination_connection_associations
WHERE id = ANY($1::uuid[])
`

func (q *Queries) RemoveJobConnectionDestinations(ctx context.Context, jobids []pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeJobConnectionDestinations, jobids)
	return err
}

const updateJobConnectionDestination = `-- name: UpdateJobConnectionDestination :one
UPDATE neosync_api.job_destination_connection_associations
SET options = $1
WHERE job_id = $2 AND connection_id = $3
RETURNING id, created_at, updated_at, job_id, connection_id, options
`

type UpdateJobConnectionDestinationParams struct {
	Options      *jsonmodels.JobDestinationOptions
	JobID        pgtype.UUID
	ConnectionID pgtype.UUID
}

func (q *Queries) UpdateJobConnectionDestination(ctx context.Context, arg UpdateJobConnectionDestinationParams) (NeosyncApiJobDestinationConnectionAssociation, error) {
	row := q.db.QueryRow(ctx, updateJobConnectionDestination, arg.Options, arg.JobID, arg.ConnectionID)
	var i NeosyncApiJobDestinationConnectionAssociation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.JobID,
		&i.ConnectionID,
		&i.Options,
	)
	return i, err
}

const updateJobMappings = `-- name: UpdateJobMappings :one
UPDATE neosync_api.jobs
SET mappings = $1,
updated_by_id = $2
WHERE id = $3
RETURNING id, created_at, updated_at, name, account_id, status, connection_source_id, connection_options, mappings, cron_schedule, created_by_id, updated_by_id
`

type UpdateJobMappingsParams struct {
	Mappings    []*jsonmodels.JobMapping
	UpdatedByID pgtype.UUID
	ID          pgtype.UUID
}

func (q *Queries) UpdateJobMappings(ctx context.Context, arg UpdateJobMappingsParams) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, updateJobMappings, arg.Mappings, arg.UpdatedByID, arg.ID)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.ConnectionOptions,
		&i.Mappings,
		&i.CronSchedule,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const updateJobSchedule = `-- name: UpdateJobSchedule :one
UPDATE neosync_api.jobs
SET cron_schedule = $1,
updated_by_id = $2
WHERE id = $3
RETURNING id, created_at, updated_at, name, account_id, status, connection_source_id, connection_options, mappings, cron_schedule, created_by_id, updated_by_id
`

type UpdateJobScheduleParams struct {
	CronSchedule pgtype.Text
	UpdatedByID  pgtype.UUID
	ID           pgtype.UUID
}

func (q *Queries) UpdateJobSchedule(ctx context.Context, arg UpdateJobScheduleParams) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, updateJobSchedule, arg.CronSchedule, arg.UpdatedByID, arg.ID)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.ConnectionOptions,
		&i.Mappings,
		&i.CronSchedule,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}

const updateJobSource = `-- name: UpdateJobSource :one
UPDATE neosync_api.jobs
SET connection_source_id = $1,
connection_options = $2,
updated_by_id = $3
WHERE id = $4
RETURNING id, created_at, updated_at, name, account_id, status, connection_source_id, connection_options, mappings, cron_schedule, created_by_id, updated_by_id
`

type UpdateJobSourceParams struct {
	ConnectionSourceID pgtype.UUID
	ConnectionOptions  *jsonmodels.JobSourceOptions
	UpdatedByID        pgtype.UUID
	ID                 pgtype.UUID
}

func (q *Queries) UpdateJobSource(ctx context.Context, arg UpdateJobSourceParams) (NeosyncApiJob, error) {
	row := q.db.QueryRow(ctx, updateJobSource,
		arg.ConnectionSourceID,
		arg.ConnectionOptions,
		arg.UpdatedByID,
		arg.ID,
	)
	var i NeosyncApiJob
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.AccountID,
		&i.Status,
		&i.ConnectionSourceID,
		&i.ConnectionOptions,
		&i.Mappings,
		&i.CronSchedule,
		&i.CreatedByID,
		&i.UpdatedByID,
	)
	return i, err
}
