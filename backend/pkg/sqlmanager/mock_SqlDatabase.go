// Code generated by mockery. DO NOT EDIT.

package sqlmanager

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockSqlDatabase is an autogenerated mock type for the SqlDatabase type
type MockSqlDatabase struct {
	mock.Mock
}

type MockSqlDatabase_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSqlDatabase) EXPECT() *MockSqlDatabase_Expecter {
	return &MockSqlDatabase_Expecter{mock: &_m.Mock}
}

// BatchExec provides a mock function with given fields: ctx, batchSize, statements, opts
func (_m *MockSqlDatabase) BatchExec(ctx context.Context, batchSize int, statements []string, opts *BatchExecOpts) error {
	ret := _m.Called(ctx, batchSize, statements, opts)

	if len(ret) == 0 {
		panic("no return value specified for BatchExec")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, []string, *BatchExecOpts) error); ok {
		r0 = rf(ctx, batchSize, statements, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSqlDatabase_BatchExec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchExec'
type MockSqlDatabase_BatchExec_Call struct {
	*mock.Call
}

// BatchExec is a helper method to define mock.On call
//   - ctx context.Context
//   - batchSize int
//   - statements []string
//   - opts *BatchExecOpts
func (_e *MockSqlDatabase_Expecter) BatchExec(ctx interface{}, batchSize interface{}, statements interface{}, opts interface{}) *MockSqlDatabase_BatchExec_Call {
	return &MockSqlDatabase_BatchExec_Call{Call: _e.mock.On("BatchExec", ctx, batchSize, statements, opts)}
}

func (_c *MockSqlDatabase_BatchExec_Call) Run(run func(ctx context.Context, batchSize int, statements []string, opts *BatchExecOpts)) *MockSqlDatabase_BatchExec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].([]string), args[3].(*BatchExecOpts))
	})
	return _c
}

func (_c *MockSqlDatabase_BatchExec_Call) Return(_a0 error) *MockSqlDatabase_BatchExec_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSqlDatabase_BatchExec_Call) RunAndReturn(run func(context.Context, int, []string, *BatchExecOpts) error) *MockSqlDatabase_BatchExec_Call {
	_c.Call.Return(run)
	return _c
}

// ClosePool provides a mock function with given fields:
func (_m *MockSqlDatabase) ClosePool() {
	_m.Called()
}

// MockSqlDatabase_ClosePool_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClosePool'
type MockSqlDatabase_ClosePool_Call struct {
	*mock.Call
}

// ClosePool is a helper method to define mock.On call
func (_e *MockSqlDatabase_Expecter) ClosePool() *MockSqlDatabase_ClosePool_Call {
	return &MockSqlDatabase_ClosePool_Call{Call: _e.mock.On("ClosePool")}
}

func (_c *MockSqlDatabase_ClosePool_Call) Run(run func()) *MockSqlDatabase_ClosePool_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockSqlDatabase_ClosePool_Call) Return() *MockSqlDatabase_ClosePool_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockSqlDatabase_ClosePool_Call) RunAndReturn(run func()) *MockSqlDatabase_ClosePool_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: ctx, statement
func (_m *MockSqlDatabase) Exec(ctx context.Context, statement string) error {
	ret := _m.Called(ctx, statement)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, statement)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSqlDatabase_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockSqlDatabase_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
//   - statement string
func (_e *MockSqlDatabase_Expecter) Exec(ctx interface{}, statement interface{}) *MockSqlDatabase_Exec_Call {
	return &MockSqlDatabase_Exec_Call{Call: _e.mock.On("Exec", ctx, statement)}
}

func (_c *MockSqlDatabase_Exec_Call) Run(run func(ctx context.Context, statement string)) *MockSqlDatabase_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSqlDatabase_Exec_Call) Return(_a0 error) *MockSqlDatabase_Exec_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSqlDatabase_Exec_Call) RunAndReturn(run func(context.Context, string) error) *MockSqlDatabase_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllForeignKeyConstraints provides a mock function with given fields: ctx, schemas
func (_m *MockSqlDatabase) GetAllForeignKeyConstraints(ctx context.Context, schemas []string) ([]*ForeignKeyConstraintsRow, error) {
	ret := _m.Called(ctx, schemas)

	if len(ret) == 0 {
		panic("no return value specified for GetAllForeignKeyConstraints")
	}

	var r0 []*ForeignKeyConstraintsRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*ForeignKeyConstraintsRow, error)); ok {
		return rf(ctx, schemas)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*ForeignKeyConstraintsRow); ok {
		r0 = rf(ctx, schemas)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ForeignKeyConstraintsRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, schemas)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSqlDatabase_GetAllForeignKeyConstraints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllForeignKeyConstraints'
type MockSqlDatabase_GetAllForeignKeyConstraints_Call struct {
	*mock.Call
}

// GetAllForeignKeyConstraints is a helper method to define mock.On call
//   - ctx context.Context
//   - schemas []string
func (_e *MockSqlDatabase_Expecter) GetAllForeignKeyConstraints(ctx interface{}, schemas interface{}) *MockSqlDatabase_GetAllForeignKeyConstraints_Call {
	return &MockSqlDatabase_GetAllForeignKeyConstraints_Call{Call: _e.mock.On("GetAllForeignKeyConstraints", ctx, schemas)}
}

func (_c *MockSqlDatabase_GetAllForeignKeyConstraints_Call) Run(run func(ctx context.Context, schemas []string)) *MockSqlDatabase_GetAllForeignKeyConstraints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockSqlDatabase_GetAllForeignKeyConstraints_Call) Return(_a0 []*ForeignKeyConstraintsRow, _a1 error) *MockSqlDatabase_GetAllForeignKeyConstraints_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSqlDatabase_GetAllForeignKeyConstraints_Call) RunAndReturn(run func(context.Context, []string) ([]*ForeignKeyConstraintsRow, error)) *MockSqlDatabase_GetAllForeignKeyConstraints_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllPrimaryKeyConstraints provides a mock function with given fields: ctx, schemas
func (_m *MockSqlDatabase) GetAllPrimaryKeyConstraints(ctx context.Context, schemas []string) ([]*PrimaryKeyConstraintsRow, error) {
	ret := _m.Called(ctx, schemas)

	if len(ret) == 0 {
		panic("no return value specified for GetAllPrimaryKeyConstraints")
	}

	var r0 []*PrimaryKeyConstraintsRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) ([]*PrimaryKeyConstraintsRow, error)); ok {
		return rf(ctx, schemas)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) []*PrimaryKeyConstraintsRow); ok {
		r0 = rf(ctx, schemas)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*PrimaryKeyConstraintsRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, schemas)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSqlDatabase_GetAllPrimaryKeyConstraints_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllPrimaryKeyConstraints'
type MockSqlDatabase_GetAllPrimaryKeyConstraints_Call struct {
	*mock.Call
}

// GetAllPrimaryKeyConstraints is a helper method to define mock.On call
//   - ctx context.Context
//   - schemas []string
func (_e *MockSqlDatabase_Expecter) GetAllPrimaryKeyConstraints(ctx interface{}, schemas interface{}) *MockSqlDatabase_GetAllPrimaryKeyConstraints_Call {
	return &MockSqlDatabase_GetAllPrimaryKeyConstraints_Call{Call: _e.mock.On("GetAllPrimaryKeyConstraints", ctx, schemas)}
}

func (_c *MockSqlDatabase_GetAllPrimaryKeyConstraints_Call) Run(run func(ctx context.Context, schemas []string)) *MockSqlDatabase_GetAllPrimaryKeyConstraints_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockSqlDatabase_GetAllPrimaryKeyConstraints_Call) Return(_a0 []*PrimaryKeyConstraintsRow, _a1 error) *MockSqlDatabase_GetAllPrimaryKeyConstraints_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSqlDatabase_GetAllPrimaryKeyConstraints_Call) RunAndReturn(run func(context.Context, []string) ([]*PrimaryKeyConstraintsRow, error)) *MockSqlDatabase_GetAllPrimaryKeyConstraints_Call {
	_c.Call.Return(run)
	return _c
}

// GetCreateTableStatement provides a mock function with given fields: ctx, schema, table
func (_m *MockSqlDatabase) GetCreateTableStatement(ctx context.Context, schema string, table string) (string, error) {
	ret := _m.Called(ctx, schema, table)

	if len(ret) == 0 {
		panic("no return value specified for GetCreateTableStatement")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, schema, table)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, schema, table)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, schema, table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSqlDatabase_GetCreateTableStatement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCreateTableStatement'
type MockSqlDatabase_GetCreateTableStatement_Call struct {
	*mock.Call
}

// GetCreateTableStatement is a helper method to define mock.On call
//   - ctx context.Context
//   - schema string
//   - table string
func (_e *MockSqlDatabase_Expecter) GetCreateTableStatement(ctx interface{}, schema interface{}, table interface{}) *MockSqlDatabase_GetCreateTableStatement_Call {
	return &MockSqlDatabase_GetCreateTableStatement_Call{Call: _e.mock.On("GetCreateTableStatement", ctx, schema, table)}
}

func (_c *MockSqlDatabase_GetCreateTableStatement_Call) Run(run func(ctx context.Context, schema string, table string)) *MockSqlDatabase_GetCreateTableStatement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockSqlDatabase_GetCreateTableStatement_Call) Return(_a0 string, _a1 error) *MockSqlDatabase_GetCreateTableStatement_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSqlDatabase_GetCreateTableStatement_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *MockSqlDatabase_GetCreateTableStatement_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabaseSchema provides a mock function with given fields: ctx
func (_m *MockSqlDatabase) GetDatabaseSchema(ctx context.Context) ([]*DatabaseSchemaRow, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabaseSchema")
	}

	var r0 []*DatabaseSchemaRow
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*DatabaseSchemaRow, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*DatabaseSchemaRow); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*DatabaseSchemaRow)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSqlDatabase_GetDatabaseSchema_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabaseSchema'
type MockSqlDatabase_GetDatabaseSchema_Call struct {
	*mock.Call
}

// GetDatabaseSchema is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockSqlDatabase_Expecter) GetDatabaseSchema(ctx interface{}) *MockSqlDatabase_GetDatabaseSchema_Call {
	return &MockSqlDatabase_GetDatabaseSchema_Call{Call: _e.mock.On("GetDatabaseSchema", ctx)}
}

func (_c *MockSqlDatabase_GetDatabaseSchema_Call) Run(run func(ctx context.Context)) *MockSqlDatabase_GetDatabaseSchema_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockSqlDatabase_GetDatabaseSchema_Call) Return(_a0 []*DatabaseSchemaRow, _a1 error) *MockSqlDatabase_GetDatabaseSchema_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSqlDatabase_GetDatabaseSchema_Call) RunAndReturn(run func(context.Context) ([]*DatabaseSchemaRow, error)) *MockSqlDatabase_GetDatabaseSchema_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSqlDatabase creates a new instance of MockSqlDatabase. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSqlDatabase(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSqlDatabase {
	mock := &MockSqlDatabase{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
