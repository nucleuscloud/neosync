// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=.js"
// @generated from file mgmt/v1alpha1/job.proto (package mgmt.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { TransformerConfig, TransformerSource } from "./transformer_pb.js";

/**
 * @generated from enum mgmt.v1alpha1.JobStatus
 */
export enum JobStatus {
  /**
   * @generated from enum value: JOB_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: JOB_STATUS_ENABLED = 1;
   */
  ENABLED = 1,

  /**
   * @generated from enum value: JOB_STATUS_PAUSED = 3;
   */
  PAUSED = 3,

  /**
   * @generated from enum value: JOB_STATUS_DISABLED = 4;
   */
  DISABLED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(JobStatus)
proto3.util.setEnumType(JobStatus, "mgmt.v1alpha1.JobStatus", [
  { no: 0, name: "JOB_STATUS_UNSPECIFIED" },
  { no: 1, name: "JOB_STATUS_ENABLED" },
  { no: 3, name: "JOB_STATUS_PAUSED" },
  { no: 4, name: "JOB_STATUS_DISABLED" },
]);

/**
 * @generated from enum mgmt.v1alpha1.ActivityStatus
 */
export enum ActivityStatus {
  /**
   * @generated from enum value: ACTIVITY_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: ACTIVITY_STATUS_SCHEDULED = 1;
   */
  SCHEDULED = 1,

  /**
   * @generated from enum value: ACTIVITY_STATUS_STARTED = 2;
   */
  STARTED = 2,

  /**
   * @generated from enum value: ACTIVITY_STATUS_CANCELED = 3;
   */
  CANCELED = 3,

  /**
   * @generated from enum value: ACTIVITY_STATUS_FAILED = 4;
   */
  FAILED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ActivityStatus)
proto3.util.setEnumType(ActivityStatus, "mgmt.v1alpha1.ActivityStatus", [
  { no: 0, name: "ACTIVITY_STATUS_UNSPECIFIED" },
  { no: 1, name: "ACTIVITY_STATUS_SCHEDULED" },
  { no: 2, name: "ACTIVITY_STATUS_STARTED" },
  { no: 3, name: "ACTIVITY_STATUS_CANCELED" },
  { no: 4, name: "ACTIVITY_STATUS_FAILED" },
]);

/**
 * An enumeration of job run statuses.
 *
 * @generated from enum mgmt.v1alpha1.JobRunStatus
 */
export enum JobRunStatus {
  /**
   * if the job run status is unknown
   *
   * @generated from enum value: JOB_RUN_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * the run is pending and has not started yet
   *
   * @generated from enum value: JOB_RUN_STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * the run is currently in progress
   *
   * @generated from enum value: JOB_RUN_STATUS_RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * the run has successfully completed
   *
   * @generated from enum value: JOB_RUN_STATUS_COMPLETE = 3;
   */
  COMPLETE = 3,

  /**
   * the run ended with an error
   *
   * @generated from enum value: JOB_RUN_STATUS_ERROR = 4;
   */
  ERROR = 4,

  /**
   * the run was cancelled
   *
   * @generated from enum value: JOB_RUN_STATUS_CANCELED = 5;
   */
  CANCELED = 5,

  /**
   * the run was terminated
   *
   * @generated from enum value: JOB_RUN_STATUS_TERMINATED = 6;
   */
  TERMINATED = 6,

  /**
   * the run ended in failure
   *
   * @generated from enum value: JOB_RUN_STATUS_FAILED = 7;
   */
  FAILED = 7,

  /**
   * the run was ended pre-maturely due to timeout
   *
   * @generated from enum value: JOB_RUN_STATUS_TIMED_OUT = 8;
   */
  TIMED_OUT = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(JobRunStatus)
proto3.util.setEnumType(JobRunStatus, "mgmt.v1alpha1.JobRunStatus", [
  { no: 0, name: "JOB_RUN_STATUS_UNSPECIFIED" },
  { no: 1, name: "JOB_RUN_STATUS_PENDING" },
  { no: 2, name: "JOB_RUN_STATUS_RUNNING" },
  { no: 3, name: "JOB_RUN_STATUS_COMPLETE" },
  { no: 4, name: "JOB_RUN_STATUS_ERROR" },
  { no: 5, name: "JOB_RUN_STATUS_CANCELED" },
  { no: 6, name: "JOB_RUN_STATUS_TERMINATED" },
  { no: 7, name: "JOB_RUN_STATUS_FAILED" },
  { no: 8, name: "JOB_RUN_STATUS_TIMED_OUT" },
]);

/**
 * @generated from enum mgmt.v1alpha1.LogWindow
 */
export enum LogWindow {
  /**
   * @generated from enum value: LOG_WINDOW_NO_TIME_UNSPECIFIED = 0;
   */
  NO_TIME_UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOG_WINDOW_FIFTEEN_MIN = 1;
   */
  FIFTEEN_MIN = 1,

  /**
   * @generated from enum value: LOG_WINDOW_ONE_HOUR = 2;
   */
  ONE_HOUR = 2,

  /**
   * @generated from enum value: LOG_WINDOW_ONE_DAY = 3;
   */
  ONE_DAY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(LogWindow)
proto3.util.setEnumType(LogWindow, "mgmt.v1alpha1.LogWindow", [
  { no: 0, name: "LOG_WINDOW_NO_TIME_UNSPECIFIED" },
  { no: 1, name: "LOG_WINDOW_FIFTEEN_MIN" },
  { no: 2, name: "LOG_WINDOW_ONE_HOUR" },
  { no: 3, name: "LOG_WINDOW_ONE_DAY" },
]);

/**
 * @generated from enum mgmt.v1alpha1.LogLevel
 */
export enum LogLevel {
  /**
   * @generated from enum value: LOG_LEVEL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: LOG_LEVEL_DEBUG = 1;
   */
  DEBUG = 1,

  /**
   * @generated from enum value: LOG_LEVEL_INFO = 2;
   */
  INFO = 2,

  /**
   * @generated from enum value: LOG_LEVEL_WARN = 3;
   */
  WARN = 3,

  /**
   * @generated from enum value: LOG_LEVEL_ERROR = 4;
   */
  ERROR = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(LogLevel)
proto3.util.setEnumType(LogLevel, "mgmt.v1alpha1.LogLevel", [
  { no: 0, name: "LOG_LEVEL_UNSPECIFIED" },
  { no: 1, name: "LOG_LEVEL_DEBUG" },
  { no: 2, name: "LOG_LEVEL_INFO" },
  { no: 3, name: "LOG_LEVEL_WARN" },
  { no: 4, name: "LOG_LEVEL_ERROR" },
]);

/**
 * @generated from message mgmt.v1alpha1.GetJobsRequest
 */
export class GetJobsRequest extends Message<GetJobsRequest> {
  /**
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  constructor(data?: PartialMessage<GetJobsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobsRequest {
    return new GetJobsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobsRequest {
    return new GetJobsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobsRequest {
    return new GetJobsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobsRequest | PlainMessage<GetJobsRequest> | undefined, b: GetJobsRequest | PlainMessage<GetJobsRequest> | undefined): boolean {
    return proto3.util.equals(GetJobsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobsResponse
 */
export class GetJobsResponse extends Message<GetJobsResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.Job jobs = 1;
   */
  jobs: Job[] = [];

  constructor(data?: PartialMessage<GetJobsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "jobs", kind: "message", T: Job, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobsResponse {
    return new GetJobsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobsResponse {
    return new GetJobsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobsResponse {
    return new GetJobsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobsResponse | PlainMessage<GetJobsResponse> | undefined, b: GetJobsResponse | PlainMessage<GetJobsResponse> | undefined): boolean {
    return proto3.util.equals(GetJobsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobSource
 */
export class JobSource extends Message<JobSource> {
  /**
   * @generated from field: mgmt.v1alpha1.JobSourceOptions options = 1;
   */
  options?: JobSourceOptions;

  constructor(data?: PartialMessage<JobSource>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobSource";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "options", kind: "message", T: JobSourceOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobSource {
    return new JobSource().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobSource {
    return new JobSource().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobSource {
    return new JobSource().fromJsonString(jsonString, options);
  }

  static equals(a: JobSource | PlainMessage<JobSource> | undefined, b: JobSource | PlainMessage<JobSource> | undefined): boolean {
    return proto3.util.equals(JobSource, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobSourceOptions
 */
export class JobSourceOptions extends Message<JobSourceOptions> {
  /**
   * @generated from oneof mgmt.v1alpha1.JobSourceOptions.config
   */
  config: {
    /**
     * @generated from field: mgmt.v1alpha1.PostgresSourceConnectionOptions postgres = 1;
     */
    value: PostgresSourceConnectionOptions;
    case: "postgres";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.AwsS3SourceConnectionOptions aws_s3 = 2;
     */
    value: AwsS3SourceConnectionOptions;
    case: "awsS3";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MysqlSourceConnectionOptions mysql = 3;
     */
    value: MysqlSourceConnectionOptions;
    case: "mysql";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.GenerateSourceOptions generate = 4;
     */
    value: GenerateSourceOptions;
    case: "generate";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.AiGenerateSourceOptions ai_generate = 5;
     */
    value: AiGenerateSourceOptions;
    case: "aiGenerate";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MongoDBSourceConnectionOptions mongodb = 6;
     */
    value: MongoDBSourceConnectionOptions;
    case: "mongodb";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.DynamoDBSourceConnectionOptions dynamodb = 7;
     */
    value: DynamoDBSourceConnectionOptions;
    case: "dynamodb";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MssqlSourceConnectionOptions mssql = 8;
     */
    value: MssqlSourceConnectionOptions;
    case: "mssql";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<JobSourceOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobSourceOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "postgres", kind: "message", T: PostgresSourceConnectionOptions, oneof: "config" },
    { no: 2, name: "aws_s3", kind: "message", T: AwsS3SourceConnectionOptions, oneof: "config" },
    { no: 3, name: "mysql", kind: "message", T: MysqlSourceConnectionOptions, oneof: "config" },
    { no: 4, name: "generate", kind: "message", T: GenerateSourceOptions, oneof: "config" },
    { no: 5, name: "ai_generate", kind: "message", T: AiGenerateSourceOptions, oneof: "config" },
    { no: 6, name: "mongodb", kind: "message", T: MongoDBSourceConnectionOptions, oneof: "config" },
    { no: 7, name: "dynamodb", kind: "message", T: DynamoDBSourceConnectionOptions, oneof: "config" },
    { no: 8, name: "mssql", kind: "message", T: MssqlSourceConnectionOptions, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobSourceOptions {
    return new JobSourceOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobSourceOptions {
    return new JobSourceOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobSourceOptions {
    return new JobSourceOptions().fromJsonString(jsonString, options);
  }

  static equals(a: JobSourceOptions | PlainMessage<JobSourceOptions> | undefined, b: JobSourceOptions | PlainMessage<JobSourceOptions> | undefined): boolean {
    return proto3.util.equals(JobSourceOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobDestination
 */
export class CreateJobDestination extends Message<CreateJobDestination> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.JobDestinationOptions options = 2;
   */
  options?: JobDestinationOptions;

  constructor(data?: PartialMessage<CreateJobDestination>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobDestination";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "options", kind: "message", T: JobDestinationOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobDestination {
    return new CreateJobDestination().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobDestination {
    return new CreateJobDestination().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobDestination {
    return new CreateJobDestination().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobDestination | PlainMessage<CreateJobDestination> | undefined, b: CreateJobDestination | PlainMessage<CreateJobDestination> | undefined): boolean {
    return proto3.util.equals(CreateJobDestination, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobDestination
 */
export class JobDestination extends Message<JobDestination> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.JobDestinationOptions options = 2;
   */
  options?: JobDestinationOptions;

  /**
   * @generated from field: string id = 3;
   */
  id = "";

  constructor(data?: PartialMessage<JobDestination>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobDestination";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "options", kind: "message", T: JobDestinationOptions },
    { no: 3, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobDestination {
    return new JobDestination().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobDestination {
    return new JobDestination().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobDestination {
    return new JobDestination().fromJsonString(jsonString, options);
  }

  static equals(a: JobDestination | PlainMessage<JobDestination> | undefined, b: JobDestination | PlainMessage<JobDestination> | undefined): boolean {
    return proto3.util.equals(JobDestination, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AiGenerateSourceOptions
 */
export class AiGenerateSourceOptions extends Message<AiGenerateSourceOptions> {
  /**
   * The connection id that corresponds with an AI-based Neosync connection
   *
   * @generated from field: string ai_connection_id = 1;
   */
  aiConnectionId = "";

  /**
   * The list of schemas (and their tables) along with any configuration options that will be used to generate data for.
   *
   * @generated from field: repeated mgmt.v1alpha1.AiGenerateSourceSchemaOption schemas = 2;
   */
  schemas: AiGenerateSourceSchemaOption[] = [];

  /**
   * An optional connection id that will be used as the basis for the shape of data to be generated.
   *
   * @generated from field: optional string fk_source_connection_id = 3;
   */
  fkSourceConnectionId?: string;

  /**
   * The name of the model to use
   *
   * @generated from field: string model_name = 4;
   */
  modelName = "";

  /**
   * Optionally provide a user prompt to give more context to the schema
   *
   * @generated from field: optional string user_prompt = 5;
   */
  userPrompt?: string;

  /**
   * The batch size that will be used to generate X number of records. This is global and will be applied to all tables configured.
   *
   * @generated from field: optional int64 generate_batch_size = 6;
   */
  generateBatchSize?: bigint;

  constructor(data?: PartialMessage<AiGenerateSourceOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AiGenerateSourceOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ai_connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schemas", kind: "message", T: AiGenerateSourceSchemaOption, repeated: true },
    { no: 3, name: "fk_source_connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "model_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "user_prompt", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 6, name: "generate_batch_size", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiGenerateSourceOptions {
    return new AiGenerateSourceOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiGenerateSourceOptions {
    return new AiGenerateSourceOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiGenerateSourceOptions {
    return new AiGenerateSourceOptions().fromJsonString(jsonString, options);
  }

  static equals(a: AiGenerateSourceOptions | PlainMessage<AiGenerateSourceOptions> | undefined, b: AiGenerateSourceOptions | PlainMessage<AiGenerateSourceOptions> | undefined): boolean {
    return proto3.util.equals(AiGenerateSourceOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AiGenerateSourceSchemaOption
 */
export class AiGenerateSourceSchemaOption extends Message<AiGenerateSourceSchemaOption> {
  /**
   * The dataabase schema
   *
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * The list of tables (and their configuration) that reside within the schema to receive generated data
   *
   * @generated from field: repeated mgmt.v1alpha1.AiGenerateSourceTableOption tables = 2;
   */
  tables: AiGenerateSourceTableOption[] = [];

  constructor(data?: PartialMessage<AiGenerateSourceSchemaOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AiGenerateSourceSchemaOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tables", kind: "message", T: AiGenerateSourceTableOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiGenerateSourceSchemaOption {
    return new AiGenerateSourceSchemaOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiGenerateSourceSchemaOption {
    return new AiGenerateSourceSchemaOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiGenerateSourceSchemaOption {
    return new AiGenerateSourceSchemaOption().fromJsonString(jsonString, options);
  }

  static equals(a: AiGenerateSourceSchemaOption | PlainMessage<AiGenerateSourceSchemaOption> | undefined, b: AiGenerateSourceSchemaOption | PlainMessage<AiGenerateSourceSchemaOption> | undefined): boolean {
    return proto3.util.equals(AiGenerateSourceSchemaOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AiGenerateSourceTableOption
 */
export class AiGenerateSourceTableOption extends Message<AiGenerateSourceTableOption> {
  /**
   * The table that will be used to. 1. The schema of the table will be injected into the prompt, of which the resulting data will then be inserted.
   *
   * @generated from field: string table = 1;
   */
  table = "";

  /**
   * The total number of records to be generated.
   *
   * @generated from field: int64 row_count = 2;
   */
  rowCount = protoInt64.zero;

  constructor(data?: PartialMessage<AiGenerateSourceTableOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AiGenerateSourceTableOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AiGenerateSourceTableOption {
    return new AiGenerateSourceTableOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AiGenerateSourceTableOption {
    return new AiGenerateSourceTableOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AiGenerateSourceTableOption {
    return new AiGenerateSourceTableOption().fromJsonString(jsonString, options);
  }

  static equals(a: AiGenerateSourceTableOption | PlainMessage<AiGenerateSourceTableOption> | undefined, b: AiGenerateSourceTableOption | PlainMessage<AiGenerateSourceTableOption> | undefined): boolean {
    return proto3.util.equals(AiGenerateSourceTableOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GenerateSourceOptions
 */
export class GenerateSourceOptions extends Message<GenerateSourceOptions> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.GenerateSourceSchemaOption schemas = 1;
   */
  schemas: GenerateSourceSchemaOption[] = [];

  /**
   * @generated from field: optional string fk_source_connection_id = 3;
   */
  fkSourceConnectionId?: string;

  constructor(data?: PartialMessage<GenerateSourceOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GenerateSourceOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schemas", kind: "message", T: GenerateSourceSchemaOption, repeated: true },
    { no: 3, name: "fk_source_connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateSourceOptions {
    return new GenerateSourceOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateSourceOptions {
    return new GenerateSourceOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateSourceOptions {
    return new GenerateSourceOptions().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateSourceOptions | PlainMessage<GenerateSourceOptions> | undefined, b: GenerateSourceOptions | PlainMessage<GenerateSourceOptions> | undefined): boolean {
    return proto3.util.equals(GenerateSourceOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GenerateSourceSchemaOption
 */
export class GenerateSourceSchemaOption extends Message<GenerateSourceSchemaOption> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: repeated mgmt.v1alpha1.GenerateSourceTableOption tables = 2;
   */
  tables: GenerateSourceTableOption[] = [];

  constructor(data?: PartialMessage<GenerateSourceSchemaOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GenerateSourceSchemaOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tables", kind: "message", T: GenerateSourceTableOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateSourceSchemaOption {
    return new GenerateSourceSchemaOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateSourceSchemaOption {
    return new GenerateSourceSchemaOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateSourceSchemaOption {
    return new GenerateSourceSchemaOption().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateSourceSchemaOption | PlainMessage<GenerateSourceSchemaOption> | undefined, b: GenerateSourceSchemaOption | PlainMessage<GenerateSourceSchemaOption> | undefined): boolean {
    return proto3.util.equals(GenerateSourceSchemaOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GenerateSourceTableOption
 */
export class GenerateSourceTableOption extends Message<GenerateSourceTableOption> {
  /**
   * @generated from field: string table = 1;
   */
  table = "";

  /**
   * @generated from field: int64 row_count = 2;
   */
  rowCount = protoInt64.zero;

  constructor(data?: PartialMessage<GenerateSourceTableOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GenerateSourceTableOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GenerateSourceTableOption {
    return new GenerateSourceTableOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GenerateSourceTableOption {
    return new GenerateSourceTableOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GenerateSourceTableOption {
    return new GenerateSourceTableOption().fromJsonString(jsonString, options);
  }

  static equals(a: GenerateSourceTableOption | PlainMessage<GenerateSourceTableOption> | undefined, b: GenerateSourceTableOption | PlainMessage<GenerateSourceTableOption> | undefined): boolean {
    return proto3.util.equals(GenerateSourceTableOption, a, b);
  }
}

/**
 * MongoDB connection options for a job source
 *
 * @generated from message mgmt.v1alpha1.MongoDBSourceConnectionOptions
 */
export class MongoDBSourceConnectionOptions extends Message<MongoDBSourceConnectionOptions> {
  /**
   * The unique connection id to a mongo connection configuration
   *
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  constructor(data?: PartialMessage<MongoDBSourceConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MongoDBSourceConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MongoDBSourceConnectionOptions {
    return new MongoDBSourceConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MongoDBSourceConnectionOptions {
    return new MongoDBSourceConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MongoDBSourceConnectionOptions {
    return new MongoDBSourceConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: MongoDBSourceConnectionOptions | PlainMessage<MongoDBSourceConnectionOptions> | undefined, b: MongoDBSourceConnectionOptions | PlainMessage<MongoDBSourceConnectionOptions> | undefined): boolean {
    return proto3.util.equals(MongoDBSourceConnectionOptions, a, b);
  }
}

/**
 * DynamoDB connection options for a job source
 *
 * @generated from message mgmt.v1alpha1.DynamoDBSourceConnectionOptions
 */
export class DynamoDBSourceConnectionOptions extends Message<DynamoDBSourceConnectionOptions> {
  /**
   * The unique connection id to a dynamodb connection configuration
   *
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * List of table option configurations for any mapped source table.
   * Any table listed in this must also be present as a job mapping table to be applied.
   *
   * @generated from field: repeated mgmt.v1alpha1.DynamoDBSourceTableOption tables = 2;
   */
  tables: DynamoDBSourceTableOption[] = [];

  /**
   * Default transformations for any unmapped keys
   *
   * @generated from field: mgmt.v1alpha1.DynamoDBSourceUnmappedTransformConfig unmapped_transforms = 3;
   */
  unmappedTransforms?: DynamoDBSourceUnmappedTransformConfig;

  /**
   * Enforces strong read consistency
   * False: Eventually Consistent Reads, True: Strongly Consistent Reads
   * https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadConsistency.html
   *
   * @generated from field: bool enable_consistent_read = 4;
   */
  enableConsistentRead = false;

  constructor(data?: PartialMessage<DynamoDBSourceConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DynamoDBSourceConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tables", kind: "message", T: DynamoDBSourceTableOption, repeated: true },
    { no: 3, name: "unmapped_transforms", kind: "message", T: DynamoDBSourceUnmappedTransformConfig },
    { no: 4, name: "enable_consistent_read", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamoDBSourceConnectionOptions {
    return new DynamoDBSourceConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamoDBSourceConnectionOptions {
    return new DynamoDBSourceConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamoDBSourceConnectionOptions {
    return new DynamoDBSourceConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: DynamoDBSourceConnectionOptions | PlainMessage<DynamoDBSourceConnectionOptions> | undefined, b: DynamoDBSourceConnectionOptions | PlainMessage<DynamoDBSourceConnectionOptions> | undefined): boolean {
    return proto3.util.equals(DynamoDBSourceConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DynamoDBSourceUnmappedTransformConfig
 */
export class DynamoDBSourceUnmappedTransformConfig extends Message<DynamoDBSourceUnmappedTransformConfig> {
  /**
   * Byte
   *
   * @generated from field: mgmt.v1alpha1.JobMappingTransformer b = 1;
   */
  b?: JobMappingTransformer;

  /**
   * Boolean
   *
   * @generated from field: mgmt.v1alpha1.JobMappingTransformer boolean = 2;
   */
  boolean?: JobMappingTransformer;

  /**
   * Number
   *
   * @generated from field: mgmt.v1alpha1.JobMappingTransformer n = 4;
   */
  n?: JobMappingTransformer;

  /**
   * String
   *
   * @generated from field: mgmt.v1alpha1.JobMappingTransformer s = 6;
   */
  s?: JobMappingTransformer;

  constructor(data?: PartialMessage<DynamoDBSourceUnmappedTransformConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DynamoDBSourceUnmappedTransformConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "b", kind: "message", T: JobMappingTransformer },
    { no: 2, name: "boolean", kind: "message", T: JobMappingTransformer },
    { no: 4, name: "n", kind: "message", T: JobMappingTransformer },
    { no: 6, name: "s", kind: "message", T: JobMappingTransformer },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamoDBSourceUnmappedTransformConfig {
    return new DynamoDBSourceUnmappedTransformConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamoDBSourceUnmappedTransformConfig {
    return new DynamoDBSourceUnmappedTransformConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamoDBSourceUnmappedTransformConfig {
    return new DynamoDBSourceUnmappedTransformConfig().fromJsonString(jsonString, options);
  }

  static equals(a: DynamoDBSourceUnmappedTransformConfig | PlainMessage<DynamoDBSourceUnmappedTransformConfig> | undefined, b: DynamoDBSourceUnmappedTransformConfig | PlainMessage<DynamoDBSourceUnmappedTransformConfig> | undefined): boolean {
    return proto3.util.equals(DynamoDBSourceUnmappedTransformConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DynamoDBSourceTableOption
 */
export class DynamoDBSourceTableOption extends Message<DynamoDBSourceTableOption> {
  /**
   * The table that this configuration will be applied to
   *
   * @generated from field: string table = 1;
   */
  table = "";

  /**
   * An optional PartiQL query that may be used for subsetting the DynamoDB table.
   * This is not a parameterized query and must be valid. Intended to be everything after the WHERE keyword.
   *
   * @generated from field: optional string where_clause = 2;
   */
  whereClause?: string;

  constructor(data?: PartialMessage<DynamoDBSourceTableOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DynamoDBSourceTableOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "where_clause", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamoDBSourceTableOption {
    return new DynamoDBSourceTableOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamoDBSourceTableOption {
    return new DynamoDBSourceTableOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamoDBSourceTableOption {
    return new DynamoDBSourceTableOption().fromJsonString(jsonString, options);
  }

  static equals(a: DynamoDBSourceTableOption | PlainMessage<DynamoDBSourceTableOption> | undefined, b: DynamoDBSourceTableOption | PlainMessage<DynamoDBSourceTableOption> | undefined): boolean {
    return proto3.util.equals(DynamoDBSourceTableOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresSourceConnectionOptions
 */
export class PostgresSourceConnectionOptions extends Message<PostgresSourceConnectionOptions> {
  /**
   * @deprecated - Use new_column_addition_strategy instead
   *
   * @generated from field: optional bool halt_on_new_column_addition = 1;
   */
  haltOnNewColumnAddition?: boolean;

  /**
   * @generated from field: repeated mgmt.v1alpha1.PostgresSourceSchemaOption schemas = 2;
   */
  schemas: PostgresSourceSchemaOption[] = [];

  /**
   * @generated from field: string connection_id = 3;
   */
  connectionId = "";

  /**
   * @generated from field: bool subset_by_foreign_key_constraints = 4;
   */
  subsetByForeignKeyConstraints = false;

  /**
   * Provide a strategy of what to do in the event Neosync encounters an unmapped column for the job's mapped tables.
   *
   * @generated from field: mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy new_column_addition_strategy = 5;
   */
  newColumnAdditionStrategy?: PostgresSourceConnectionOptions_NewColumnAdditionStrategy;

  constructor(data?: PartialMessage<PostgresSourceConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSourceConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "halt_on_new_column_addition", kind: "scalar", T: 8 /* ScalarType.BOOL */, opt: true },
    { no: 2, name: "schemas", kind: "message", T: PostgresSourceSchemaOption, repeated: true },
    { no: 3, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subset_by_foreign_key_constraints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "new_column_addition_strategy", kind: "message", T: PostgresSourceConnectionOptions_NewColumnAdditionStrategy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSourceConnectionOptions {
    return new PostgresSourceConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSourceConnectionOptions {
    return new PostgresSourceConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSourceConnectionOptions {
    return new PostgresSourceConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSourceConnectionOptions | PlainMessage<PostgresSourceConnectionOptions> | undefined, b: PostgresSourceConnectionOptions | PlainMessage<PostgresSourceConnectionOptions> | undefined): boolean {
    return proto3.util.equals(PostgresSourceConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy
 */
export class PostgresSourceConnectionOptions_NewColumnAdditionStrategy extends Message<PostgresSourceConnectionOptions_NewColumnAdditionStrategy> {
  /**
   * @generated from oneof mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy.strategy
   */
  strategy: {
    /**
     * halt job if a new column is detected. This is equiavlent to the deprecated halt_on_new_column_addition
     *
     * @generated from field: mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy.HaltJob halt_job = 1;
     */
    value: PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob;
    case: "haltJob";
  } | {
    /**
     * automatically handle unmapped columns. It handles this by using the DBs default/nullable values.
     * If this doesn't exist, will fall back to configuring generators for supported datatypes.
     * If none of the criteria above can be met, the job run will fail to prevent leaking of PII.
     *
     * @generated from field: mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy.AutoMap auto_map = 2;
     */
    value: PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap;
    case: "autoMap";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "halt_job", kind: "message", T: PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob, oneof: "strategy" },
    { no: 2, name: "auto_map", kind: "message", T: PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap, oneof: "strategy" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSourceConnectionOptions_NewColumnAdditionStrategy | PlainMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy> | undefined, b: PostgresSourceConnectionOptions_NewColumnAdditionStrategy | PlainMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy> | undefined): boolean {
    return proto3.util.equals(PostgresSourceConnectionOptions_NewColumnAdditionStrategy, a, b);
  }
}

/**
 * Configuration for the HaltJob strategy
 *
 * @generated from message mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy.HaltJob
 */
export class PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob extends Message<PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob> {
  constructor(data?: PartialMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy.HaltJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob | PlainMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob> | undefined, b: PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob | PlainMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob> | undefined): boolean {
    return proto3.util.equals(PostgresSourceConnectionOptions_NewColumnAdditionStrategy_HaltJob, a, b);
  }
}

/**
 * Configuration for the AutoMap strategy
 *
 * @generated from message mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy.AutoMap
 */
export class PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap extends Message<PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap> {
  constructor(data?: PartialMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSourceConnectionOptions.NewColumnAdditionStrategy.AutoMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap {
    return new PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap | PlainMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap> | undefined, b: PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap | PlainMessage<PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap> | undefined): boolean {
    return proto3.util.equals(PostgresSourceConnectionOptions_NewColumnAdditionStrategy_AutoMap, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresSourceSchemaOption
 */
export class PostgresSourceSchemaOption extends Message<PostgresSourceSchemaOption> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: repeated mgmt.v1alpha1.PostgresSourceTableOption tables = 2;
   */
  tables: PostgresSourceTableOption[] = [];

  constructor(data?: PartialMessage<PostgresSourceSchemaOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSourceSchemaOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tables", kind: "message", T: PostgresSourceTableOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSourceSchemaOption {
    return new PostgresSourceSchemaOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSourceSchemaOption {
    return new PostgresSourceSchemaOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSourceSchemaOption {
    return new PostgresSourceSchemaOption().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSourceSchemaOption | PlainMessage<PostgresSourceSchemaOption> | undefined, b: PostgresSourceSchemaOption | PlainMessage<PostgresSourceSchemaOption> | undefined): boolean {
    return proto3.util.equals(PostgresSourceSchemaOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresSourceTableOption
 */
export class PostgresSourceTableOption extends Message<PostgresSourceTableOption> {
  /**
   * @generated from field: string table = 1;
   */
  table = "";

  /**
   * @generated from field: optional string where_clause = 2;
   */
  whereClause?: string;

  constructor(data?: PartialMessage<PostgresSourceTableOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSourceTableOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "where_clause", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSourceTableOption {
    return new PostgresSourceTableOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSourceTableOption {
    return new PostgresSourceTableOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSourceTableOption {
    return new PostgresSourceTableOption().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSourceTableOption | PlainMessage<PostgresSourceTableOption> | undefined, b: PostgresSourceTableOption | PlainMessage<PostgresSourceTableOption> | undefined): boolean {
    return proto3.util.equals(PostgresSourceTableOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlSourceConnectionOptions
 */
export class MysqlSourceConnectionOptions extends Message<MysqlSourceConnectionOptions> {
  /**
   * @generated from field: bool halt_on_new_column_addition = 1;
   */
  haltOnNewColumnAddition = false;

  /**
   * @generated from field: repeated mgmt.v1alpha1.MysqlSourceSchemaOption schemas = 2;
   */
  schemas: MysqlSourceSchemaOption[] = [];

  /**
   * @generated from field: string connection_id = 3;
   */
  connectionId = "";

  /**
   * @generated from field: bool subset_by_foreign_key_constraints = 4;
   */
  subsetByForeignKeyConstraints = false;

  constructor(data?: PartialMessage<MysqlSourceConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlSourceConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "halt_on_new_column_addition", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "schemas", kind: "message", T: MysqlSourceSchemaOption, repeated: true },
    { no: 3, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subset_by_foreign_key_constraints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlSourceConnectionOptions {
    return new MysqlSourceConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlSourceConnectionOptions {
    return new MysqlSourceConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlSourceConnectionOptions {
    return new MysqlSourceConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlSourceConnectionOptions | PlainMessage<MysqlSourceConnectionOptions> | undefined, b: MysqlSourceConnectionOptions | PlainMessage<MysqlSourceConnectionOptions> | undefined): boolean {
    return proto3.util.equals(MysqlSourceConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlSourceSchemaOption
 */
export class MysqlSourceSchemaOption extends Message<MysqlSourceSchemaOption> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: repeated mgmt.v1alpha1.MysqlSourceTableOption tables = 2;
   */
  tables: MysqlSourceTableOption[] = [];

  constructor(data?: PartialMessage<MysqlSourceSchemaOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlSourceSchemaOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tables", kind: "message", T: MysqlSourceTableOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlSourceSchemaOption {
    return new MysqlSourceSchemaOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlSourceSchemaOption {
    return new MysqlSourceSchemaOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlSourceSchemaOption {
    return new MysqlSourceSchemaOption().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlSourceSchemaOption | PlainMessage<MysqlSourceSchemaOption> | undefined, b: MysqlSourceSchemaOption | PlainMessage<MysqlSourceSchemaOption> | undefined): boolean {
    return proto3.util.equals(MysqlSourceSchemaOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlSourceTableOption
 */
export class MysqlSourceTableOption extends Message<MysqlSourceTableOption> {
  /**
   * @generated from field: string table = 1;
   */
  table = "";

  /**
   * @generated from field: optional string where_clause = 2;
   */
  whereClause?: string;

  constructor(data?: PartialMessage<MysqlSourceTableOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlSourceTableOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "where_clause", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlSourceTableOption {
    return new MysqlSourceTableOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlSourceTableOption {
    return new MysqlSourceTableOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlSourceTableOption {
    return new MysqlSourceTableOption().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlSourceTableOption | PlainMessage<MysqlSourceTableOption> | undefined, b: MysqlSourceTableOption | PlainMessage<MysqlSourceTableOption> | undefined): boolean {
    return proto3.util.equals(MysqlSourceTableOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MssqlSourceConnectionOptions
 */
export class MssqlSourceConnectionOptions extends Message<MssqlSourceConnectionOptions> {
  /**
   * @generated from field: bool halt_on_new_column_addition = 1;
   */
  haltOnNewColumnAddition = false;

  /**
   * @generated from field: repeated mgmt.v1alpha1.MssqlSourceSchemaOption schemas = 2;
   */
  schemas: MssqlSourceSchemaOption[] = [];

  /**
   * @generated from field: string connection_id = 3;
   */
  connectionId = "";

  /**
   * @generated from field: bool subset_by_foreign_key_constraints = 4;
   */
  subsetByForeignKeyConstraints = false;

  constructor(data?: PartialMessage<MssqlSourceConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MssqlSourceConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "halt_on_new_column_addition", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "schemas", kind: "message", T: MssqlSourceSchemaOption, repeated: true },
    { no: 3, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "subset_by_foreign_key_constraints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MssqlSourceConnectionOptions {
    return new MssqlSourceConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MssqlSourceConnectionOptions {
    return new MssqlSourceConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MssqlSourceConnectionOptions {
    return new MssqlSourceConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: MssqlSourceConnectionOptions | PlainMessage<MssqlSourceConnectionOptions> | undefined, b: MssqlSourceConnectionOptions | PlainMessage<MssqlSourceConnectionOptions> | undefined): boolean {
    return proto3.util.equals(MssqlSourceConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MssqlSourceSchemaOption
 */
export class MssqlSourceSchemaOption extends Message<MssqlSourceSchemaOption> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: repeated mgmt.v1alpha1.MssqlSourceTableOption tables = 2;
   */
  tables: MssqlSourceTableOption[] = [];

  constructor(data?: PartialMessage<MssqlSourceSchemaOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MssqlSourceSchemaOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tables", kind: "message", T: MssqlSourceTableOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MssqlSourceSchemaOption {
    return new MssqlSourceSchemaOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MssqlSourceSchemaOption {
    return new MssqlSourceSchemaOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MssqlSourceSchemaOption {
    return new MssqlSourceSchemaOption().fromJsonString(jsonString, options);
  }

  static equals(a: MssqlSourceSchemaOption | PlainMessage<MssqlSourceSchemaOption> | undefined, b: MssqlSourceSchemaOption | PlainMessage<MssqlSourceSchemaOption> | undefined): boolean {
    return proto3.util.equals(MssqlSourceSchemaOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MssqlSourceTableOption
 */
export class MssqlSourceTableOption extends Message<MssqlSourceTableOption> {
  /**
   * @generated from field: string table = 1;
   */
  table = "";

  /**
   * @generated from field: optional string where_clause = 2;
   */
  whereClause?: string;

  constructor(data?: PartialMessage<MssqlSourceTableOption>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MssqlSourceTableOption";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "where_clause", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MssqlSourceTableOption {
    return new MssqlSourceTableOption().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MssqlSourceTableOption {
    return new MssqlSourceTableOption().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MssqlSourceTableOption {
    return new MssqlSourceTableOption().fromJsonString(jsonString, options);
  }

  static equals(a: MssqlSourceTableOption | PlainMessage<MssqlSourceTableOption> | undefined, b: MssqlSourceTableOption | PlainMessage<MssqlSourceTableOption> | undefined): boolean {
    return proto3.util.equals(MssqlSourceTableOption, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AwsS3SourceConnectionOptions
 */
export class AwsS3SourceConnectionOptions extends Message<AwsS3SourceConnectionOptions> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  constructor(data?: PartialMessage<AwsS3SourceConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsS3SourceConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3SourceConnectionOptions {
    return new AwsS3SourceConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3SourceConnectionOptions {
    return new AwsS3SourceConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3SourceConnectionOptions {
    return new AwsS3SourceConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3SourceConnectionOptions | PlainMessage<AwsS3SourceConnectionOptions> | undefined, b: AwsS3SourceConnectionOptions | PlainMessage<AwsS3SourceConnectionOptions> | undefined): boolean {
    return proto3.util.equals(AwsS3SourceConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobDestinationOptions
 */
export class JobDestinationOptions extends Message<JobDestinationOptions> {
  /**
   * @generated from oneof mgmt.v1alpha1.JobDestinationOptions.config
   */
  config: {
    /**
     * @generated from field: mgmt.v1alpha1.PostgresDestinationConnectionOptions postgres_options = 1;
     */
    value: PostgresDestinationConnectionOptions;
    case: "postgresOptions";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.AwsS3DestinationConnectionOptions aws_s3_options = 2;
     */
    value: AwsS3DestinationConnectionOptions;
    case: "awsS3Options";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MysqlDestinationConnectionOptions mysql_options = 3;
     */
    value: MysqlDestinationConnectionOptions;
    case: "mysqlOptions";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MongoDBDestinationConnectionOptions mongodb_options = 4;
     */
    value: MongoDBDestinationConnectionOptions;
    case: "mongodbOptions";
  } | {
    /**
     * Destination Connecton options for Google Cloud Storage
     *
     * @generated from field: mgmt.v1alpha1.GcpCloudStorageDestinationConnectionOptions gcp_cloudstorage_options = 5;
     */
    value: GcpCloudStorageDestinationConnectionOptions;
    case: "gcpCloudstorageOptions";
  } | {
    /**
     * Destination Connection options for DynamoDB
     *
     * @generated from field: mgmt.v1alpha1.DynamoDBDestinationConnectionOptions dynamodb_options = 6;
     */
    value: DynamoDBDestinationConnectionOptions;
    case: "dynamodbOptions";
  } | {
    /**
     * Destination Connection options for Microsoft SQL Server
     *
     * @generated from field: mgmt.v1alpha1.MssqlDestinationConnectionOptions mssql_options = 7;
     */
    value: MssqlDestinationConnectionOptions;
    case: "mssqlOptions";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<JobDestinationOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobDestinationOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "postgres_options", kind: "message", T: PostgresDestinationConnectionOptions, oneof: "config" },
    { no: 2, name: "aws_s3_options", kind: "message", T: AwsS3DestinationConnectionOptions, oneof: "config" },
    { no: 3, name: "mysql_options", kind: "message", T: MysqlDestinationConnectionOptions, oneof: "config" },
    { no: 4, name: "mongodb_options", kind: "message", T: MongoDBDestinationConnectionOptions, oneof: "config" },
    { no: 5, name: "gcp_cloudstorage_options", kind: "message", T: GcpCloudStorageDestinationConnectionOptions, oneof: "config" },
    { no: 6, name: "dynamodb_options", kind: "message", T: DynamoDBDestinationConnectionOptions, oneof: "config" },
    { no: 7, name: "mssql_options", kind: "message", T: MssqlDestinationConnectionOptions, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobDestinationOptions {
    return new JobDestinationOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobDestinationOptions {
    return new JobDestinationOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobDestinationOptions {
    return new JobDestinationOptions().fromJsonString(jsonString, options);
  }

  static equals(a: JobDestinationOptions | PlainMessage<JobDestinationOptions> | undefined, b: JobDestinationOptions | PlainMessage<JobDestinationOptions> | undefined): boolean {
    return proto3.util.equals(JobDestinationOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MongoDBDestinationConnectionOptions
 */
export class MongoDBDestinationConnectionOptions extends Message<MongoDBDestinationConnectionOptions> {
  constructor(data?: PartialMessage<MongoDBDestinationConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MongoDBDestinationConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MongoDBDestinationConnectionOptions {
    return new MongoDBDestinationConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MongoDBDestinationConnectionOptions {
    return new MongoDBDestinationConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MongoDBDestinationConnectionOptions {
    return new MongoDBDestinationConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: MongoDBDestinationConnectionOptions | PlainMessage<MongoDBDestinationConnectionOptions> | undefined, b: MongoDBDestinationConnectionOptions | PlainMessage<MongoDBDestinationConnectionOptions> | undefined): boolean {
    return proto3.util.equals(MongoDBDestinationConnectionOptions, a, b);
  }
}

/**
 * Configuration for Google Cloud Storage Destination Connection Job Options
 *
 * @generated from message mgmt.v1alpha1.GcpCloudStorageDestinationConnectionOptions
 */
export class GcpCloudStorageDestinationConnectionOptions extends Message<GcpCloudStorageDestinationConnectionOptions> {
  constructor(data?: PartialMessage<GcpCloudStorageDestinationConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GcpCloudStorageDestinationConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GcpCloudStorageDestinationConnectionOptions {
    return new GcpCloudStorageDestinationConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GcpCloudStorageDestinationConnectionOptions {
    return new GcpCloudStorageDestinationConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GcpCloudStorageDestinationConnectionOptions {
    return new GcpCloudStorageDestinationConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: GcpCloudStorageDestinationConnectionOptions | PlainMessage<GcpCloudStorageDestinationConnectionOptions> | undefined, b: GcpCloudStorageDestinationConnectionOptions | PlainMessage<GcpCloudStorageDestinationConnectionOptions> | undefined): boolean {
    return proto3.util.equals(GcpCloudStorageDestinationConnectionOptions, a, b);
  }
}

/**
 * Configuration for DynamoDB Destination Connection Job Options
 *
 * @generated from message mgmt.v1alpha1.DynamoDBDestinationConnectionOptions
 */
export class DynamoDBDestinationConnectionOptions extends Message<DynamoDBDestinationConnectionOptions> {
  /**
   * List of table mappings when piping data from a dynamoDB table to another dynamoDB table
   *
   * @generated from field: repeated mgmt.v1alpha1.DynamoDBDestinationTableMapping table_mappings = 1;
   */
  tableMappings: DynamoDBDestinationTableMapping[] = [];

  constructor(data?: PartialMessage<DynamoDBDestinationConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DynamoDBDestinationConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_mappings", kind: "message", T: DynamoDBDestinationTableMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamoDBDestinationConnectionOptions {
    return new DynamoDBDestinationConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamoDBDestinationConnectionOptions {
    return new DynamoDBDestinationConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamoDBDestinationConnectionOptions {
    return new DynamoDBDestinationConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: DynamoDBDestinationConnectionOptions | PlainMessage<DynamoDBDestinationConnectionOptions> | undefined, b: DynamoDBDestinationConnectionOptions | PlainMessage<DynamoDBDestinationConnectionOptions> | undefined): boolean {
    return proto3.util.equals(DynamoDBDestinationConnectionOptions, a, b);
  }
}

/**
 * Configuration for mapping a source table to a destination table for DynamoDB
 *
 * @generated from message mgmt.v1alpha1.DynamoDBDestinationTableMapping
 */
export class DynamoDBDestinationTableMapping extends Message<DynamoDBDestinationTableMapping> {
  /**
   * The name of the incoming source table
   *
   * @generated from field: string source_table = 1;
   */
  sourceTable = "";

  /**
   * The name of the outgoing destination table
   *
   * @generated from field: string destination_table = 2;
   */
  destinationTable = "";

  constructor(data?: PartialMessage<DynamoDBDestinationTableMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DynamoDBDestinationTableMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destination_table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamoDBDestinationTableMapping {
    return new DynamoDBDestinationTableMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamoDBDestinationTableMapping {
    return new DynamoDBDestinationTableMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamoDBDestinationTableMapping {
    return new DynamoDBDestinationTableMapping().fromJsonString(jsonString, options);
  }

  static equals(a: DynamoDBDestinationTableMapping | PlainMessage<DynamoDBDestinationTableMapping> | undefined, b: DynamoDBDestinationTableMapping | PlainMessage<DynamoDBDestinationTableMapping> | undefined): boolean {
    return proto3.util.equals(DynamoDBDestinationTableMapping, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresDestinationConnectionOptions
 */
export class PostgresDestinationConnectionOptions extends Message<PostgresDestinationConnectionOptions> {
  /**
   * @generated from field: mgmt.v1alpha1.PostgresTruncateTableConfig truncate_table = 1;
   */
  truncateTable?: PostgresTruncateTableConfig;

  /**
   * @generated from field: bool init_table_schema = 2;
   */
  initTableSchema = false;

  /**
   * @generated from field: mgmt.v1alpha1.PostgresOnConflictConfig on_conflict = 3;
   */
  onConflict?: PostgresOnConflictConfig;

  /**
   * Insert all valid records, skipping any that violate foreign key constraints.
   *
   * @generated from field: bool skip_foreign_key_violations = 4;
   */
  skipForeignKeyViolations = false;

  /**
   * Configure batching options to handle how much data is sent to your database at once.
   *
   * @generated from field: mgmt.v1alpha1.BatchConfig batch = 5;
   */
  batch?: BatchConfig;

  /**
   * Determines the maximum number of parallel batched inserts.
   *
   * @generated from field: optional uint32 max_in_flight = 6;
   */
  maxInFlight?: number;

  constructor(data?: PartialMessage<PostgresDestinationConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresDestinationConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "truncate_table", kind: "message", T: PostgresTruncateTableConfig },
    { no: 2, name: "init_table_schema", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "on_conflict", kind: "message", T: PostgresOnConflictConfig },
    { no: 4, name: "skip_foreign_key_violations", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "batch", kind: "message", T: BatchConfig },
    { no: 6, name: "max_in_flight", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresDestinationConnectionOptions {
    return new PostgresDestinationConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresDestinationConnectionOptions {
    return new PostgresDestinationConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresDestinationConnectionOptions {
    return new PostgresDestinationConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresDestinationConnectionOptions | PlainMessage<PostgresDestinationConnectionOptions> | undefined, b: PostgresDestinationConnectionOptions | PlainMessage<PostgresDestinationConnectionOptions> | undefined): boolean {
    return proto3.util.equals(PostgresDestinationConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresOnConflictConfig
 */
export class PostgresOnConflictConfig extends Message<PostgresOnConflictConfig> {
  /**
   * @generated from field: bool do_nothing = 1;
   */
  doNothing = false;

  constructor(data?: PartialMessage<PostgresOnConflictConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresOnConflictConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "do_nothing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresOnConflictConfig {
    return new PostgresOnConflictConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresOnConflictConfig {
    return new PostgresOnConflictConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresOnConflictConfig {
    return new PostgresOnConflictConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresOnConflictConfig | PlainMessage<PostgresOnConflictConfig> | undefined, b: PostgresOnConflictConfig | PlainMessage<PostgresOnConflictConfig> | undefined): boolean {
    return proto3.util.equals(PostgresOnConflictConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresTruncateTableConfig
 */
export class PostgresTruncateTableConfig extends Message<PostgresTruncateTableConfig> {
  /**
   * @generated from field: bool truncate_before_insert = 1;
   */
  truncateBeforeInsert = false;

  /**
   * @generated from field: bool cascade = 2;
   */
  cascade = false;

  constructor(data?: PartialMessage<PostgresTruncateTableConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresTruncateTableConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "truncate_before_insert", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "cascade", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresTruncateTableConfig {
    return new PostgresTruncateTableConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresTruncateTableConfig {
    return new PostgresTruncateTableConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresTruncateTableConfig {
    return new PostgresTruncateTableConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresTruncateTableConfig | PlainMessage<PostgresTruncateTableConfig> | undefined, b: PostgresTruncateTableConfig | PlainMessage<PostgresTruncateTableConfig> | undefined): boolean {
    return proto3.util.equals(PostgresTruncateTableConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlDestinationConnectionOptions
 */
export class MysqlDestinationConnectionOptions extends Message<MysqlDestinationConnectionOptions> {
  /**
   * @generated from field: mgmt.v1alpha1.MysqlTruncateTableConfig truncate_table = 1;
   */
  truncateTable?: MysqlTruncateTableConfig;

  /**
   * @generated from field: bool init_table_schema = 2;
   */
  initTableSchema = false;

  /**
   * @generated from field: mgmt.v1alpha1.MysqlOnConflictConfig on_conflict = 3;
   */
  onConflict?: MysqlOnConflictConfig;

  /**
   * Insert all valid records, skipping any that violate foreign key constraints.
   *
   * @generated from field: bool skip_foreign_key_violations = 4;
   */
  skipForeignKeyViolations = false;

  /**
   * Configure batching options to handle how much data is sent to your database at once.
   *
   * @generated from field: mgmt.v1alpha1.BatchConfig batch = 5;
   */
  batch?: BatchConfig;

  /**
   * Determines the maximum number of parallel batched inserts.
   *
   * @generated from field: optional uint32 max_in_flight = 6;
   */
  maxInFlight?: number;

  constructor(data?: PartialMessage<MysqlDestinationConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlDestinationConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "truncate_table", kind: "message", T: MysqlTruncateTableConfig },
    { no: 2, name: "init_table_schema", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "on_conflict", kind: "message", T: MysqlOnConflictConfig },
    { no: 4, name: "skip_foreign_key_violations", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "batch", kind: "message", T: BatchConfig },
    { no: 6, name: "max_in_flight", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlDestinationConnectionOptions {
    return new MysqlDestinationConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlDestinationConnectionOptions {
    return new MysqlDestinationConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlDestinationConnectionOptions {
    return new MysqlDestinationConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlDestinationConnectionOptions | PlainMessage<MysqlDestinationConnectionOptions> | undefined, b: MysqlDestinationConnectionOptions | PlainMessage<MysqlDestinationConnectionOptions> | undefined): boolean {
    return proto3.util.equals(MysqlDestinationConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlTruncateTableConfig
 */
export class MysqlTruncateTableConfig extends Message<MysqlTruncateTableConfig> {
  /**
   * @generated from field: bool truncate_before_insert = 1;
   */
  truncateBeforeInsert = false;

  constructor(data?: PartialMessage<MysqlTruncateTableConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlTruncateTableConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "truncate_before_insert", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlTruncateTableConfig {
    return new MysqlTruncateTableConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlTruncateTableConfig {
    return new MysqlTruncateTableConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlTruncateTableConfig {
    return new MysqlTruncateTableConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlTruncateTableConfig | PlainMessage<MysqlTruncateTableConfig> | undefined, b: MysqlTruncateTableConfig | PlainMessage<MysqlTruncateTableConfig> | undefined): boolean {
    return proto3.util.equals(MysqlTruncateTableConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlOnConflictConfig
 */
export class MysqlOnConflictConfig extends Message<MysqlOnConflictConfig> {
  /**
   * @generated from field: bool do_nothing = 1;
   */
  doNothing = false;

  constructor(data?: PartialMessage<MysqlOnConflictConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlOnConflictConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "do_nothing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlOnConflictConfig {
    return new MysqlOnConflictConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlOnConflictConfig {
    return new MysqlOnConflictConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlOnConflictConfig {
    return new MysqlOnConflictConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlOnConflictConfig | PlainMessage<MysqlOnConflictConfig> | undefined, b: MysqlOnConflictConfig | PlainMessage<MysqlOnConflictConfig> | undefined): boolean {
    return proto3.util.equals(MysqlOnConflictConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MssqlDestinationConnectionOptions
 */
export class MssqlDestinationConnectionOptions extends Message<MssqlDestinationConnectionOptions> {
  /**
   * @generated from field: mgmt.v1alpha1.MssqlTruncateTableConfig truncate_table = 1;
   */
  truncateTable?: MssqlTruncateTableConfig;

  /**
   * Currently not supported and a placeholder for future implementation
   *
   * @generated from field: bool init_table_schema = 2;
   */
  initTableSchema = false;

  /**
   * Currently not supported and a placeholder for future implementation
   *
   * @generated from field: mgmt.v1alpha1.MssqlOnConflictConfig on_conflict = 3;
   */
  onConflict?: MssqlOnConflictConfig;

  /**
   * Insert all valid records, skipping any that violate foreign key constraints.
   *
   * @generated from field: bool skip_foreign_key_violations = 4;
   */
  skipForeignKeyViolations = false;

  /**
   * Configure batching options to handle how much data is sent to your database at once.
   *
   * @generated from field: mgmt.v1alpha1.BatchConfig batch = 5;
   */
  batch?: BatchConfig;

  /**
   * Determines the maximum number of parallel batched inserts.
   *
   * @generated from field: optional uint32 max_in_flight = 6;
   */
  maxInFlight?: number;

  constructor(data?: PartialMessage<MssqlDestinationConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MssqlDestinationConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "truncate_table", kind: "message", T: MssqlTruncateTableConfig },
    { no: 2, name: "init_table_schema", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "on_conflict", kind: "message", T: MssqlOnConflictConfig },
    { no: 4, name: "skip_foreign_key_violations", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "batch", kind: "message", T: BatchConfig },
    { no: 6, name: "max_in_flight", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MssqlDestinationConnectionOptions {
    return new MssqlDestinationConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MssqlDestinationConnectionOptions {
    return new MssqlDestinationConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MssqlDestinationConnectionOptions {
    return new MssqlDestinationConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: MssqlDestinationConnectionOptions | PlainMessage<MssqlDestinationConnectionOptions> | undefined, b: MssqlDestinationConnectionOptions | PlainMessage<MssqlDestinationConnectionOptions> | undefined): boolean {
    return proto3.util.equals(MssqlDestinationConnectionOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MssqlTruncateTableConfig
 */
export class MssqlTruncateTableConfig extends Message<MssqlTruncateTableConfig> {
  /**
   * @generated from field: bool truncate_before_insert = 1;
   */
  truncateBeforeInsert = false;

  constructor(data?: PartialMessage<MssqlTruncateTableConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MssqlTruncateTableConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "truncate_before_insert", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MssqlTruncateTableConfig {
    return new MssqlTruncateTableConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MssqlTruncateTableConfig {
    return new MssqlTruncateTableConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MssqlTruncateTableConfig {
    return new MssqlTruncateTableConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MssqlTruncateTableConfig | PlainMessage<MssqlTruncateTableConfig> | undefined, b: MssqlTruncateTableConfig | PlainMessage<MssqlTruncateTableConfig> | undefined): boolean {
    return proto3.util.equals(MssqlTruncateTableConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MssqlOnConflictConfig
 */
export class MssqlOnConflictConfig extends Message<MssqlOnConflictConfig> {
  /**
   * @generated from field: bool do_nothing = 1;
   */
  doNothing = false;

  constructor(data?: PartialMessage<MssqlOnConflictConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MssqlOnConflictConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "do_nothing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MssqlOnConflictConfig {
    return new MssqlOnConflictConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MssqlOnConflictConfig {
    return new MssqlOnConflictConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MssqlOnConflictConfig {
    return new MssqlOnConflictConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MssqlOnConflictConfig | PlainMessage<MssqlOnConflictConfig> | undefined, b: MssqlOnConflictConfig | PlainMessage<MssqlOnConflictConfig> | undefined): boolean {
    return proto3.util.equals(MssqlOnConflictConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AwsS3DestinationConnectionOptions
 */
export class AwsS3DestinationConnectionOptions extends Message<AwsS3DestinationConnectionOptions> {
  /**
   * The storage class that will be used when objects are written to S3
   *
   * @generated from field: mgmt.v1alpha1.AwsS3DestinationConnectionOptions.StorageClass storage_class = 1;
   */
  storageClass = AwsS3DestinationConnectionOptions_StorageClass.UNSPECIFIED;

  /**
   * The maximum number of batched messages to have in flight at a given time. Increase this to improve throughput.
   *
   * @generated from field: optional uint32 max_in_flight = 2;
   */
  maxInFlight?: number;

  /**
   * The maximum period (duration string) to wait on an upload before abandoning it and reattempting.
   *
   * @generated from field: optional string timeout = 3;
   */
  timeout?: string;

  /**
   * Configure batching options to more efficiently store records in S3
   *
   * @generated from field: mgmt.v1alpha1.BatchConfig batch = 4;
   */
  batch?: BatchConfig;

  constructor(data?: PartialMessage<AwsS3DestinationConnectionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsS3DestinationConnectionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "storage_class", kind: "enum", T: proto3.getEnumType(AwsS3DestinationConnectionOptions_StorageClass) },
    { no: 2, name: "max_in_flight", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 3, name: "timeout", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "batch", kind: "message", T: BatchConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3DestinationConnectionOptions {
    return new AwsS3DestinationConnectionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3DestinationConnectionOptions {
    return new AwsS3DestinationConnectionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3DestinationConnectionOptions {
    return new AwsS3DestinationConnectionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3DestinationConnectionOptions | PlainMessage<AwsS3DestinationConnectionOptions> | undefined, b: AwsS3DestinationConnectionOptions | PlainMessage<AwsS3DestinationConnectionOptions> | undefined): boolean {
    return proto3.util.equals(AwsS3DestinationConnectionOptions, a, b);
  }
}

/**
 * @generated from enum mgmt.v1alpha1.AwsS3DestinationConnectionOptions.StorageClass
 */
export enum AwsS3DestinationConnectionOptions_StorageClass {
  /**
   * @generated from enum value: STORAGE_CLASS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STORAGE_CLASS_STANDARD = 1;
   */
  STANDARD = 1,

  /**
   * @generated from enum value: STORAGE_CLASS_REDUCED_REDUNDANCY = 2;
   */
  REDUCED_REDUNDANCY = 2,

  /**
   * @generated from enum value: STORAGE_CLASS_GLACIER = 3;
   */
  GLACIER = 3,

  /**
   * @generated from enum value: STORAGE_CLASS_STANDARD_IA = 4;
   */
  STANDARD_IA = 4,

  /**
   * @generated from enum value: STORAGE_CLASS_ONEZONE_IA = 5;
   */
  ONEZONE_IA = 5,

  /**
   * @generated from enum value: STORAGE_CLASS_INTELLIGENT_TIERING = 6;
   */
  INTELLIGENT_TIERING = 6,

  /**
   * @generated from enum value: STORAGE_CLASS_DEEP_ARCHIVE = 7;
   */
  DEEP_ARCHIVE = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(AwsS3DestinationConnectionOptions_StorageClass)
proto3.util.setEnumType(AwsS3DestinationConnectionOptions_StorageClass, "mgmt.v1alpha1.AwsS3DestinationConnectionOptions.StorageClass", [
  { no: 0, name: "STORAGE_CLASS_UNSPECIFIED" },
  { no: 1, name: "STORAGE_CLASS_STANDARD" },
  { no: 2, name: "STORAGE_CLASS_REDUCED_REDUNDANCY" },
  { no: 3, name: "STORAGE_CLASS_GLACIER" },
  { no: 4, name: "STORAGE_CLASS_STANDARD_IA" },
  { no: 5, name: "STORAGE_CLASS_ONEZONE_IA" },
  { no: 6, name: "STORAGE_CLASS_INTELLIGENT_TIERING" },
  { no: 7, name: "STORAGE_CLASS_DEEP_ARCHIVE" },
]);

/**
 * @generated from message mgmt.v1alpha1.BatchConfig
 */
export class BatchConfig extends Message<BatchConfig> {
  /**
   * The max allowed in a batch before it is flushed. 0 to disable.
   *
   * @generated from field: optional uint32 count = 1;
   */
  count?: number;

  /**
   * A duration string in which an incomplete batch should be flushed regardless of the count.
   * Examples are 1s, 1m, 500ms
   *
   * @generated from field: optional string period = 2;
   */
  period?: string;

  constructor(data?: PartialMessage<BatchConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.BatchConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 13 /* ScalarType.UINT32 */, opt: true },
    { no: 2, name: "period", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchConfig {
    return new BatchConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchConfig {
    return new BatchConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchConfig {
    return new BatchConfig().fromJsonString(jsonString, options);
  }

  static equals(a: BatchConfig | PlainMessage<BatchConfig> | undefined, b: BatchConfig | PlainMessage<BatchConfig> | undefined): boolean {
    return proto3.util.equals(BatchConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobRequest
 */
export class CreateJobRequest extends Message<CreateJobRequest> {
  /**
   * The unique account identifier that this job will be associated with
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * The unique, friendly name of the job. This is unique per account
   *
   * @generated from field: string job_name = 2;
   */
  jobName = "";

  /**
   * Optionally provide a cron schedule. Goes into effect if the job status is set to enabled
   *
   * @generated from field: optional string cron_schedule = 3;
   */
  cronSchedule?: string;

  /**
   * @generated from field: repeated mgmt.v1alpha1.JobMapping mappings = 4;
   */
  mappings: JobMapping[] = [];

  /**
   * @generated from field: mgmt.v1alpha1.JobSource source = 5;
   */
  source?: JobSource;

  /**
   * @generated from field: repeated mgmt.v1alpha1.CreateJobDestination destinations = 6;
   */
  destinations: CreateJobDestination[] = [];

  /**
   * Initially trigger a run of this job regardless of its status or cron schedule
   *
   * @generated from field: bool initiate_job_run = 7;
   */
  initiateJobRun = false;

  /**
   * Specify timeouts and other workflow options for the underlying temporal workflow
   *
   * @generated from field: mgmt.v1alpha1.WorkflowOptions workflow_options = 8;
   */
  workflowOptions?: WorkflowOptions;

  /**
   * Specify timeout and retry options for data synchronization activities
   * Data sync activities are any piece of work that involves actually synchronizing data from a source to a destination
   * For the data sync and generate jobs, this will be applied per table
   *
   * @generated from field: mgmt.v1alpha1.ActivityOptions sync_options = 9;
   */
  syncOptions?: ActivityOptions;

  /**
   * @generated from field: repeated mgmt.v1alpha1.VirtualForeignConstraint virtual_foreign_keys = 10;
   */
  virtualForeignKeys: VirtualForeignConstraint[] = [];

  constructor(data?: PartialMessage<CreateJobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "job_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cron_schedule", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 4, name: "mappings", kind: "message", T: JobMapping, repeated: true },
    { no: 5, name: "source", kind: "message", T: JobSource },
    { no: 6, name: "destinations", kind: "message", T: CreateJobDestination, repeated: true },
    { no: 7, name: "initiate_job_run", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "workflow_options", kind: "message", T: WorkflowOptions },
    { no: 9, name: "sync_options", kind: "message", T: ActivityOptions },
    { no: 10, name: "virtual_foreign_keys", kind: "message", T: VirtualForeignConstraint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobRequest {
    return new CreateJobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobRequest {
    return new CreateJobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobRequest {
    return new CreateJobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobRequest | PlainMessage<CreateJobRequest> | undefined, b: CreateJobRequest | PlainMessage<CreateJobRequest> | undefined): boolean {
    return proto3.util.equals(CreateJobRequest, a, b);
  }
}

/**
 * Config that contains various timeouts that are configured in the underlying temporal workflow
 * More options will come in the future as needed
 *
 * @generated from message mgmt.v1alpha1.WorkflowOptions
 */
export class WorkflowOptions extends Message<WorkflowOptions> {
  /**
   * The timeout for a single workflow run.
   * Measured in seconds
   *
   * @generated from field: optional int64 run_timeout = 8;
   */
  runTimeout?: bigint;

  constructor(data?: PartialMessage<WorkflowOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.WorkflowOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "run_timeout", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowOptions {
    return new WorkflowOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowOptions {
    return new WorkflowOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowOptions {
    return new WorkflowOptions().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowOptions | PlainMessage<WorkflowOptions> | undefined, b: WorkflowOptions | PlainMessage<WorkflowOptions> | undefined): boolean {
    return proto3.util.equals(WorkflowOptions, a, b);
  }
}

/**
 * Config that contains various timeouts that are configured in the underlying temporal workflow(s) and activities
 *
 * @generated from message mgmt.v1alpha1.ActivityOptions
 */
export class ActivityOptions extends Message<ActivityOptions> {
  /**
   * Total time that a workflow is willing to wait for an activity to complete, including retries.
   * Measured in seconds
   *
   * @generated from field: optional int64 schedule_to_close_timeout = 1;
   */
  scheduleToCloseTimeout?: bigint;

  /**
   * Max time of a single Temporal Activity execution attempt.
   * This timeout should be as short as the longest psosible execution of any activity (e.g. table sync).
   * Important to know that this is per retry attempt. Defaults to the schedule to close timeout if not provided.
   * Measured in seconds
   *
   * @generated from field: optional int64 start_to_close_timeout = 2;
   */
  startToCloseTimeout?: bigint;

  /**
   * Optionally define a retry policy for the activity
   * If max attempts is not set, the activity will retry indefinitely until the start to close timeout lapses
   *
   * @generated from field: mgmt.v1alpha1.RetryPolicy retry_policy = 3;
   */
  retryPolicy?: RetryPolicy;

  constructor(data?: PartialMessage<ActivityOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ActivityOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedule_to_close_timeout", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 2, name: "start_to_close_timeout", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 3, name: "retry_policy", kind: "message", T: RetryPolicy },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivityOptions {
    return new ActivityOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivityOptions {
    return new ActivityOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivityOptions {
    return new ActivityOptions().fromJsonString(jsonString, options);
  }

  static equals(a: ActivityOptions | PlainMessage<ActivityOptions> | undefined, b: ActivityOptions | PlainMessage<ActivityOptions> | undefined): boolean {
    return proto3.util.equals(ActivityOptions, a, b);
  }
}

/**
 * Defines the retry policy for an activity
 *
 * @generated from message mgmt.v1alpha1.RetryPolicy
 */
export class RetryPolicy extends Message<RetryPolicy> {
  /**
   * Maximum number of attempts. When exceeded the retries stop even if not expired yet.
   * If not set or set to 0, it means unlimited, and rely on activity ScheduleToCloseTimeout to stop.
   *
   * @generated from field: optional int32 maximum_attempts = 1;
   */
  maximumAttempts?: number;

  constructor(data?: PartialMessage<RetryPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.RetryPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "maximum_attempts", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RetryPolicy {
    return new RetryPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RetryPolicy {
    return new RetryPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RetryPolicy {
    return new RetryPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: RetryPolicy | PlainMessage<RetryPolicy> | undefined, b: RetryPolicy | PlainMessage<RetryPolicy> | undefined): boolean {
    return proto3.util.equals(RetryPolicy, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobResponse
 */
export class CreateJobResponse extends Message<CreateJobResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<CreateJobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobResponse {
    return new CreateJobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobResponse {
    return new CreateJobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobResponse {
    return new CreateJobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobResponse | PlainMessage<CreateJobResponse> | undefined, b: CreateJobResponse | PlainMessage<CreateJobResponse> | undefined): boolean {
    return proto3.util.equals(CreateJobResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobMappingTransformer
 */
export class JobMappingTransformer extends Message<JobMappingTransformer> {
  /**
   * @deprecated - This is no longer used in favor just providing the TransformerConfig
   *
   * @generated from field: mgmt.v1alpha1.TransformerSource source = 1;
   */
  source = TransformerSource.UNSPECIFIED;

  /**
   * @generated from field: mgmt.v1alpha1.TransformerConfig config = 3;
   */
  config?: TransformerConfig;

  constructor(data?: PartialMessage<JobMappingTransformer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobMappingTransformer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source", kind: "enum", T: proto3.getEnumType(TransformerSource) },
    { no: 3, name: "config", kind: "message", T: TransformerConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobMappingTransformer {
    return new JobMappingTransformer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobMappingTransformer {
    return new JobMappingTransformer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobMappingTransformer {
    return new JobMappingTransformer().fromJsonString(jsonString, options);
  }

  static equals(a: JobMappingTransformer | PlainMessage<JobMappingTransformer> | undefined, b: JobMappingTransformer | PlainMessage<JobMappingTransformer> | undefined): boolean {
    return proto3.util.equals(JobMappingTransformer, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobMapping
 */
export class JobMapping extends Message<JobMapping> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: string table = 2;
   */
  table = "";

  /**
   * @generated from field: string column = 3;
   */
  column = "";

  /**
   * @generated from field: mgmt.v1alpha1.JobMappingTransformer transformer = 5;
   */
  transformer?: JobMappingTransformer;

  constructor(data?: PartialMessage<JobMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "transformer", kind: "message", T: JobMappingTransformer },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobMapping {
    return new JobMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobMapping {
    return new JobMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobMapping {
    return new JobMapping().fromJsonString(jsonString, options);
  }

  static equals(a: JobMapping | PlainMessage<JobMapping> | undefined, b: JobMapping | PlainMessage<JobMapping> | undefined): boolean {
    return proto3.util.equals(JobMapping, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRequest
 */
export class GetJobRequest extends Message<GetJobRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetJobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRequest {
    return new GetJobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRequest {
    return new GetJobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRequest {
    return new GetJobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRequest | PlainMessage<GetJobRequest> | undefined, b: GetJobRequest | PlainMessage<GetJobRequest> | undefined): boolean {
    return proto3.util.equals(GetJobRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobResponse
 */
export class GetJobResponse extends Message<GetJobResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<GetJobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobResponse {
    return new GetJobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobResponse {
    return new GetJobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobResponse {
    return new GetJobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobResponse | PlainMessage<GetJobResponse> | undefined, b: GetJobResponse | PlainMessage<GetJobResponse> | undefined): boolean {
    return proto3.util.equals(GetJobResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateJobScheduleRequest
 */
export class UpdateJobScheduleRequest extends Message<UpdateJobScheduleRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: optional string cron_schedule = 2;
   */
  cronSchedule?: string;

  constructor(data?: PartialMessage<UpdateJobScheduleRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateJobScheduleRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cron_schedule", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateJobScheduleRequest {
    return new UpdateJobScheduleRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateJobScheduleRequest {
    return new UpdateJobScheduleRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateJobScheduleRequest {
    return new UpdateJobScheduleRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateJobScheduleRequest | PlainMessage<UpdateJobScheduleRequest> | undefined, b: UpdateJobScheduleRequest | PlainMessage<UpdateJobScheduleRequest> | undefined): boolean {
    return proto3.util.equals(UpdateJobScheduleRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateJobScheduleResponse
 */
export class UpdateJobScheduleResponse extends Message<UpdateJobScheduleResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<UpdateJobScheduleResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateJobScheduleResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateJobScheduleResponse {
    return new UpdateJobScheduleResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateJobScheduleResponse {
    return new UpdateJobScheduleResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateJobScheduleResponse {
    return new UpdateJobScheduleResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateJobScheduleResponse | PlainMessage<UpdateJobScheduleResponse> | undefined, b: UpdateJobScheduleResponse | PlainMessage<UpdateJobScheduleResponse> | undefined): boolean {
    return proto3.util.equals(UpdateJobScheduleResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PauseJobRequest
 */
export class PauseJobRequest extends Message<PauseJobRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: bool pause = 2;
   */
  pause = false;

  /**
   * @generated from field: optional string note = 3;
   */
  note?: string;

  constructor(data?: PartialMessage<PauseJobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PauseJobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "pause", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "note", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PauseJobRequest {
    return new PauseJobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PauseJobRequest {
    return new PauseJobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PauseJobRequest {
    return new PauseJobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PauseJobRequest | PlainMessage<PauseJobRequest> | undefined, b: PauseJobRequest | PlainMessage<PauseJobRequest> | undefined): boolean {
    return proto3.util.equals(PauseJobRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PauseJobResponse
 */
export class PauseJobResponse extends Message<PauseJobResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<PauseJobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PauseJobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PauseJobResponse {
    return new PauseJobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PauseJobResponse {
    return new PauseJobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PauseJobResponse {
    return new PauseJobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PauseJobResponse | PlainMessage<PauseJobResponse> | undefined, b: PauseJobResponse | PlainMessage<PauseJobResponse> | undefined): boolean {
    return proto3.util.equals(PauseJobResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateJobSourceConnectionRequest
 */
export class UpdateJobSourceConnectionRequest extends Message<UpdateJobSourceConnectionRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: mgmt.v1alpha1.JobSource source = 2;
   */
  source?: JobSource;

  /**
   * @generated from field: repeated mgmt.v1alpha1.JobMapping mappings = 3;
   */
  mappings: JobMapping[] = [];

  /**
   * @generated from field: repeated mgmt.v1alpha1.VirtualForeignConstraint virtual_foreign_keys = 4;
   */
  virtualForeignKeys: VirtualForeignConstraint[] = [];

  constructor(data?: PartialMessage<UpdateJobSourceConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateJobSourceConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source", kind: "message", T: JobSource },
    { no: 3, name: "mappings", kind: "message", T: JobMapping, repeated: true },
    { no: 4, name: "virtual_foreign_keys", kind: "message", T: VirtualForeignConstraint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateJobSourceConnectionRequest {
    return new UpdateJobSourceConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateJobSourceConnectionRequest {
    return new UpdateJobSourceConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateJobSourceConnectionRequest {
    return new UpdateJobSourceConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateJobSourceConnectionRequest | PlainMessage<UpdateJobSourceConnectionRequest> | undefined, b: UpdateJobSourceConnectionRequest | PlainMessage<UpdateJobSourceConnectionRequest> | undefined): boolean {
    return proto3.util.equals(UpdateJobSourceConnectionRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateJobSourceConnectionResponse
 */
export class UpdateJobSourceConnectionResponse extends Message<UpdateJobSourceConnectionResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<UpdateJobSourceConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateJobSourceConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateJobSourceConnectionResponse {
    return new UpdateJobSourceConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateJobSourceConnectionResponse {
    return new UpdateJobSourceConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateJobSourceConnectionResponse {
    return new UpdateJobSourceConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateJobSourceConnectionResponse | PlainMessage<UpdateJobSourceConnectionResponse> | undefined, b: UpdateJobSourceConnectionResponse | PlainMessage<UpdateJobSourceConnectionResponse> | undefined): boolean {
    return proto3.util.equals(UpdateJobSourceConnectionResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresSourceSchemaSubset
 */
export class PostgresSourceSchemaSubset extends Message<PostgresSourceSchemaSubset> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.PostgresSourceSchemaOption postgres_schemas = 1;
   */
  postgresSchemas: PostgresSourceSchemaOption[] = [];

  constructor(data?: PartialMessage<PostgresSourceSchemaSubset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSourceSchemaSubset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "postgres_schemas", kind: "message", T: PostgresSourceSchemaOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSourceSchemaSubset {
    return new PostgresSourceSchemaSubset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSourceSchemaSubset {
    return new PostgresSourceSchemaSubset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSourceSchemaSubset {
    return new PostgresSourceSchemaSubset().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSourceSchemaSubset | PlainMessage<PostgresSourceSchemaSubset> | undefined, b: PostgresSourceSchemaSubset | PlainMessage<PostgresSourceSchemaSubset> | undefined): boolean {
    return proto3.util.equals(PostgresSourceSchemaSubset, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlSourceSchemaSubset
 */
export class MysqlSourceSchemaSubset extends Message<MysqlSourceSchemaSubset> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.MysqlSourceSchemaOption mysql_schemas = 1;
   */
  mysqlSchemas: MysqlSourceSchemaOption[] = [];

  constructor(data?: PartialMessage<MysqlSourceSchemaSubset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlSourceSchemaSubset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mysql_schemas", kind: "message", T: MysqlSourceSchemaOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlSourceSchemaSubset {
    return new MysqlSourceSchemaSubset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlSourceSchemaSubset {
    return new MysqlSourceSchemaSubset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlSourceSchemaSubset {
    return new MysqlSourceSchemaSubset().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlSourceSchemaSubset | PlainMessage<MysqlSourceSchemaSubset> | undefined, b: MysqlSourceSchemaSubset | PlainMessage<MysqlSourceSchemaSubset> | undefined): boolean {
    return proto3.util.equals(MysqlSourceSchemaSubset, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DynamoDBSourceSchemaSubset
 */
export class DynamoDBSourceSchemaSubset extends Message<DynamoDBSourceSchemaSubset> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.DynamoDBSourceTableOption tables = 1;
   */
  tables: DynamoDBSourceTableOption[] = [];

  constructor(data?: PartialMessage<DynamoDBSourceSchemaSubset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DynamoDBSourceSchemaSubset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tables", kind: "message", T: DynamoDBSourceTableOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamoDBSourceSchemaSubset {
    return new DynamoDBSourceSchemaSubset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamoDBSourceSchemaSubset {
    return new DynamoDBSourceSchemaSubset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamoDBSourceSchemaSubset {
    return new DynamoDBSourceSchemaSubset().fromJsonString(jsonString, options);
  }

  static equals(a: DynamoDBSourceSchemaSubset | PlainMessage<DynamoDBSourceSchemaSubset> | undefined, b: DynamoDBSourceSchemaSubset | PlainMessage<DynamoDBSourceSchemaSubset> | undefined): boolean {
    return proto3.util.equals(DynamoDBSourceSchemaSubset, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MssqlSourceSchemaSubset
 */
export class MssqlSourceSchemaSubset extends Message<MssqlSourceSchemaSubset> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.MssqlSourceSchemaOption mssql_schemas = 1;
   */
  mssqlSchemas: MssqlSourceSchemaOption[] = [];

  constructor(data?: PartialMessage<MssqlSourceSchemaSubset>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MssqlSourceSchemaSubset";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mssql_schemas", kind: "message", T: MssqlSourceSchemaOption, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MssqlSourceSchemaSubset {
    return new MssqlSourceSchemaSubset().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MssqlSourceSchemaSubset {
    return new MssqlSourceSchemaSubset().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MssqlSourceSchemaSubset {
    return new MssqlSourceSchemaSubset().fromJsonString(jsonString, options);
  }

  static equals(a: MssqlSourceSchemaSubset | PlainMessage<MssqlSourceSchemaSubset> | undefined, b: MssqlSourceSchemaSubset | PlainMessage<MssqlSourceSchemaSubset> | undefined): boolean {
    return proto3.util.equals(MssqlSourceSchemaSubset, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobSourceSqlSubetSchemas
 */
export class JobSourceSqlSubetSchemas extends Message<JobSourceSqlSubetSchemas> {
  /**
   * @generated from oneof mgmt.v1alpha1.JobSourceSqlSubetSchemas.schemas
   */
  schemas: {
    /**
     * @generated from field: mgmt.v1alpha1.PostgresSourceSchemaSubset postgres_subset = 2;
     */
    value: PostgresSourceSchemaSubset;
    case: "postgresSubset";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MysqlSourceSchemaSubset mysql_subset = 3;
     */
    value: MysqlSourceSchemaSubset;
    case: "mysqlSubset";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.DynamoDBSourceSchemaSubset dynamodb_subset = 4;
     */
    value: DynamoDBSourceSchemaSubset;
    case: "dynamodbSubset";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MssqlSourceSchemaSubset mssql_subset = 5;
     */
    value: MssqlSourceSchemaSubset;
    case: "mssqlSubset";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<JobSourceSqlSubetSchemas>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobSourceSqlSubetSchemas";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "postgres_subset", kind: "message", T: PostgresSourceSchemaSubset, oneof: "schemas" },
    { no: 3, name: "mysql_subset", kind: "message", T: MysqlSourceSchemaSubset, oneof: "schemas" },
    { no: 4, name: "dynamodb_subset", kind: "message", T: DynamoDBSourceSchemaSubset, oneof: "schemas" },
    { no: 5, name: "mssql_subset", kind: "message", T: MssqlSourceSchemaSubset, oneof: "schemas" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobSourceSqlSubetSchemas {
    return new JobSourceSqlSubetSchemas().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobSourceSqlSubetSchemas {
    return new JobSourceSqlSubetSchemas().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobSourceSqlSubetSchemas {
    return new JobSourceSqlSubetSchemas().fromJsonString(jsonString, options);
  }

  static equals(a: JobSourceSqlSubetSchemas | PlainMessage<JobSourceSqlSubetSchemas> | undefined, b: JobSourceSqlSubetSchemas | PlainMessage<JobSourceSqlSubetSchemas> | undefined): boolean {
    return proto3.util.equals(JobSourceSqlSubetSchemas, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetJobSourceSqlConnectionSubsetsRequest
 */
export class SetJobSourceSqlConnectionSubsetsRequest extends Message<SetJobSourceSqlConnectionSubsetsRequest> {
  /**
   * The unique identifier of the job to update subsets for
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The subset configuration
   *
   * @generated from field: mgmt.v1alpha1.JobSourceSqlSubetSchemas schemas = 2;
   */
  schemas?: JobSourceSqlSubetSchemas;

  /**
   * Whether or not to have subsets follow foreign key constraints (for connections that support it)
   *
   * @generated from field: bool subset_by_foreign_key_constraints = 3;
   */
  subsetByForeignKeyConstraints = false;

  constructor(data?: PartialMessage<SetJobSourceSqlConnectionSubsetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetJobSourceSqlConnectionSubsetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schemas", kind: "message", T: JobSourceSqlSubetSchemas },
    { no: 3, name: "subset_by_foreign_key_constraints", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetJobSourceSqlConnectionSubsetsRequest {
    return new SetJobSourceSqlConnectionSubsetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetJobSourceSqlConnectionSubsetsRequest {
    return new SetJobSourceSqlConnectionSubsetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetJobSourceSqlConnectionSubsetsRequest {
    return new SetJobSourceSqlConnectionSubsetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetJobSourceSqlConnectionSubsetsRequest | PlainMessage<SetJobSourceSqlConnectionSubsetsRequest> | undefined, b: SetJobSourceSqlConnectionSubsetsRequest | PlainMessage<SetJobSourceSqlConnectionSubsetsRequest> | undefined): boolean {
    return proto3.util.equals(SetJobSourceSqlConnectionSubsetsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetJobSourceSqlConnectionSubsetsResponse
 */
export class SetJobSourceSqlConnectionSubsetsResponse extends Message<SetJobSourceSqlConnectionSubsetsResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<SetJobSourceSqlConnectionSubsetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetJobSourceSqlConnectionSubsetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetJobSourceSqlConnectionSubsetsResponse {
    return new SetJobSourceSqlConnectionSubsetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetJobSourceSqlConnectionSubsetsResponse {
    return new SetJobSourceSqlConnectionSubsetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetJobSourceSqlConnectionSubsetsResponse {
    return new SetJobSourceSqlConnectionSubsetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetJobSourceSqlConnectionSubsetsResponse | PlainMessage<SetJobSourceSqlConnectionSubsetsResponse> | undefined, b: SetJobSourceSqlConnectionSubsetsResponse | PlainMessage<SetJobSourceSqlConnectionSubsetsResponse> | undefined): boolean {
    return proto3.util.equals(SetJobSourceSqlConnectionSubsetsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateJobDestinationConnectionRequest
 */
export class UpdateJobDestinationConnectionRequest extends Message<UpdateJobDestinationConnectionRequest> {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  /**
   * @generated from field: string connection_id = 2;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.JobDestinationOptions options = 3;
   */
  options?: JobDestinationOptions;

  /**
   * @generated from field: string destination_id = 4;
   */
  destinationId = "";

  constructor(data?: PartialMessage<UpdateJobDestinationConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateJobDestinationConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "options", kind: "message", T: JobDestinationOptions },
    { no: 4, name: "destination_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateJobDestinationConnectionRequest {
    return new UpdateJobDestinationConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateJobDestinationConnectionRequest {
    return new UpdateJobDestinationConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateJobDestinationConnectionRequest {
    return new UpdateJobDestinationConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateJobDestinationConnectionRequest | PlainMessage<UpdateJobDestinationConnectionRequest> | undefined, b: UpdateJobDestinationConnectionRequest | PlainMessage<UpdateJobDestinationConnectionRequest> | undefined): boolean {
    return proto3.util.equals(UpdateJobDestinationConnectionRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateJobDestinationConnectionResponse
 */
export class UpdateJobDestinationConnectionResponse extends Message<UpdateJobDestinationConnectionResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<UpdateJobDestinationConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateJobDestinationConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateJobDestinationConnectionResponse {
    return new UpdateJobDestinationConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateJobDestinationConnectionResponse {
    return new UpdateJobDestinationConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateJobDestinationConnectionResponse {
    return new UpdateJobDestinationConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateJobDestinationConnectionResponse | PlainMessage<UpdateJobDestinationConnectionResponse> | undefined, b: UpdateJobDestinationConnectionResponse | PlainMessage<UpdateJobDestinationConnectionResponse> | undefined): boolean {
    return proto3.util.equals(UpdateJobDestinationConnectionResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteJobDestinationConnectionRequest
 */
export class DeleteJobDestinationConnectionRequest extends Message<DeleteJobDestinationConnectionRequest> {
  /**
   * @generated from field: string destination_id = 1;
   */
  destinationId = "";

  constructor(data?: PartialMessage<DeleteJobDestinationConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteJobDestinationConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "destination_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteJobDestinationConnectionRequest {
    return new DeleteJobDestinationConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteJobDestinationConnectionRequest {
    return new DeleteJobDestinationConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteJobDestinationConnectionRequest {
    return new DeleteJobDestinationConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteJobDestinationConnectionRequest | PlainMessage<DeleteJobDestinationConnectionRequest> | undefined, b: DeleteJobDestinationConnectionRequest | PlainMessage<DeleteJobDestinationConnectionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteJobDestinationConnectionRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteJobDestinationConnectionResponse
 */
export class DeleteJobDestinationConnectionResponse extends Message<DeleteJobDestinationConnectionResponse> {
  constructor(data?: PartialMessage<DeleteJobDestinationConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteJobDestinationConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteJobDestinationConnectionResponse {
    return new DeleteJobDestinationConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteJobDestinationConnectionResponse {
    return new DeleteJobDestinationConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteJobDestinationConnectionResponse {
    return new DeleteJobDestinationConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteJobDestinationConnectionResponse | PlainMessage<DeleteJobDestinationConnectionResponse> | undefined, b: DeleteJobDestinationConnectionResponse | PlainMessage<DeleteJobDestinationConnectionResponse> | undefined): boolean {
    return proto3.util.equals(DeleteJobDestinationConnectionResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobDestinationConnectionsRequest
 */
export class CreateJobDestinationConnectionsRequest extends Message<CreateJobDestinationConnectionsRequest> {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  /**
   * @generated from field: repeated mgmt.v1alpha1.CreateJobDestination destinations = 2;
   */
  destinations: CreateJobDestination[] = [];

  constructor(data?: PartialMessage<CreateJobDestinationConnectionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobDestinationConnectionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "destinations", kind: "message", T: CreateJobDestination, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobDestinationConnectionsRequest {
    return new CreateJobDestinationConnectionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobDestinationConnectionsRequest {
    return new CreateJobDestinationConnectionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobDestinationConnectionsRequest {
    return new CreateJobDestinationConnectionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobDestinationConnectionsRequest | PlainMessage<CreateJobDestinationConnectionsRequest> | undefined, b: CreateJobDestinationConnectionsRequest | PlainMessage<CreateJobDestinationConnectionsRequest> | undefined): boolean {
    return proto3.util.equals(CreateJobDestinationConnectionsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobDestinationConnectionsResponse
 */
export class CreateJobDestinationConnectionsResponse extends Message<CreateJobDestinationConnectionsResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<CreateJobDestinationConnectionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobDestinationConnectionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobDestinationConnectionsResponse {
    return new CreateJobDestinationConnectionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobDestinationConnectionsResponse {
    return new CreateJobDestinationConnectionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobDestinationConnectionsResponse {
    return new CreateJobDestinationConnectionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobDestinationConnectionsResponse | PlainMessage<CreateJobDestinationConnectionsResponse> | undefined, b: CreateJobDestinationConnectionsResponse | PlainMessage<CreateJobDestinationConnectionsResponse> | undefined): boolean {
    return proto3.util.equals(CreateJobDestinationConnectionsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteJobRequest
 */
export class DeleteJobRequest extends Message<DeleteJobRequest> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteJobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteJobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteJobRequest {
    return new DeleteJobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteJobRequest {
    return new DeleteJobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteJobRequest {
    return new DeleteJobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteJobRequest | PlainMessage<DeleteJobRequest> | undefined, b: DeleteJobRequest | PlainMessage<DeleteJobRequest> | undefined): boolean {
    return proto3.util.equals(DeleteJobRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteJobResponse
 */
export class DeleteJobResponse extends Message<DeleteJobResponse> {
  constructor(data?: PartialMessage<DeleteJobResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteJobResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteJobResponse {
    return new DeleteJobResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteJobResponse {
    return new DeleteJobResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteJobResponse {
    return new DeleteJobResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteJobResponse | PlainMessage<DeleteJobResponse> | undefined, b: DeleteJobResponse | PlainMessage<DeleteJobResponse> | undefined): boolean {
    return proto3.util.equals(DeleteJobResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.IsJobNameAvailableRequest
 */
export class IsJobNameAvailableRequest extends Message<IsJobNameAvailableRequest> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string account_id = 2;
   */
  accountId = "";

  constructor(data?: PartialMessage<IsJobNameAvailableRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.IsJobNameAvailableRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsJobNameAvailableRequest {
    return new IsJobNameAvailableRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsJobNameAvailableRequest {
    return new IsJobNameAvailableRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsJobNameAvailableRequest {
    return new IsJobNameAvailableRequest().fromJsonString(jsonString, options);
  }

  static equals(a: IsJobNameAvailableRequest | PlainMessage<IsJobNameAvailableRequest> | undefined, b: IsJobNameAvailableRequest | PlainMessage<IsJobNameAvailableRequest> | undefined): boolean {
    return proto3.util.equals(IsJobNameAvailableRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.IsJobNameAvailableResponse
 */
export class IsJobNameAvailableResponse extends Message<IsJobNameAvailableResponse> {
  /**
   * @generated from field: bool is_available = 1;
   */
  isAvailable = false;

  constructor(data?: PartialMessage<IsJobNameAvailableResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.IsJobNameAvailableResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_available", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsJobNameAvailableResponse {
    return new IsJobNameAvailableResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsJobNameAvailableResponse {
    return new IsJobNameAvailableResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsJobNameAvailableResponse {
    return new IsJobNameAvailableResponse().fromJsonString(jsonString, options);
  }

  static equals(a: IsJobNameAvailableResponse | PlainMessage<IsJobNameAvailableResponse> | undefined, b: IsJobNameAvailableResponse | PlainMessage<IsJobNameAvailableResponse> | undefined): boolean {
    return proto3.util.equals(IsJobNameAvailableResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRunsRequest
 */
export class GetJobRunsRequest extends Message<GetJobRunsRequest> {
  /**
   * @generated from oneof mgmt.v1alpha1.GetJobRunsRequest.id
   */
  id: {
    /**
     * @generated from field: string job_id = 1;
     */
    value: string;
    case: "jobId";
  } | {
    /**
     * @generated from field: string account_id = 2;
     */
    value: string;
    case: "accountId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetJobRunsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRunsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
    { no: 2, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRunsRequest {
    return new GetJobRunsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRunsRequest {
    return new GetJobRunsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRunsRequest {
    return new GetJobRunsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRunsRequest | PlainMessage<GetJobRunsRequest> | undefined, b: GetJobRunsRequest | PlainMessage<GetJobRunsRequest> | undefined): boolean {
    return proto3.util.equals(GetJobRunsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRunsResponse
 */
export class GetJobRunsResponse extends Message<GetJobRunsResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.JobRun job_runs = 1;
   */
  jobRuns: JobRun[] = [];

  constructor(data?: PartialMessage<GetJobRunsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRunsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_runs", kind: "message", T: JobRun, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRunsResponse {
    return new GetJobRunsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRunsResponse {
    return new GetJobRunsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRunsResponse {
    return new GetJobRunsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRunsResponse | PlainMessage<GetJobRunsResponse> | undefined, b: GetJobRunsResponse | PlainMessage<GetJobRunsResponse> | undefined): boolean {
    return proto3.util.equals(GetJobRunsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRunRequest
 */
export class GetJobRunRequest extends Message<GetJobRunRequest> {
  /**
   * @generated from field: string job_run_id = 1;
   */
  jobRunId = "";

  /**
   * @generated from field: string account_id = 2;
   */
  accountId = "";

  constructor(data?: PartialMessage<GetJobRunRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRunRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRunRequest {
    return new GetJobRunRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRunRequest {
    return new GetJobRunRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRunRequest {
    return new GetJobRunRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRunRequest | PlainMessage<GetJobRunRequest> | undefined, b: GetJobRunRequest | PlainMessage<GetJobRunRequest> | undefined): boolean {
    return proto3.util.equals(GetJobRunRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRunResponse
 */
export class GetJobRunResponse extends Message<GetJobRunResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.JobRun job_run = 1;
   */
  jobRun?: JobRun;

  constructor(data?: PartialMessage<GetJobRunResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRunResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_run", kind: "message", T: JobRun },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRunResponse {
    return new GetJobRunResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRunResponse {
    return new GetJobRunResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRunResponse {
    return new GetJobRunResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRunResponse | PlainMessage<GetJobRunResponse> | undefined, b: GetJobRunResponse | PlainMessage<GetJobRunResponse> | undefined): boolean {
    return proto3.util.equals(GetJobRunResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobRunRequest
 */
export class CreateJobRunRequest extends Message<CreateJobRunRequest> {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  constructor(data?: PartialMessage<CreateJobRunRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobRunRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobRunRequest {
    return new CreateJobRunRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobRunRequest {
    return new CreateJobRunRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobRunRequest {
    return new CreateJobRunRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobRunRequest | PlainMessage<CreateJobRunRequest> | undefined, b: CreateJobRunRequest | PlainMessage<CreateJobRunRequest> | undefined): boolean {
    return proto3.util.equals(CreateJobRunRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobRunResponse
 */
export class CreateJobRunResponse extends Message<CreateJobRunResponse> {
  constructor(data?: PartialMessage<CreateJobRunResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobRunResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobRunResponse {
    return new CreateJobRunResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobRunResponse {
    return new CreateJobRunResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobRunResponse {
    return new CreateJobRunResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobRunResponse | PlainMessage<CreateJobRunResponse> | undefined, b: CreateJobRunResponse | PlainMessage<CreateJobRunResponse> | undefined): boolean {
    return proto3.util.equals(CreateJobRunResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CancelJobRunRequest
 */
export class CancelJobRunRequest extends Message<CancelJobRunRequest> {
  /**
   * @generated from field: string job_run_id = 1;
   */
  jobRunId = "";

  /**
   * @generated from field: string account_id = 2;
   */
  accountId = "";

  constructor(data?: PartialMessage<CancelJobRunRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CancelJobRunRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelJobRunRequest {
    return new CancelJobRunRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelJobRunRequest {
    return new CancelJobRunRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelJobRunRequest {
    return new CancelJobRunRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CancelJobRunRequest | PlainMessage<CancelJobRunRequest> | undefined, b: CancelJobRunRequest | PlainMessage<CancelJobRunRequest> | undefined): boolean {
    return proto3.util.equals(CancelJobRunRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CancelJobRunResponse
 */
export class CancelJobRunResponse extends Message<CancelJobRunResponse> {
  constructor(data?: PartialMessage<CancelJobRunResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CancelJobRunResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelJobRunResponse {
    return new CancelJobRunResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelJobRunResponse {
    return new CancelJobRunResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelJobRunResponse {
    return new CancelJobRunResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CancelJobRunResponse | PlainMessage<CancelJobRunResponse> | undefined, b: CancelJobRunResponse | PlainMessage<CancelJobRunResponse> | undefined): boolean {
    return proto3.util.equals(CancelJobRunResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.Job
 */
export class Job extends Message<Job> {
  /**
   * The unique identifier of the job
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string created_by_user_id = 2;
   */
  createdByUserId = "";

  /**
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * @generated from field: string updated_by_user_id = 4;
   */
  updatedByUserId = "";

  /**
   * @generated from field: google.protobuf.Timestamp updated_at = 5;
   */
  updatedAt?: Timestamp;

  /**
   * The unique, friendly name of the job
   *
   * @generated from field: string name = 6;
   */
  name = "";

  /**
   * @generated from field: mgmt.v1alpha1.JobSource source = 7;
   */
  source?: JobSource;

  /**
   * @generated from field: repeated mgmt.v1alpha1.JobDestination destinations = 8;
   */
  destinations: JobDestination[] = [];

  /**
   * @generated from field: repeated mgmt.v1alpha1.JobMapping mappings = 9;
   */
  mappings: JobMapping[] = [];

  /**
   * @generated from field: optional string cron_schedule = 10;
   */
  cronSchedule?: string;

  /**
   * The account identifier that a job is associated with
   *
   * @generated from field: string account_id = 11;
   */
  accountId = "";

  /**
   * Specify timeout and retry options for data synchronization activities
   * Data sync activities are any piece of work that involves actually synchronizing data from a source to a destination
   * For the data sync and generate jobs, this will be applied per table
   *
   * @generated from field: mgmt.v1alpha1.ActivityOptions sync_options = 12;
   */
  syncOptions?: ActivityOptions;

  /**
   * Specify timeouts and other workflow options for the underlying temporal workflow
   *
   * @generated from field: mgmt.v1alpha1.WorkflowOptions workflow_options = 13;
   */
  workflowOptions?: WorkflowOptions;

  /**
   * Any virtual foreign keys that are configured as a part of this job
   *
   * @generated from field: repeated mgmt.v1alpha1.VirtualForeignConstraint virtual_foreign_keys = 14;
   */
  virtualForeignKeys: VirtualForeignConstraint[] = [];

  constructor(data?: PartialMessage<Job>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.Job";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "created_by_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "updated_by_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "updated_at", kind: "message", T: Timestamp },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "source", kind: "message", T: JobSource },
    { no: 8, name: "destinations", kind: "message", T: JobDestination, repeated: true },
    { no: 9, name: "mappings", kind: "message", T: JobMapping, repeated: true },
    { no: 10, name: "cron_schedule", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 11, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "sync_options", kind: "message", T: ActivityOptions },
    { no: 13, name: "workflow_options", kind: "message", T: WorkflowOptions },
    { no: 14, name: "virtual_foreign_keys", kind: "message", T: VirtualForeignConstraint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Job {
    return new Job().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Job {
    return new Job().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Job {
    return new Job().fromJsonString(jsonString, options);
  }

  static equals(a: Job | PlainMessage<Job> | undefined, b: Job | PlainMessage<Job> | undefined): boolean {
    return proto3.util.equals(Job, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobRecentRun
 */
export class JobRecentRun extends Message<JobRecentRun> {
  /**
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: string job_run_id = 2;
   */
  jobRunId = "";

  constructor(data?: PartialMessage<JobRecentRun>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobRecentRun";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_time", kind: "message", T: Timestamp },
    { no: 2, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobRecentRun {
    return new JobRecentRun().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobRecentRun {
    return new JobRecentRun().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobRecentRun {
    return new JobRecentRun().fromJsonString(jsonString, options);
  }

  static equals(a: JobRecentRun | PlainMessage<JobRecentRun> | undefined, b: JobRecentRun | PlainMessage<JobRecentRun> | undefined): boolean {
    return proto3.util.equals(JobRecentRun, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRecentRunsRequest
 */
export class GetJobRecentRunsRequest extends Message<GetJobRecentRunsRequest> {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  constructor(data?: PartialMessage<GetJobRecentRunsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRecentRunsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRecentRunsRequest {
    return new GetJobRecentRunsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRecentRunsRequest {
    return new GetJobRecentRunsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRecentRunsRequest {
    return new GetJobRecentRunsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRecentRunsRequest | PlainMessage<GetJobRecentRunsRequest> | undefined, b: GetJobRecentRunsRequest | PlainMessage<GetJobRecentRunsRequest> | undefined): boolean {
    return proto3.util.equals(GetJobRecentRunsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRecentRunsResponse
 */
export class GetJobRecentRunsResponse extends Message<GetJobRecentRunsResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.JobRecentRun recent_runs = 1;
   */
  recentRuns: JobRecentRun[] = [];

  constructor(data?: PartialMessage<GetJobRecentRunsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRecentRunsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "recent_runs", kind: "message", T: JobRecentRun, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRecentRunsResponse {
    return new GetJobRecentRunsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRecentRunsResponse {
    return new GetJobRecentRunsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRecentRunsResponse {
    return new GetJobRecentRunsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRecentRunsResponse | PlainMessage<GetJobRecentRunsResponse> | undefined, b: GetJobRecentRunsResponse | PlainMessage<GetJobRecentRunsResponse> | undefined): boolean {
    return proto3.util.equals(GetJobRecentRunsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobNextRuns
 */
export class JobNextRuns extends Message<JobNextRuns> {
  /**
   * @generated from field: repeated google.protobuf.Timestamp next_run_times = 1;
   */
  nextRunTimes: Timestamp[] = [];

  constructor(data?: PartialMessage<JobNextRuns>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobNextRuns";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_run_times", kind: "message", T: Timestamp, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobNextRuns {
    return new JobNextRuns().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobNextRuns {
    return new JobNextRuns().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobNextRuns {
    return new JobNextRuns().fromJsonString(jsonString, options);
  }

  static equals(a: JobNextRuns | PlainMessage<JobNextRuns> | undefined, b: JobNextRuns | PlainMessage<JobNextRuns> | undefined): boolean {
    return proto3.util.equals(JobNextRuns, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobNextRunsRequest
 */
export class GetJobNextRunsRequest extends Message<GetJobNextRunsRequest> {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  constructor(data?: PartialMessage<GetJobNextRunsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobNextRunsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobNextRunsRequest {
    return new GetJobNextRunsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobNextRunsRequest {
    return new GetJobNextRunsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobNextRunsRequest {
    return new GetJobNextRunsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobNextRunsRequest | PlainMessage<GetJobNextRunsRequest> | undefined, b: GetJobNextRunsRequest | PlainMessage<GetJobNextRunsRequest> | undefined): boolean {
    return proto3.util.equals(GetJobNextRunsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobNextRunsResponse
 */
export class GetJobNextRunsResponse extends Message<GetJobNextRunsResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.JobNextRuns next_runs = 1;
   */
  nextRuns?: JobNextRuns;

  constructor(data?: PartialMessage<GetJobNextRunsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobNextRunsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "next_runs", kind: "message", T: JobNextRuns },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobNextRunsResponse {
    return new GetJobNextRunsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobNextRunsResponse {
    return new GetJobNextRunsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobNextRunsResponse {
    return new GetJobNextRunsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobNextRunsResponse | PlainMessage<GetJobNextRunsResponse> | undefined, b: GetJobNextRunsResponse | PlainMessage<GetJobNextRunsResponse> | undefined): boolean {
    return proto3.util.equals(GetJobNextRunsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobStatusRequest
 */
export class GetJobStatusRequest extends Message<GetJobStatusRequest> {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  constructor(data?: PartialMessage<GetJobStatusRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobStatusRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobStatusRequest {
    return new GetJobStatusRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobStatusRequest {
    return new GetJobStatusRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobStatusRequest {
    return new GetJobStatusRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobStatusRequest | PlainMessage<GetJobStatusRequest> | undefined, b: GetJobStatusRequest | PlainMessage<GetJobStatusRequest> | undefined): boolean {
    return proto3.util.equals(GetJobStatusRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobStatusResponse
 */
export class GetJobStatusResponse extends Message<GetJobStatusResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.JobStatus status = 1;
   */
  status = JobStatus.UNSPECIFIED;

  constructor(data?: PartialMessage<GetJobStatusResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobStatusResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(JobStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobStatusResponse {
    return new GetJobStatusResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobStatusResponse {
    return new GetJobStatusResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobStatusResponse {
    return new GetJobStatusResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobStatusResponse | PlainMessage<GetJobStatusResponse> | undefined, b: GetJobStatusResponse | PlainMessage<GetJobStatusResponse> | undefined): boolean {
    return proto3.util.equals(GetJobStatusResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobStatusRecord
 */
export class JobStatusRecord extends Message<JobStatusRecord> {
  /**
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  /**
   * @generated from field: mgmt.v1alpha1.JobStatus status = 2;
   */
  status = JobStatus.UNSPECIFIED;

  constructor(data?: PartialMessage<JobStatusRecord>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobStatusRecord";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(JobStatus) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobStatusRecord {
    return new JobStatusRecord().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobStatusRecord {
    return new JobStatusRecord().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobStatusRecord {
    return new JobStatusRecord().fromJsonString(jsonString, options);
  }

  static equals(a: JobStatusRecord | PlainMessage<JobStatusRecord> | undefined, b: JobStatusRecord | PlainMessage<JobStatusRecord> | undefined): boolean {
    return proto3.util.equals(JobStatusRecord, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobStatusesRequest
 */
export class GetJobStatusesRequest extends Message<GetJobStatusesRequest> {
  /**
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  constructor(data?: PartialMessage<GetJobStatusesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobStatusesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobStatusesRequest {
    return new GetJobStatusesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobStatusesRequest {
    return new GetJobStatusesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobStatusesRequest {
    return new GetJobStatusesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobStatusesRequest | PlainMessage<GetJobStatusesRequest> | undefined, b: GetJobStatusesRequest | PlainMessage<GetJobStatusesRequest> | undefined): boolean {
    return proto3.util.equals(GetJobStatusesRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobStatusesResponse
 */
export class GetJobStatusesResponse extends Message<GetJobStatusesResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.JobStatusRecord statuses = 1;
   */
  statuses: JobStatusRecord[] = [];

  constructor(data?: PartialMessage<GetJobStatusesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobStatusesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statuses", kind: "message", T: JobStatusRecord, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobStatusesResponse {
    return new GetJobStatusesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobStatusesResponse {
    return new GetJobStatusesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobStatusesResponse {
    return new GetJobStatusesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobStatusesResponse | PlainMessage<GetJobStatusesResponse> | undefined, b: GetJobStatusesResponse | PlainMessage<GetJobStatusesResponse> | undefined): boolean {
    return proto3.util.equals(GetJobStatusesResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ActivityFailure
 */
export class ActivityFailure extends Message<ActivityFailure> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<ActivityFailure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ActivityFailure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActivityFailure {
    return new ActivityFailure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActivityFailure {
    return new ActivityFailure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActivityFailure {
    return new ActivityFailure().fromJsonString(jsonString, options);
  }

  static equals(a: ActivityFailure | PlainMessage<ActivityFailure> | undefined, b: ActivityFailure | PlainMessage<ActivityFailure> | undefined): boolean {
    return proto3.util.equals(ActivityFailure, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PendingActivity
 */
export class PendingActivity extends Message<PendingActivity> {
  /**
   * @generated from field: mgmt.v1alpha1.ActivityStatus status = 1;
   */
  status = ActivityStatus.UNSPECIFIED;

  /**
   * @generated from field: string activity_name = 2;
   */
  activityName = "";

  /**
   * @generated from field: optional mgmt.v1alpha1.ActivityFailure last_failure = 3;
   */
  lastFailure?: ActivityFailure;

  constructor(data?: PartialMessage<PendingActivity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PendingActivity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "enum", T: proto3.getEnumType(ActivityStatus) },
    { no: 2, name: "activity_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "last_failure", kind: "message", T: ActivityFailure, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PendingActivity {
    return new PendingActivity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PendingActivity {
    return new PendingActivity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PendingActivity {
    return new PendingActivity().fromJsonString(jsonString, options);
  }

  static equals(a: PendingActivity | PlainMessage<PendingActivity> | undefined, b: PendingActivity | PlainMessage<PendingActivity> | undefined): boolean {
    return proto3.util.equals(PendingActivity, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobRun
 */
export class JobRun extends Message<JobRun> {
  /**
   * The id of the job run. This will currently be equivalent to the temporal workflow id
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The unique identifier of the job id this run is associated with
   *
   * @generated from field: string job_id = 2;
   */
  jobId = "";

  /**
   * The name of the job run.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * the status of the job run
   *
   * @generated from field: mgmt.v1alpha1.JobRunStatus status = 4;
   */
  status = JobRunStatus.UNSPECIFIED;

  /**
   * A timestamp of when the run started
   *
   * @generated from field: google.protobuf.Timestamp started_at = 6;
   */
  startedAt?: Timestamp;

  /**
   * Available if the run completed or has not yet been archived by the system
   *
   * @generated from field: optional google.protobuf.Timestamp completed_at = 7;
   */
  completedAt?: Timestamp;

  /**
   * Pending activities are only returned when retrieving a specific job run and will not be returned when requesting job runs in list format
   *
   * @generated from field: repeated mgmt.v1alpha1.PendingActivity pending_activities = 8;
   */
  pendingActivities: PendingActivity[] = [];

  constructor(data?: PartialMessage<JobRun>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobRun";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "status", kind: "enum", T: proto3.getEnumType(JobRunStatus) },
    { no: 6, name: "started_at", kind: "message", T: Timestamp },
    { no: 7, name: "completed_at", kind: "message", T: Timestamp, opt: true },
    { no: 8, name: "pending_activities", kind: "message", T: PendingActivity, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobRun {
    return new JobRun().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobRun {
    return new JobRun().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobRun {
    return new JobRun().fromJsonString(jsonString, options);
  }

  static equals(a: JobRun | PlainMessage<JobRun> | undefined, b: JobRun | PlainMessage<JobRun> | undefined): boolean {
    return proto3.util.equals(JobRun, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobRunEventTaskError
 */
export class JobRunEventTaskError extends Message<JobRunEventTaskError> {
  /**
   * @generated from field: string message = 1;
   */
  message = "";

  /**
   * @generated from field: string retry_state = 2;
   */
  retryState = "";

  constructor(data?: PartialMessage<JobRunEventTaskError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobRunEventTaskError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "retry_state", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobRunEventTaskError {
    return new JobRunEventTaskError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobRunEventTaskError {
    return new JobRunEventTaskError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobRunEventTaskError {
    return new JobRunEventTaskError().fromJsonString(jsonString, options);
  }

  static equals(a: JobRunEventTaskError | PlainMessage<JobRunEventTaskError> | undefined, b: JobRunEventTaskError | PlainMessage<JobRunEventTaskError> | undefined): boolean {
    return proto3.util.equals(JobRunEventTaskError, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobRunEventTask
 */
export class JobRunEventTask extends Message<JobRunEventTask> {
  /**
   * @generated from field: int64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: google.protobuf.Timestamp event_time = 3;
   */
  eventTime?: Timestamp;

  /**
   * @generated from field: mgmt.v1alpha1.JobRunEventTaskError error = 4;
   */
  error?: JobRunEventTaskError;

  constructor(data?: PartialMessage<JobRunEventTask>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobRunEventTask";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "event_time", kind: "message", T: Timestamp },
    { no: 4, name: "error", kind: "message", T: JobRunEventTaskError },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobRunEventTask {
    return new JobRunEventTask().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobRunEventTask {
    return new JobRunEventTask().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobRunEventTask {
    return new JobRunEventTask().fromJsonString(jsonString, options);
  }

  static equals(a: JobRunEventTask | PlainMessage<JobRunEventTask> | undefined, b: JobRunEventTask | PlainMessage<JobRunEventTask> | undefined): boolean {
    return proto3.util.equals(JobRunEventTask, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobRunSyncMetadata
 */
export class JobRunSyncMetadata extends Message<JobRunSyncMetadata> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: string table = 2;
   */
  table = "";

  constructor(data?: PartialMessage<JobRunSyncMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobRunSyncMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobRunSyncMetadata {
    return new JobRunSyncMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobRunSyncMetadata {
    return new JobRunSyncMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobRunSyncMetadata {
    return new JobRunSyncMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: JobRunSyncMetadata | PlainMessage<JobRunSyncMetadata> | undefined, b: JobRunSyncMetadata | PlainMessage<JobRunSyncMetadata> | undefined): boolean {
    return proto3.util.equals(JobRunSyncMetadata, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobRunEventMetadata
 */
export class JobRunEventMetadata extends Message<JobRunEventMetadata> {
  /**
   * @generated from oneof mgmt.v1alpha1.JobRunEventMetadata.metadata
   */
  metadata: {
    /**
     * @generated from field: mgmt.v1alpha1.JobRunSyncMetadata sync_metadata = 1;
     */
    value: JobRunSyncMetadata;
    case: "syncMetadata";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<JobRunEventMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobRunEventMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sync_metadata", kind: "message", T: JobRunSyncMetadata, oneof: "metadata" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobRunEventMetadata {
    return new JobRunEventMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobRunEventMetadata {
    return new JobRunEventMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobRunEventMetadata {
    return new JobRunEventMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: JobRunEventMetadata | PlainMessage<JobRunEventMetadata> | undefined, b: JobRunEventMetadata | PlainMessage<JobRunEventMetadata> | undefined): boolean {
    return proto3.util.equals(JobRunEventMetadata, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobRunEvent
 */
export class JobRunEvent extends Message<JobRunEvent> {
  /**
   * @generated from field: int64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * @generated from field: string type = 2;
   */
  type = "";

  /**
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp close_time = 4;
   */
  closeTime?: Timestamp;

  /**
   * @generated from field: mgmt.v1alpha1.JobRunEventMetadata metadata = 5;
   */
  metadata?: JobRunEventMetadata;

  /**
   * @generated from field: repeated mgmt.v1alpha1.JobRunEventTask tasks = 6;
   */
  tasks: JobRunEventTask[] = [];

  constructor(data?: PartialMessage<JobRunEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobRunEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "start_time", kind: "message", T: Timestamp },
    { no: 4, name: "close_time", kind: "message", T: Timestamp },
    { no: 5, name: "metadata", kind: "message", T: JobRunEventMetadata },
    { no: 6, name: "tasks", kind: "message", T: JobRunEventTask, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobRunEvent {
    return new JobRunEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobRunEvent {
    return new JobRunEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobRunEvent {
    return new JobRunEvent().fromJsonString(jsonString, options);
  }

  static equals(a: JobRunEvent | PlainMessage<JobRunEvent> | undefined, b: JobRunEvent | PlainMessage<JobRunEvent> | undefined): boolean {
    return proto3.util.equals(JobRunEvent, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRunEventsRequest
 */
export class GetJobRunEventsRequest extends Message<GetJobRunEventsRequest> {
  /**
   * @generated from field: string job_run_id = 1;
   */
  jobRunId = "";

  /**
   * @generated from field: string account_id = 2;
   */
  accountId = "";

  constructor(data?: PartialMessage<GetJobRunEventsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRunEventsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRunEventsRequest {
    return new GetJobRunEventsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRunEventsRequest {
    return new GetJobRunEventsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRunEventsRequest {
    return new GetJobRunEventsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRunEventsRequest | PlainMessage<GetJobRunEventsRequest> | undefined, b: GetJobRunEventsRequest | PlainMessage<GetJobRunEventsRequest> | undefined): boolean {
    return proto3.util.equals(GetJobRunEventsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRunEventsResponse
 */
export class GetJobRunEventsResponse extends Message<GetJobRunEventsResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.JobRunEvent events = 1;
   */
  events: JobRunEvent[] = [];

  /**
   * @generated from field: bool is_run_complete = 2;
   */
  isRunComplete = false;

  constructor(data?: PartialMessage<GetJobRunEventsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRunEventsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "events", kind: "message", T: JobRunEvent, repeated: true },
    { no: 2, name: "is_run_complete", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRunEventsResponse {
    return new GetJobRunEventsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRunEventsResponse {
    return new GetJobRunEventsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRunEventsResponse {
    return new GetJobRunEventsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRunEventsResponse | PlainMessage<GetJobRunEventsResponse> | undefined, b: GetJobRunEventsResponse | PlainMessage<GetJobRunEventsResponse> | undefined): boolean {
    return proto3.util.equals(GetJobRunEventsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteJobRunRequest
 */
export class DeleteJobRunRequest extends Message<DeleteJobRunRequest> {
  /**
   * @generated from field: string job_run_id = 1;
   */
  jobRunId = "";

  /**
   * @generated from field: string account_id = 2;
   */
  accountId = "";

  constructor(data?: PartialMessage<DeleteJobRunRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteJobRunRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteJobRunRequest {
    return new DeleteJobRunRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteJobRunRequest {
    return new DeleteJobRunRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteJobRunRequest {
    return new DeleteJobRunRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteJobRunRequest | PlainMessage<DeleteJobRunRequest> | undefined, b: DeleteJobRunRequest | PlainMessage<DeleteJobRunRequest> | undefined): boolean {
    return proto3.util.equals(DeleteJobRunRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteJobRunResponse
 */
export class DeleteJobRunResponse extends Message<DeleteJobRunResponse> {
  constructor(data?: PartialMessage<DeleteJobRunResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteJobRunResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteJobRunResponse {
    return new DeleteJobRunResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteJobRunResponse {
    return new DeleteJobRunResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteJobRunResponse {
    return new DeleteJobRunResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteJobRunResponse | PlainMessage<DeleteJobRunResponse> | undefined, b: DeleteJobRunResponse | PlainMessage<DeleteJobRunResponse> | undefined): boolean {
    return proto3.util.equals(DeleteJobRunResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.TerminateJobRunRequest
 */
export class TerminateJobRunRequest extends Message<TerminateJobRunRequest> {
  /**
   * @generated from field: string job_run_id = 1;
   */
  jobRunId = "";

  /**
   * @generated from field: string account_id = 2;
   */
  accountId = "";

  constructor(data?: PartialMessage<TerminateJobRunRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.TerminateJobRunRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerminateJobRunRequest {
    return new TerminateJobRunRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerminateJobRunRequest {
    return new TerminateJobRunRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerminateJobRunRequest {
    return new TerminateJobRunRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TerminateJobRunRequest | PlainMessage<TerminateJobRunRequest> | undefined, b: TerminateJobRunRequest | PlainMessage<TerminateJobRunRequest> | undefined): boolean {
    return proto3.util.equals(TerminateJobRunRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.TerminateJobRunResponse
 */
export class TerminateJobRunResponse extends Message<TerminateJobRunResponse> {
  constructor(data?: PartialMessage<TerminateJobRunResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.TerminateJobRunResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TerminateJobRunResponse {
    return new TerminateJobRunResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TerminateJobRunResponse {
    return new TerminateJobRunResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TerminateJobRunResponse {
    return new TerminateJobRunResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TerminateJobRunResponse | PlainMessage<TerminateJobRunResponse> | undefined, b: TerminateJobRunResponse | PlainMessage<TerminateJobRunResponse> | undefined): boolean {
    return proto3.util.equals(TerminateJobRunResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRunLogsStreamRequest
 */
export class GetJobRunLogsStreamRequest extends Message<GetJobRunLogsStreamRequest> {
  /**
   * @generated from field: string job_run_id = 1;
   */
  jobRunId = "";

  /**
   * @generated from field: string account_id = 2;
   */
  accountId = "";

  /**
   * The time window in which to retrieve the logs
   *
   * @generated from field: mgmt.v1alpha1.LogWindow window = 3;
   */
  window = LogWindow.NO_TIME_UNSPECIFIED;

  /**
   * Whether or not to tail the stream. Note: only works with k8s-pods and is not currently supported with Loki logs
   *
   * @generated from field: bool should_tail = 4;
   */
  shouldTail = false;

  /**
   * Optionally provide a max log limit
   *
   * @generated from field: optional int64 max_log_lines = 5;
   */
  maxLogLines?: bigint;

  /**
   * Provide a list of log levels to filter by. If any of these are UNSPECIFIED, all log levels are returned.
   *
   * @generated from field: repeated mgmt.v1alpha1.LogLevel log_levels = 6;
   */
  logLevels: LogLevel[] = [];

  constructor(data?: PartialMessage<GetJobRunLogsStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRunLogsStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "window", kind: "enum", T: proto3.getEnumType(LogWindow) },
    { no: 4, name: "should_tail", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "max_log_lines", kind: "scalar", T: 3 /* ScalarType.INT64 */, opt: true },
    { no: 6, name: "log_levels", kind: "enum", T: proto3.getEnumType(LogLevel), repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRunLogsStreamRequest {
    return new GetJobRunLogsStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRunLogsStreamRequest {
    return new GetJobRunLogsStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRunLogsStreamRequest {
    return new GetJobRunLogsStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRunLogsStreamRequest | PlainMessage<GetJobRunLogsStreamRequest> | undefined, b: GetJobRunLogsStreamRequest | PlainMessage<GetJobRunLogsStreamRequest> | undefined): boolean {
    return proto3.util.equals(GetJobRunLogsStreamRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobRunLogsStreamResponse
 */
export class GetJobRunLogsStreamResponse extends Message<GetJobRunLogsStreamResponse> {
  /**
   * @generated from field: string log_line = 1;
   */
  logLine = "";

  /**
   * @generated from field: optional google.protobuf.Timestamp timestamp = 2;
   */
  timestamp?: Timestamp;

  constructor(data?: PartialMessage<GetJobRunLogsStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobRunLogsStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "log_line", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "timestamp", kind: "message", T: Timestamp, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobRunLogsStreamResponse {
    return new GetJobRunLogsStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobRunLogsStreamResponse {
    return new GetJobRunLogsStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobRunLogsStreamResponse {
    return new GetJobRunLogsStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobRunLogsStreamResponse | PlainMessage<GetJobRunLogsStreamResponse> | undefined, b: GetJobRunLogsStreamResponse | PlainMessage<GetJobRunLogsStreamResponse> | undefined): boolean {
    return proto3.util.equals(GetJobRunLogsStreamResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetJobWorkflowOptionsRequest
 */
export class SetJobWorkflowOptionsRequest extends Message<SetJobWorkflowOptionsRequest> {
  /**
   * The unique identifier of the job
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The workflow options object. The entire object must be provided and will fully overwrite the previous result
   *
   * @generated from field: mgmt.v1alpha1.WorkflowOptions worfklow_options = 2;
   */
  worfklowOptions?: WorkflowOptions;

  constructor(data?: PartialMessage<SetJobWorkflowOptionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetJobWorkflowOptionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "worfklow_options", kind: "message", T: WorkflowOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetJobWorkflowOptionsRequest {
    return new SetJobWorkflowOptionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetJobWorkflowOptionsRequest {
    return new SetJobWorkflowOptionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetJobWorkflowOptionsRequest {
    return new SetJobWorkflowOptionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetJobWorkflowOptionsRequest | PlainMessage<SetJobWorkflowOptionsRequest> | undefined, b: SetJobWorkflowOptionsRequest | PlainMessage<SetJobWorkflowOptionsRequest> | undefined): boolean {
    return proto3.util.equals(SetJobWorkflowOptionsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetJobWorkflowOptionsResponse
 */
export class SetJobWorkflowOptionsResponse extends Message<SetJobWorkflowOptionsResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<SetJobWorkflowOptionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetJobWorkflowOptionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetJobWorkflowOptionsResponse {
    return new SetJobWorkflowOptionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetJobWorkflowOptionsResponse {
    return new SetJobWorkflowOptionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetJobWorkflowOptionsResponse {
    return new SetJobWorkflowOptionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetJobWorkflowOptionsResponse | PlainMessage<SetJobWorkflowOptionsResponse> | undefined, b: SetJobWorkflowOptionsResponse | PlainMessage<SetJobWorkflowOptionsResponse> | undefined): boolean {
    return proto3.util.equals(SetJobWorkflowOptionsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetJobSyncOptionsRequest
 */
export class SetJobSyncOptionsRequest extends Message<SetJobSyncOptionsRequest> {
  /**
   * The unique identifier of the job
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The sync options object. The entire object must be provided and will fully overwrite the previous result
   *
   * @generated from field: mgmt.v1alpha1.ActivityOptions sync_options = 2;
   */
  syncOptions?: ActivityOptions;

  constructor(data?: PartialMessage<SetJobSyncOptionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetJobSyncOptionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sync_options", kind: "message", T: ActivityOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetJobSyncOptionsRequest {
    return new SetJobSyncOptionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetJobSyncOptionsRequest {
    return new SetJobSyncOptionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetJobSyncOptionsRequest {
    return new SetJobSyncOptionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetJobSyncOptionsRequest | PlainMessage<SetJobSyncOptionsRequest> | undefined, b: SetJobSyncOptionsRequest | PlainMessage<SetJobSyncOptionsRequest> | undefined): boolean {
    return proto3.util.equals(SetJobSyncOptionsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetJobSyncOptionsResponse
 */
export class SetJobSyncOptionsResponse extends Message<SetJobSyncOptionsResponse> {
  /**
   * @generated from field: mgmt.v1alpha1.Job job = 1;
   */
  job?: Job;

  constructor(data?: PartialMessage<SetJobSyncOptionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetJobSyncOptionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job", kind: "message", T: Job },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetJobSyncOptionsResponse {
    return new SetJobSyncOptionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetJobSyncOptionsResponse {
    return new SetJobSyncOptionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetJobSyncOptionsResponse {
    return new SetJobSyncOptionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetJobSyncOptionsResponse | PlainMessage<SetJobSyncOptionsResponse> | undefined, b: SetJobSyncOptionsResponse | PlainMessage<SetJobSyncOptionsResponse> | undefined): boolean {
    return proto3.util.equals(SetJobSyncOptionsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ValidateJobMappingsRequest
 */
export class ValidateJobMappingsRequest extends Message<ValidateJobMappingsRequest> {
  /**
   * The unique account identifier that this job will be associated with
   *
   * @generated from field: string account_id = 1;
   */
  accountId = "";

  /**
   * @generated from field: repeated mgmt.v1alpha1.JobMapping mappings = 2;
   */
  mappings: JobMapping[] = [];

  /**
   * @generated from field: string connection_id = 3;
   */
  connectionId = "";

  /**
   * @generated from field: repeated mgmt.v1alpha1.VirtualForeignConstraint virtual_foreign_keys = 4;
   */
  virtualForeignKeys: VirtualForeignConstraint[] = [];

  constructor(data?: PartialMessage<ValidateJobMappingsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ValidateJobMappingsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mappings", kind: "message", T: JobMapping, repeated: true },
    { no: 3, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "virtual_foreign_keys", kind: "message", T: VirtualForeignConstraint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateJobMappingsRequest {
    return new ValidateJobMappingsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateJobMappingsRequest {
    return new ValidateJobMappingsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateJobMappingsRequest {
    return new ValidateJobMappingsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ValidateJobMappingsRequest | PlainMessage<ValidateJobMappingsRequest> | undefined, b: ValidateJobMappingsRequest | PlainMessage<ValidateJobMappingsRequest> | undefined): boolean {
    return proto3.util.equals(ValidateJobMappingsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ColumnError
 */
export class ColumnError extends Message<ColumnError> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: string table = 2;
   */
  table = "";

  /**
   * @generated from field: string column = 3;
   */
  column = "";

  /**
   * @generated from field: repeated string errors = 4;
   */
  errors: string[] = [];

  constructor(data?: PartialMessage<ColumnError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ColumnError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "errors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ColumnError {
    return new ColumnError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ColumnError {
    return new ColumnError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ColumnError {
    return new ColumnError().fromJsonString(jsonString, options);
  }

  static equals(a: ColumnError | PlainMessage<ColumnError> | undefined, b: ColumnError | PlainMessage<ColumnError> | undefined): boolean {
    return proto3.util.equals(ColumnError, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DatabaseError
 */
export class DatabaseError extends Message<DatabaseError> {
  /**
   * @generated from field: repeated string errors = 1;
   */
  errors: string[] = [];

  constructor(data?: PartialMessage<DatabaseError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DatabaseError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "errors", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseError {
    return new DatabaseError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseError {
    return new DatabaseError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseError {
    return new DatabaseError().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseError | PlainMessage<DatabaseError> | undefined, b: DatabaseError | PlainMessage<DatabaseError> | undefined): boolean {
    return proto3.util.equals(DatabaseError, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ValidateJobMappingsResponse
 */
export class ValidateJobMappingsResponse extends Message<ValidateJobMappingsResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.ColumnError column_errors = 1;
   */
  columnErrors: ColumnError[] = [];

  /**
   * @generated from field: mgmt.v1alpha1.DatabaseError database_errors = 2;
   */
  databaseErrors?: DatabaseError;

  constructor(data?: PartialMessage<ValidateJobMappingsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ValidateJobMappingsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column_errors", kind: "message", T: ColumnError, repeated: true },
    { no: 2, name: "database_errors", kind: "message", T: DatabaseError },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValidateJobMappingsResponse {
    return new ValidateJobMappingsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValidateJobMappingsResponse {
    return new ValidateJobMappingsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValidateJobMappingsResponse {
    return new ValidateJobMappingsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ValidateJobMappingsResponse | PlainMessage<ValidateJobMappingsResponse> | undefined, b: ValidateJobMappingsResponse | PlainMessage<ValidateJobMappingsResponse> | undefined): boolean {
    return proto3.util.equals(ValidateJobMappingsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.VirtualForeignKey
 */
export class VirtualForeignKey extends Message<VirtualForeignKey> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: string table = 2;
   */
  table = "";

  /**
   * @generated from field: repeated string columns = 3;
   */
  columns: string[] = [];

  constructor(data?: PartialMessage<VirtualForeignKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.VirtualForeignKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VirtualForeignKey {
    return new VirtualForeignKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VirtualForeignKey {
    return new VirtualForeignKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VirtualForeignKey {
    return new VirtualForeignKey().fromJsonString(jsonString, options);
  }

  static equals(a: VirtualForeignKey | PlainMessage<VirtualForeignKey> | undefined, b: VirtualForeignKey | PlainMessage<VirtualForeignKey> | undefined): boolean {
    return proto3.util.equals(VirtualForeignKey, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.VirtualForeignConstraint
 */
export class VirtualForeignConstraint extends Message<VirtualForeignConstraint> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: string table = 2;
   */
  table = "";

  /**
   * @generated from field: repeated string columns = 3;
   */
  columns: string[] = [];

  /**
   * @generated from field: mgmt.v1alpha1.VirtualForeignKey foreign_key = 4;
   */
  foreignKey?: VirtualForeignKey;

  constructor(data?: PartialMessage<VirtualForeignConstraint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.VirtualForeignConstraint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "foreign_key", kind: "message", T: VirtualForeignKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VirtualForeignConstraint {
    return new VirtualForeignConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VirtualForeignConstraint {
    return new VirtualForeignConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VirtualForeignConstraint {
    return new VirtualForeignConstraint().fromJsonString(jsonString, options);
  }

  static equals(a: VirtualForeignConstraint | PlainMessage<VirtualForeignConstraint> | undefined, b: VirtualForeignConstraint | PlainMessage<VirtualForeignConstraint> | undefined): boolean {
    return proto3.util.equals(VirtualForeignConstraint, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.RunContextKey
 */
export class RunContextKey extends Message<RunContextKey> {
  /**
   * The Neosync Run ID
   *
   * @generated from field: string job_run_id = 1;
   */
  jobRunId = "";

  /**
   * An opaque identifier that will be used to store specific items
   *
   * @generated from field: string external_id = 2;
   */
  externalId = "";

  /**
   * The Neosync Account ID
   *
   * @generated from field: string account_id = 3;
   */
  accountId = "";

  constructor(data?: PartialMessage<RunContextKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.RunContextKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "external_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "account_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunContextKey {
    return new RunContextKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunContextKey {
    return new RunContextKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunContextKey {
    return new RunContextKey().fromJsonString(jsonString, options);
  }

  static equals(a: RunContextKey | PlainMessage<RunContextKey> | undefined, b: RunContextKey | PlainMessage<RunContextKey> | undefined): boolean {
    return proto3.util.equals(RunContextKey, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetRunContextRequest
 */
export class GetRunContextRequest extends Message<GetRunContextRequest> {
  /**
   * @generated from field: mgmt.v1alpha1.RunContextKey id = 1;
   */
  id?: RunContextKey;

  constructor(data?: PartialMessage<GetRunContextRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetRunContextRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: RunContextKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRunContextRequest {
    return new GetRunContextRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRunContextRequest {
    return new GetRunContextRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRunContextRequest {
    return new GetRunContextRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetRunContextRequest | PlainMessage<GetRunContextRequest> | undefined, b: GetRunContextRequest | PlainMessage<GetRunContextRequest> | undefined): boolean {
    return proto3.util.equals(GetRunContextRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetRunContextResponse
 */
export class GetRunContextResponse extends Message<GetRunContextResponse> {
  /**
   * @generated from field: bytes value = 1;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<GetRunContextResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetRunContextResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetRunContextResponse {
    return new GetRunContextResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetRunContextResponse {
    return new GetRunContextResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetRunContextResponse {
    return new GetRunContextResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetRunContextResponse | PlainMessage<GetRunContextResponse> | undefined, b: GetRunContextResponse | PlainMessage<GetRunContextResponse> | undefined): boolean {
    return proto3.util.equals(GetRunContextResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetRunContextRequest
 */
export class SetRunContextRequest extends Message<SetRunContextRequest> {
  /**
   * @generated from field: mgmt.v1alpha1.RunContextKey id = 1;
   */
  id?: RunContextKey;

  /**
   * An opaque value that is to be determined by the key
   *
   * @generated from field: bytes value = 2;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<SetRunContextRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetRunContextRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: RunContextKey },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetRunContextRequest {
    return new SetRunContextRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetRunContextRequest {
    return new SetRunContextRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetRunContextRequest {
    return new SetRunContextRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetRunContextRequest | PlainMessage<SetRunContextRequest> | undefined, b: SetRunContextRequest | PlainMessage<SetRunContextRequest> | undefined): boolean {
    return proto3.util.equals(SetRunContextRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetRunContextResponse
 */
export class SetRunContextResponse extends Message<SetRunContextResponse> {
  constructor(data?: PartialMessage<SetRunContextResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetRunContextResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetRunContextResponse {
    return new SetRunContextResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetRunContextResponse {
    return new SetRunContextResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetRunContextResponse {
    return new SetRunContextResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetRunContextResponse | PlainMessage<SetRunContextResponse> | undefined, b: SetRunContextResponse | PlainMessage<SetRunContextResponse> | undefined): boolean {
    return proto3.util.equals(SetRunContextResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetRunContextsRequest
 */
export class SetRunContextsRequest extends Message<SetRunContextsRequest> {
  /**
   * @generated from field: mgmt.v1alpha1.RunContextKey id = 1;
   */
  id?: RunContextKey;

  /**
   * An opaque value that is to be determined by the key
   *
   * @generated from field: bytes value = 2;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<SetRunContextsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetRunContextsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "message", T: RunContextKey },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetRunContextsRequest {
    return new SetRunContextsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetRunContextsRequest {
    return new SetRunContextsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetRunContextsRequest {
    return new SetRunContextsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetRunContextsRequest | PlainMessage<SetRunContextsRequest> | undefined, b: SetRunContextsRequest | PlainMessage<SetRunContextsRequest> | undefined): boolean {
    return proto3.util.equals(SetRunContextsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetRunContextsResponse
 */
export class SetRunContextsResponse extends Message<SetRunContextsResponse> {
  constructor(data?: PartialMessage<SetRunContextsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetRunContextsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetRunContextsResponse {
    return new SetRunContextsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetRunContextsResponse {
    return new SetRunContextsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetRunContextsResponse {
    return new SetRunContextsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetRunContextsResponse | PlainMessage<SetRunContextsResponse> | undefined, b: SetRunContextsResponse | PlainMessage<SetRunContextsResponse> | undefined): boolean {
    return proto3.util.equals(SetRunContextsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobHook
 */
export class JobHook extends Message<JobHook> {
  /**
   * The unique identifier of this hook.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Name of the hook for display/reference.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Description of what this hook does.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * The unique identifier of the job this hook belongs to.
   *
   * @generated from field: string job_id = 4;
   */
  jobId = "";

  /**
   * Hook-type specific configuration.
   *
   * @generated from field: mgmt.v1alpha1.JobHookConfig config = 5;
   */
  config?: JobHookConfig;

  /**
   * The user that created this hook.
   *
   * @generated from field: string created_by_user_id = 6;
   */
  createdByUserId = "";

  /**
   * The time this hook was created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 7;
   */
  createdAt?: Timestamp;

  /**
   * The user that last updated this hook.
   *
   * @generated from field: string updated_by_user_id = 8;
   */
  updatedByUserId = "";

  /**
   * The last time this hook was updated.
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 9;
   */
  updatedAt?: Timestamp;

  /**
   * Whether or not the hook is enabled.
   *
   * @generated from field: bool enabled = 10;
   */
  enabled = false;

  /**
   * The priority of the hook (0-100). This determines the execution order. Lower values are higher priority (priority=0 is the highest).
   * Tie Breaking is determined by the following: (priority, created_at, id) in ascending order.
   *
   * @generated from field: uint32 priority = 11;
   */
  priority = 0;

  constructor(data?: PartialMessage<JobHook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobHook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "config", kind: "message", T: JobHookConfig },
    { no: 6, name: "created_by_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "created_at", kind: "message", T: Timestamp },
    { no: 8, name: "updated_by_user_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "updated_at", kind: "message", T: Timestamp },
    { no: 10, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "priority", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobHook {
    return new JobHook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobHook {
    return new JobHook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobHook {
    return new JobHook().fromJsonString(jsonString, options);
  }

  static equals(a: JobHook | PlainMessage<JobHook> | undefined, b: JobHook | PlainMessage<JobHook> | undefined): boolean {
    return proto3.util.equals(JobHook, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.NewJobHook
 */
export class NewJobHook extends Message<NewJobHook> {
  /**
   * Name of the hook for display/reference.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Description of what this hook does.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Hook-type specific configuration.
   *
   * @generated from field: mgmt.v1alpha1.JobHookConfig config = 3;
   */
  config?: JobHookConfig;

  /**
   * Whether or not the hook is enabled.
   *
   * @generated from field: bool enabled = 4;
   */
  enabled = false;

  /**
   * The priority of the hook (0-100). This determines the execution order. Lower values are higher priority (priority=0 is the highest).
   * Tie Breaking is determined by the following: (priority, created_at, id) in ascending order.
   *
   * @generated from field: uint32 priority = 5;
   */
  priority = 0;

  constructor(data?: PartialMessage<NewJobHook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.NewJobHook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "config", kind: "message", T: JobHookConfig },
    { no: 4, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "priority", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NewJobHook {
    return new NewJobHook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NewJobHook {
    return new NewJobHook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NewJobHook {
    return new NewJobHook().fromJsonString(jsonString, options);
  }

  static equals(a: NewJobHook | PlainMessage<NewJobHook> | undefined, b: NewJobHook | PlainMessage<NewJobHook> | undefined): boolean {
    return proto3.util.equals(NewJobHook, a, b);
  }
}

/**
 * Contains the specific hook type configurations.
 *
 * @generated from message mgmt.v1alpha1.JobHookConfig
 */
export class JobHookConfig extends Message<JobHookConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.JobHookConfig.config
   */
  config: {
    /**
     * Configuration for SQL-specific hooks.
     *
     * @generated from field: mgmt.v1alpha1.JobHookConfig.JobSqlHook sql = 5;
     */
    value: JobHookConfig_JobSqlHook;
    case: "sql";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<JobHookConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobHookConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "sql", kind: "message", T: JobHookConfig_JobSqlHook, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobHookConfig {
    return new JobHookConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobHookConfig {
    return new JobHookConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobHookConfig {
    return new JobHookConfig().fromJsonString(jsonString, options);
  }

  static equals(a: JobHookConfig | PlainMessage<JobHookConfig> | undefined, b: JobHookConfig | PlainMessage<JobHookConfig> | undefined): boolean {
    return proto3.util.equals(JobHookConfig, a, b);
  }
}

/**
 * Configuration for SQL-based hooks
 *
 * @generated from message mgmt.v1alpha1.JobHookConfig.JobSqlHook
 */
export class JobHookConfig_JobSqlHook extends Message<JobHookConfig_JobSqlHook> {
  /**
   * The SQL query to execute
   *
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * Unique identifier of the Neosync connection to run this hook for. Must be a connection id that is present in the job.
   *
   * @generated from field: string connection_id = 2;
   */
  connectionId = "";

  /**
   * The timing of when the hook will run
   *
   * @generated from field: mgmt.v1alpha1.JobHookConfig.JobSqlHook.Timing timing = 3;
   */
  timing?: JobHookConfig_JobSqlHook_Timing;

  constructor(data?: PartialMessage<JobHookConfig_JobSqlHook>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobHookConfig.JobSqlHook";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "timing", kind: "message", T: JobHookConfig_JobSqlHook_Timing },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobHookConfig_JobSqlHook {
    return new JobHookConfig_JobSqlHook().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobHookConfig_JobSqlHook {
    return new JobHookConfig_JobSqlHook().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobHookConfig_JobSqlHook {
    return new JobHookConfig_JobSqlHook().fromJsonString(jsonString, options);
  }

  static equals(a: JobHookConfig_JobSqlHook | PlainMessage<JobHookConfig_JobSqlHook> | undefined, b: JobHookConfig_JobSqlHook | PlainMessage<JobHookConfig_JobSqlHook> | undefined): boolean {
    return proto3.util.equals(JobHookConfig_JobSqlHook, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.JobHookConfig.JobSqlHook.Timing
 */
export class JobHookConfig_JobSqlHook_Timing extends Message<JobHookConfig_JobSqlHook_Timing> {
  /**
   * @generated from oneof mgmt.v1alpha1.JobHookConfig.JobSqlHook.Timing.timing
   */
  timing: {
    /**
     * A Pre-Sync timing.
     * Will run before the first table sync.
     * Will run before Truncation, if enabled.
     * Will run before Schema Init, if enabled.
     *
     * @generated from field: mgmt.v1alpha1.JobHookTimingPreSync pre_sync = 3;
     */
    value: JobHookTimingPreSync;
    case: "preSync";
  } | {
    /**
     * A Post-Sync timing. Will run after the last table sync.
     *
     * @generated from field: mgmt.v1alpha1.JobHookTimingPostSync post_sync = 4;
     */
    value: JobHookTimingPostSync;
    case: "postSync";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<JobHookConfig_JobSqlHook_Timing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobHookConfig.JobSqlHook.Timing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "pre_sync", kind: "message", T: JobHookTimingPreSync, oneof: "timing" },
    { no: 4, name: "post_sync", kind: "message", T: JobHookTimingPostSync, oneof: "timing" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobHookConfig_JobSqlHook_Timing {
    return new JobHookConfig_JobSqlHook_Timing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobHookConfig_JobSqlHook_Timing {
    return new JobHookConfig_JobSqlHook_Timing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobHookConfig_JobSqlHook_Timing {
    return new JobHookConfig_JobSqlHook_Timing().fromJsonString(jsonString, options);
  }

  static equals(a: JobHookConfig_JobSqlHook_Timing | PlainMessage<JobHookConfig_JobSqlHook_Timing> | undefined, b: JobHookConfig_JobSqlHook_Timing | PlainMessage<JobHookConfig_JobSqlHook_Timing> | undefined): boolean {
    return proto3.util.equals(JobHookConfig_JobSqlHook_Timing, a, b);
  }
}

/**
 * Configures the job hook to run before the first table sync.
 * Will run before Truncation, if enabled.
 * Will run before Schema Init, if enabled.
 *
 * @generated from message mgmt.v1alpha1.JobHookTimingPreSync
 */
export class JobHookTimingPreSync extends Message<JobHookTimingPreSync> {
  constructor(data?: PartialMessage<JobHookTimingPreSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobHookTimingPreSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobHookTimingPreSync {
    return new JobHookTimingPreSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobHookTimingPreSync {
    return new JobHookTimingPreSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobHookTimingPreSync {
    return new JobHookTimingPreSync().fromJsonString(jsonString, options);
  }

  static equals(a: JobHookTimingPreSync | PlainMessage<JobHookTimingPreSync> | undefined, b: JobHookTimingPreSync | PlainMessage<JobHookTimingPreSync> | undefined): boolean {
    return proto3.util.equals(JobHookTimingPreSync, a, b);
  }
}

/**
 * Configures the job hook to run after the last table sync.
 *
 * @generated from message mgmt.v1alpha1.JobHookTimingPostSync
 */
export class JobHookTimingPostSync extends Message<JobHookTimingPostSync> {
  constructor(data?: PartialMessage<JobHookTimingPostSync>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.JobHookTimingPostSync";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): JobHookTimingPostSync {
    return new JobHookTimingPostSync().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): JobHookTimingPostSync {
    return new JobHookTimingPostSync().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): JobHookTimingPostSync {
    return new JobHookTimingPostSync().fromJsonString(jsonString, options);
  }

  static equals(a: JobHookTimingPostSync | PlainMessage<JobHookTimingPostSync> | undefined, b: JobHookTimingPostSync | PlainMessage<JobHookTimingPostSync> | undefined): boolean {
    return proto3.util.equals(JobHookTimingPostSync, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobHooksRequest
 */
export class GetJobHooksRequest extends Message<GetJobHooksRequest> {
  /**
   * The unique identifier of the job
   *
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  constructor(data?: PartialMessage<GetJobHooksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobHooksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobHooksRequest {
    return new GetJobHooksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobHooksRequest {
    return new GetJobHooksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobHooksRequest {
    return new GetJobHooksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobHooksRequest | PlainMessage<GetJobHooksRequest> | undefined, b: GetJobHooksRequest | PlainMessage<GetJobHooksRequest> | undefined): boolean {
    return proto3.util.equals(GetJobHooksRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobHooksResponse
 */
export class GetJobHooksResponse extends Message<GetJobHooksResponse> {
  /**
   * The list of hooks found attached to the job
   *
   * @generated from field: repeated mgmt.v1alpha1.JobHook hooks = 1;
   */
  hooks: JobHook[] = [];

  constructor(data?: PartialMessage<GetJobHooksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobHooksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hooks", kind: "message", T: JobHook, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobHooksResponse {
    return new GetJobHooksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobHooksResponse {
    return new GetJobHooksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobHooksResponse {
    return new GetJobHooksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobHooksResponse | PlainMessage<GetJobHooksResponse> | undefined, b: GetJobHooksResponse | PlainMessage<GetJobHooksResponse> | undefined): boolean {
    return proto3.util.equals(GetJobHooksResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobHookRequest
 */
export class GetJobHookRequest extends Message<GetJobHookRequest> {
  /**
   * The unique identifier of the hook
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<GetJobHookRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobHookRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobHookRequest {
    return new GetJobHookRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobHookRequest {
    return new GetJobHookRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobHookRequest {
    return new GetJobHookRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobHookRequest | PlainMessage<GetJobHookRequest> | undefined, b: GetJobHookRequest | PlainMessage<GetJobHookRequest> | undefined): boolean {
    return proto3.util.equals(GetJobHookRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetJobHookResponse
 */
export class GetJobHookResponse extends Message<GetJobHookResponse> {
  /**
   * The found hook
   *
   * @generated from field: mgmt.v1alpha1.JobHook hook = 1;
   */
  hook?: JobHook;

  constructor(data?: PartialMessage<GetJobHookResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetJobHookResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hook", kind: "message", T: JobHook },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetJobHookResponse {
    return new GetJobHookResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetJobHookResponse {
    return new GetJobHookResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetJobHookResponse {
    return new GetJobHookResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetJobHookResponse | PlainMessage<GetJobHookResponse> | undefined, b: GetJobHookResponse | PlainMessage<GetJobHookResponse> | undefined): boolean {
    return proto3.util.equals(GetJobHookResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobHookRequest
 */
export class CreateJobHookRequest extends Message<CreateJobHookRequest> {
  /**
   * The unique identifier of the job
   *
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  /**
   * The new hook configuration
   *
   * @generated from field: mgmt.v1alpha1.NewJobHook hook = 2;
   */
  hook?: NewJobHook;

  constructor(data?: PartialMessage<CreateJobHookRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobHookRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "hook", kind: "message", T: NewJobHook },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobHookRequest {
    return new CreateJobHookRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobHookRequest {
    return new CreateJobHookRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobHookRequest {
    return new CreateJobHookRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobHookRequest | PlainMessage<CreateJobHookRequest> | undefined, b: CreateJobHookRequest | PlainMessage<CreateJobHookRequest> | undefined): boolean {
    return proto3.util.equals(CreateJobHookRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.CreateJobHookResponse
 */
export class CreateJobHookResponse extends Message<CreateJobHookResponse> {
  /**
   * The newly created hook
   *
   * @generated from field: mgmt.v1alpha1.JobHook hook = 1;
   */
  hook?: JobHook;

  constructor(data?: PartialMessage<CreateJobHookResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.CreateJobHookResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hook", kind: "message", T: JobHook },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateJobHookResponse {
    return new CreateJobHookResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateJobHookResponse {
    return new CreateJobHookResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateJobHookResponse {
    return new CreateJobHookResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateJobHookResponse | PlainMessage<CreateJobHookResponse> | undefined, b: CreateJobHookResponse | PlainMessage<CreateJobHookResponse> | undefined): boolean {
    return proto3.util.equals(CreateJobHookResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteJobHookRequest
 */
export class DeleteJobHookRequest extends Message<DeleteJobHookRequest> {
  /**
   * The unique identifier of the hook
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<DeleteJobHookRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteJobHookRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteJobHookRequest {
    return new DeleteJobHookRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteJobHookRequest {
    return new DeleteJobHookRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteJobHookRequest {
    return new DeleteJobHookRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteJobHookRequest | PlainMessage<DeleteJobHookRequest> | undefined, b: DeleteJobHookRequest | PlainMessage<DeleteJobHookRequest> | undefined): boolean {
    return proto3.util.equals(DeleteJobHookRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DeleteJobHookResponse
 */
export class DeleteJobHookResponse extends Message<DeleteJobHookResponse> {
  constructor(data?: PartialMessage<DeleteJobHookResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DeleteJobHookResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteJobHookResponse {
    return new DeleteJobHookResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteJobHookResponse {
    return new DeleteJobHookResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteJobHookResponse {
    return new DeleteJobHookResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteJobHookResponse | PlainMessage<DeleteJobHookResponse> | undefined, b: DeleteJobHookResponse | PlainMessage<DeleteJobHookResponse> | undefined): boolean {
    return proto3.util.equals(DeleteJobHookResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.IsJobHookNameAvailableRequest
 */
export class IsJobHookNameAvailableRequest extends Message<IsJobHookNameAvailableRequest> {
  /**
   * The unique identifier of the job
   *
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  /**
   * The hook name to check.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  constructor(data?: PartialMessage<IsJobHookNameAvailableRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.IsJobHookNameAvailableRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsJobHookNameAvailableRequest {
    return new IsJobHookNameAvailableRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsJobHookNameAvailableRequest {
    return new IsJobHookNameAvailableRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsJobHookNameAvailableRequest {
    return new IsJobHookNameAvailableRequest().fromJsonString(jsonString, options);
  }

  static equals(a: IsJobHookNameAvailableRequest | PlainMessage<IsJobHookNameAvailableRequest> | undefined, b: IsJobHookNameAvailableRequest | PlainMessage<IsJobHookNameAvailableRequest> | undefined): boolean {
    return proto3.util.equals(IsJobHookNameAvailableRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.IsJobHookNameAvailableResponse
 */
export class IsJobHookNameAvailableResponse extends Message<IsJobHookNameAvailableResponse> {
  /**
   * Whether or not the hook name is available
   *
   * @generated from field: bool is_available = 1;
   */
  isAvailable = false;

  constructor(data?: PartialMessage<IsJobHookNameAvailableResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.IsJobHookNameAvailableResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "is_available", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IsJobHookNameAvailableResponse {
    return new IsJobHookNameAvailableResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IsJobHookNameAvailableResponse {
    return new IsJobHookNameAvailableResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IsJobHookNameAvailableResponse {
    return new IsJobHookNameAvailableResponse().fromJsonString(jsonString, options);
  }

  static equals(a: IsJobHookNameAvailableResponse | PlainMessage<IsJobHookNameAvailableResponse> | undefined, b: IsJobHookNameAvailableResponse | PlainMessage<IsJobHookNameAvailableResponse> | undefined): boolean {
    return proto3.util.equals(IsJobHookNameAvailableResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateJobHookRequest
 */
export class UpdateJobHookRequest extends Message<UpdateJobHookRequest> {
  /**
   * The unique identifier of the hook
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Name of the hook for display/reference.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * Description of what this hook does.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Hook-type specific configuration.
   *
   * @generated from field: mgmt.v1alpha1.JobHookConfig config = 4;
   */
  config?: JobHookConfig;

  /**
   * Whether or not the hook is enabled.
   *
   * @generated from field: bool enabled = 5;
   */
  enabled = false;

  /**
   * The priority of the hook (0-100). This determines the execution order. Lower values are higher priority (priority=0 is the highest).
   * Tie Breaking is determined by the following: (priority, created_at, id) in ascending order.
   *
   * @generated from field: uint32 priority = 6;
   */
  priority = 0;

  constructor(data?: PartialMessage<UpdateJobHookRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateJobHookRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "config", kind: "message", T: JobHookConfig },
    { no: 5, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "priority", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateJobHookRequest {
    return new UpdateJobHookRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateJobHookRequest {
    return new UpdateJobHookRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateJobHookRequest {
    return new UpdateJobHookRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateJobHookRequest | PlainMessage<UpdateJobHookRequest> | undefined, b: UpdateJobHookRequest | PlainMessage<UpdateJobHookRequest> | undefined): boolean {
    return proto3.util.equals(UpdateJobHookRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UpdateJobHookResponse
 */
export class UpdateJobHookResponse extends Message<UpdateJobHookResponse> {
  /**
   * The updated job hook
   *
   * @generated from field: mgmt.v1alpha1.JobHook hook = 1;
   */
  hook?: JobHook;

  constructor(data?: PartialMessage<UpdateJobHookResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UpdateJobHookResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hook", kind: "message", T: JobHook },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateJobHookResponse {
    return new UpdateJobHookResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateJobHookResponse {
    return new UpdateJobHookResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateJobHookResponse {
    return new UpdateJobHookResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateJobHookResponse | PlainMessage<UpdateJobHookResponse> | undefined, b: UpdateJobHookResponse | PlainMessage<UpdateJobHookResponse> | undefined): boolean {
    return proto3.util.equals(UpdateJobHookResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetJobHookEnabledRequest
 */
export class SetJobHookEnabledRequest extends Message<SetJobHookEnabledRequest> {
  /**
   * The unique identifier of the hook
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Whether or not the hook is enabled.
   *
   * @generated from field: bool enabled = 2;
   */
  enabled = false;

  constructor(data?: PartialMessage<SetJobHookEnabledRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetJobHookEnabledRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetJobHookEnabledRequest {
    return new SetJobHookEnabledRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetJobHookEnabledRequest {
    return new SetJobHookEnabledRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetJobHookEnabledRequest {
    return new SetJobHookEnabledRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetJobHookEnabledRequest | PlainMessage<SetJobHookEnabledRequest> | undefined, b: SetJobHookEnabledRequest | PlainMessage<SetJobHookEnabledRequest> | undefined): boolean {
    return proto3.util.equals(SetJobHookEnabledRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SetJobHookEnabledResponse
 */
export class SetJobHookEnabledResponse extends Message<SetJobHookEnabledResponse> {
  /**
   * The updated job hook
   *
   * @generated from field: mgmt.v1alpha1.JobHook hook = 1;
   */
  hook?: JobHook;

  constructor(data?: PartialMessage<SetJobHookEnabledResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SetJobHookEnabledResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hook", kind: "message", T: JobHook },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetJobHookEnabledResponse {
    return new SetJobHookEnabledResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetJobHookEnabledResponse {
    return new SetJobHookEnabledResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetJobHookEnabledResponse {
    return new SetJobHookEnabledResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SetJobHookEnabledResponse | PlainMessage<SetJobHookEnabledResponse> | undefined, b: SetJobHookEnabledResponse | PlainMessage<SetJobHookEnabledResponse> | undefined): boolean {
    return proto3.util.equals(SetJobHookEnabledResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetActiveJobHooksByTimingRequest
 */
export class GetActiveJobHooksByTimingRequest extends Message<GetActiveJobHooksByTimingRequest> {
  /**
   * The unique identifier of the job
   *
   * @generated from field: string job_id = 1;
   */
  jobId = "";

  /**
   * The timing desired.
   *
   * @generated from field: mgmt.v1alpha1.GetActiveJobHooksByTimingRequest.Timing timing = 2;
   */
  timing = GetActiveJobHooksByTimingRequest_Timing.UNSPECIFIED;

  constructor(data?: PartialMessage<GetActiveJobHooksByTimingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetActiveJobHooksByTimingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "timing", kind: "enum", T: proto3.getEnumType(GetActiveJobHooksByTimingRequest_Timing) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetActiveJobHooksByTimingRequest {
    return new GetActiveJobHooksByTimingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetActiveJobHooksByTimingRequest {
    return new GetActiveJobHooksByTimingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetActiveJobHooksByTimingRequest {
    return new GetActiveJobHooksByTimingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetActiveJobHooksByTimingRequest | PlainMessage<GetActiveJobHooksByTimingRequest> | undefined, b: GetActiveJobHooksByTimingRequest | PlainMessage<GetActiveJobHooksByTimingRequest> | undefined): boolean {
    return proto3.util.equals(GetActiveJobHooksByTimingRequest, a, b);
  }
}

/**
 * @generated from enum mgmt.v1alpha1.GetActiveJobHooksByTimingRequest.Timing
 */
export enum GetActiveJobHooksByTimingRequest_Timing {
  /**
   * If unspecified, returns all active job hooks
   *
   * @generated from enum value: TIMING_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Only returns presync hooks
   *
   * @generated from enum value: TIMING_PRESYNC = 1;
   */
  PRESYNC = 1,

  /**
   * Only returns postsync hooks
   *
   * @generated from enum value: TIMING_POSTSYNC = 2;
   */
  POSTSYNC = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(GetActiveJobHooksByTimingRequest_Timing)
proto3.util.setEnumType(GetActiveJobHooksByTimingRequest_Timing, "mgmt.v1alpha1.GetActiveJobHooksByTimingRequest.Timing", [
  { no: 0, name: "TIMING_UNSPECIFIED" },
  { no: 1, name: "TIMING_PRESYNC" },
  { no: 2, name: "TIMING_POSTSYNC" },
]);

/**
 * @generated from message mgmt.v1alpha1.GetActiveJobHooksByTimingResponse
 */
export class GetActiveJobHooksByTimingResponse extends Message<GetActiveJobHooksByTimingResponse> {
  /**
   * The active job hooks
   *
   * @generated from field: repeated mgmt.v1alpha1.JobHook hooks = 1;
   */
  hooks: JobHook[] = [];

  constructor(data?: PartialMessage<GetActiveJobHooksByTimingResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetActiveJobHooksByTimingResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hooks", kind: "message", T: JobHook, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetActiveJobHooksByTimingResponse {
    return new GetActiveJobHooksByTimingResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetActiveJobHooksByTimingResponse {
    return new GetActiveJobHooksByTimingResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetActiveJobHooksByTimingResponse {
    return new GetActiveJobHooksByTimingResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetActiveJobHooksByTimingResponse | PlainMessage<GetActiveJobHooksByTimingResponse> | undefined, b: GetActiveJobHooksByTimingResponse | PlainMessage<GetActiveJobHooksByTimingResponse> | undefined): boolean {
    return proto3.util.equals(GetActiveJobHooksByTimingResponse, a, b);
  }
}

