// @generated by protoc-gen-es v1.3.1 with parameter "target=ts,import_extension=.js"
// @generated from file mgmt/v1alpha1/connection_data.proto (package mgmt.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from message mgmt.v1alpha1.PostgresStreamConfig
 */
export class PostgresStreamConfig extends Message<PostgresStreamConfig> {
  constructor(data?: PartialMessage<PostgresStreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresStreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresStreamConfig {
    return new PostgresStreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresStreamConfig {
    return new PostgresStreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresStreamConfig {
    return new PostgresStreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresStreamConfig | PlainMessage<PostgresStreamConfig> | undefined, b: PostgresStreamConfig | PlainMessage<PostgresStreamConfig> | undefined): boolean {
    return proto3.util.equals(PostgresStreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlStreamConfig
 */
export class MysqlStreamConfig extends Message<MysqlStreamConfig> {
  constructor(data?: PartialMessage<MysqlStreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlStreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlStreamConfig {
    return new MysqlStreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlStreamConfig {
    return new MysqlStreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlStreamConfig {
    return new MysqlStreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlStreamConfig | PlainMessage<MysqlStreamConfig> | undefined, b: MysqlStreamConfig | PlainMessage<MysqlStreamConfig> | undefined): boolean {
    return proto3.util.equals(MysqlStreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AwsS3StreamConfig
 */
export class AwsS3StreamConfig extends Message<AwsS3StreamConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.AwsS3StreamConfig.id
   */
  id: {
    /**
     * @generated from field: string job_id = 1;
     */
    value: string;
    case: "jobId";
  } | {
    /**
     * @generated from field: string job_run_id = 2;
     */
    value: string;
    case: "jobRunId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AwsS3StreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsS3StreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
    { no: 2, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3StreamConfig {
    return new AwsS3StreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3StreamConfig {
    return new AwsS3StreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3StreamConfig {
    return new AwsS3StreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3StreamConfig | PlainMessage<AwsS3StreamConfig> | undefined, b: AwsS3StreamConfig | PlainMessage<AwsS3StreamConfig> | undefined): boolean {
    return proto3.util.equals(AwsS3StreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ConnectionStreamConfig
 */
export class ConnectionStreamConfig extends Message<ConnectionStreamConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.ConnectionStreamConfig.config
   */
  config: {
    /**
     * @generated from field: mgmt.v1alpha1.PostgresStreamConfig pg_config = 1;
     */
    value: PostgresStreamConfig;
    case: "pgConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.AwsS3StreamConfig aws_s3_config = 2;
     */
    value: AwsS3StreamConfig;
    case: "awsS3Config";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MysqlStreamConfig mysql_config = 3;
     */
    value: MysqlStreamConfig;
    case: "mysqlConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ConnectionStreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ConnectionStreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pg_config", kind: "message", T: PostgresStreamConfig, oneof: "config" },
    { no: 2, name: "aws_s3_config", kind: "message", T: AwsS3StreamConfig, oneof: "config" },
    { no: 3, name: "mysql_config", kind: "message", T: MysqlStreamConfig, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionStreamConfig {
    return new ConnectionStreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionStreamConfig {
    return new ConnectionStreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionStreamConfig {
    return new ConnectionStreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionStreamConfig | PlainMessage<ConnectionStreamConfig> | undefined, b: ConnectionStreamConfig | PlainMessage<ConnectionStreamConfig> | undefined): boolean {
    return proto3.util.equals(ConnectionStreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionDataStreamRequest
 */
export class GetConnectionDataStreamRequest extends Message<GetConnectionDataStreamRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.ConnectionStreamConfig stream_config = 2;
   */
  streamConfig?: ConnectionStreamConfig;

  /**
   * @generated from field: string schema = 3;
   */
  schema = "";

  /**
   * @generated from field: string table = 4;
   */
  table = "";

  constructor(data?: PartialMessage<GetConnectionDataStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionDataStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "stream_config", kind: "message", T: ConnectionStreamConfig },
    { no: 3, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionDataStreamRequest {
    return new GetConnectionDataStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionDataStreamRequest {
    return new GetConnectionDataStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionDataStreamRequest {
    return new GetConnectionDataStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionDataStreamRequest | PlainMessage<GetConnectionDataStreamRequest> | undefined, b: GetConnectionDataStreamRequest | PlainMessage<GetConnectionDataStreamRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionDataStreamRequest, a, b);
  }
}

/**
 * Each stream response is a single row in the requested schema and table
 *
 * @generated from message mgmt.v1alpha1.GetConnectionDataStreamResponse
 */
export class GetConnectionDataStreamResponse extends Message<GetConnectionDataStreamResponse> {
  /**
   * A map of column name to the bytes value of the data that was found for that column and row
   *
   * @generated from field: map<string, bytes> row = 1;
   */
  row: { [key: string]: Uint8Array } = {};

  constructor(data?: PartialMessage<GetConnectionDataStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionDataStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 12 /* ScalarType.BYTES */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionDataStreamResponse {
    return new GetConnectionDataStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionDataStreamResponse {
    return new GetConnectionDataStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionDataStreamResponse {
    return new GetConnectionDataStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionDataStreamResponse | PlainMessage<GetConnectionDataStreamResponse> | undefined, b: GetConnectionDataStreamResponse | PlainMessage<GetConnectionDataStreamResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionDataStreamResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresSchemaConfig
 */
export class PostgresSchemaConfig extends Message<PostgresSchemaConfig> {
  constructor(data?: PartialMessage<PostgresSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSchemaConfig {
    return new PostgresSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSchemaConfig {
    return new PostgresSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSchemaConfig {
    return new PostgresSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSchemaConfig | PlainMessage<PostgresSchemaConfig> | undefined, b: PostgresSchemaConfig | PlainMessage<PostgresSchemaConfig> | undefined): boolean {
    return proto3.util.equals(PostgresSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlSchemaConfig
 */
export class MysqlSchemaConfig extends Message<MysqlSchemaConfig> {
  constructor(data?: PartialMessage<MysqlSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlSchemaConfig {
    return new MysqlSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlSchemaConfig {
    return new MysqlSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlSchemaConfig {
    return new MysqlSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlSchemaConfig | PlainMessage<MysqlSchemaConfig> | undefined, b: MysqlSchemaConfig | PlainMessage<MysqlSchemaConfig> | undefined): boolean {
    return proto3.util.equals(MysqlSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AwsS3SchemaConfig
 */
export class AwsS3SchemaConfig extends Message<AwsS3SchemaConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.AwsS3SchemaConfig.id
   */
  id: {
    /**
     * @generated from field: string job_id = 1;
     */
    value: string;
    case: "jobId";
  } | {
    /**
     * @generated from field: string job_run_id = 2;
     */
    value: string;
    case: "jobRunId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AwsS3SchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsS3SchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
    { no: 2, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3SchemaConfig {
    return new AwsS3SchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3SchemaConfig {
    return new AwsS3SchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3SchemaConfig {
    return new AwsS3SchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3SchemaConfig | PlainMessage<AwsS3SchemaConfig> | undefined, b: AwsS3SchemaConfig | PlainMessage<AwsS3SchemaConfig> | undefined): boolean {
    return proto3.util.equals(AwsS3SchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ConnectionSchemaConfig
 */
export class ConnectionSchemaConfig extends Message<ConnectionSchemaConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.ConnectionSchemaConfig.config
   */
  config: {
    /**
     * @generated from field: mgmt.v1alpha1.PostgresSchemaConfig pg_config = 1;
     */
    value: PostgresSchemaConfig;
    case: "pgConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.AwsS3SchemaConfig aws_s3_config = 2;
     */
    value: AwsS3SchemaConfig;
    case: "awsS3Config";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MysqlSchemaConfig mysql_config = 3;
     */
    value: MysqlSchemaConfig;
    case: "mysqlConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ConnectionSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ConnectionSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pg_config", kind: "message", T: PostgresSchemaConfig, oneof: "config" },
    { no: 2, name: "aws_s3_config", kind: "message", T: AwsS3SchemaConfig, oneof: "config" },
    { no: 3, name: "mysql_config", kind: "message", T: MysqlSchemaConfig, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionSchemaConfig {
    return new ConnectionSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionSchemaConfig {
    return new ConnectionSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionSchemaConfig {
    return new ConnectionSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionSchemaConfig | PlainMessage<ConnectionSchemaConfig> | undefined, b: ConnectionSchemaConfig | PlainMessage<ConnectionSchemaConfig> | undefined): boolean {
    return proto3.util.equals(ConnectionSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DatabaseColumn
 */
export class DatabaseColumn extends Message<DatabaseColumn> {
  /**
   * The database schema. Ex: public
   *
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * The name of the table in the schema
   *
   * @generated from field: string table = 2;
   */
  table = "";

  /**
   * The name of the column
   *
   * @generated from field: string column = 3;
   */
  column = "";

  /**
   * The datatype of the column
   *
   * @generated from field: string data_type = 4;
   */
  dataType = "";

  constructor(data?: PartialMessage<DatabaseColumn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DatabaseColumn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "data_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseColumn {
    return new DatabaseColumn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseColumn {
    return new DatabaseColumn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseColumn {
    return new DatabaseColumn().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseColumn | PlainMessage<DatabaseColumn> | undefined, b: DatabaseColumn | PlainMessage<DatabaseColumn> | undefined): boolean {
    return proto3.util.equals(DatabaseColumn, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionSchemaRequest
 */
export class GetConnectionSchemaRequest extends Message<GetConnectionSchemaRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.ConnectionSchemaConfig schema_config = 2;
   */
  schemaConfig?: ConnectionSchemaConfig;

  constructor(data?: PartialMessage<GetConnectionSchemaRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionSchemaRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schema_config", kind: "message", T: ConnectionSchemaConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionSchemaRequest {
    return new GetConnectionSchemaRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionSchemaRequest {
    return new GetConnectionSchemaRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionSchemaRequest {
    return new GetConnectionSchemaRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionSchemaRequest | PlainMessage<GetConnectionSchemaRequest> | undefined, b: GetConnectionSchemaRequest | PlainMessage<GetConnectionSchemaRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionSchemaRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionSchemaResponse
 */
export class GetConnectionSchemaResponse extends Message<GetConnectionSchemaResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.DatabaseColumn schemas = 1;
   */
  schemas: DatabaseColumn[] = [];

  constructor(data?: PartialMessage<GetConnectionSchemaResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionSchemaResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schemas", kind: "message", T: DatabaseColumn, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionSchemaResponse {
    return new GetConnectionSchemaResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionSchemaResponse {
    return new GetConnectionSchemaResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionSchemaResponse {
    return new GetConnectionSchemaResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionSchemaResponse | PlainMessage<GetConnectionSchemaResponse> | undefined, b: GetConnectionSchemaResponse | PlainMessage<GetConnectionSchemaResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionSchemaResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionForeignConstraintsRequest
 */
export class GetConnectionForeignConstraintsRequest extends Message<GetConnectionForeignConstraintsRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  constructor(data?: PartialMessage<GetConnectionForeignConstraintsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionForeignConstraintsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionForeignConstraintsRequest {
    return new GetConnectionForeignConstraintsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionForeignConstraintsRequest {
    return new GetConnectionForeignConstraintsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionForeignConstraintsRequest {
    return new GetConnectionForeignConstraintsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionForeignConstraintsRequest | PlainMessage<GetConnectionForeignConstraintsRequest> | undefined, b: GetConnectionForeignConstraintsRequest | PlainMessage<GetConnectionForeignConstraintsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionForeignConstraintsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ForeignKey
 */
export class ForeignKey extends Message<ForeignKey> {
  /**
   * @generated from field: string table = 1;
   */
  table = "";

  /**
   * @generated from field: string column = 2;
   */
  column = "";

  constructor(data?: PartialMessage<ForeignKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ForeignKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForeignKey {
    return new ForeignKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForeignKey {
    return new ForeignKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForeignKey {
    return new ForeignKey().fromJsonString(jsonString, options);
  }

  static equals(a: ForeignKey | PlainMessage<ForeignKey> | undefined, b: ForeignKey | PlainMessage<ForeignKey> | undefined): boolean {
    return proto3.util.equals(ForeignKey, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ForeignConstraint
 */
export class ForeignConstraint extends Message<ForeignConstraint> {
  /**
   * @generated from field: string column = 1;
   */
  column = "";

  /**
   * @generated from field: bool is_nullable = 2;
   */
  isNullable = false;

  /**
   * @generated from field: mgmt.v1alpha1.ForeignKey foreign_key = 3;
   */
  foreignKey?: ForeignKey;

  constructor(data?: PartialMessage<ForeignConstraint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ForeignConstraint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_nullable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "foreign_key", kind: "message", T: ForeignKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForeignConstraint {
    return new ForeignConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForeignConstraint {
    return new ForeignConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForeignConstraint {
    return new ForeignConstraint().fromJsonString(jsonString, options);
  }

  static equals(a: ForeignConstraint | PlainMessage<ForeignConstraint> | undefined, b: ForeignConstraint | PlainMessage<ForeignConstraint> | undefined): boolean {
    return proto3.util.equals(ForeignConstraint, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ForeignConstraintTables
 */
export class ForeignConstraintTables extends Message<ForeignConstraintTables> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.ForeignConstraint constraints = 1;
   */
  constraints: ForeignConstraint[] = [];

  constructor(data?: PartialMessage<ForeignConstraintTables>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ForeignConstraintTables";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "constraints", kind: "message", T: ForeignConstraint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForeignConstraintTables {
    return new ForeignConstraintTables().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForeignConstraintTables {
    return new ForeignConstraintTables().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForeignConstraintTables {
    return new ForeignConstraintTables().fromJsonString(jsonString, options);
  }

  static equals(a: ForeignConstraintTables | PlainMessage<ForeignConstraintTables> | undefined, b: ForeignConstraintTables | PlainMessage<ForeignConstraintTables> | undefined): boolean {
    return proto3.util.equals(ForeignConstraintTables, a, b);
  }
}

/**
 * Dependency constraints for a specific table
 *
 * @generated from message mgmt.v1alpha1.GetConnectionForeignConstraintsResponse
 */
export class GetConnectionForeignConstraintsResponse extends Message<GetConnectionForeignConstraintsResponse> {
  /**
   * the key here is <schema>.<table> and the list of tables that it depends on, also `<schema>.<table>` format.
   *
   * @generated from field: map<string, mgmt.v1alpha1.ForeignConstraintTables> table_constraints = 1;
   */
  tableConstraints: { [key: string]: ForeignConstraintTables } = {};

  constructor(data?: PartialMessage<GetConnectionForeignConstraintsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionForeignConstraintsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_constraints", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ForeignConstraintTables} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionForeignConstraintsResponse {
    return new GetConnectionForeignConstraintsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionForeignConstraintsResponse {
    return new GetConnectionForeignConstraintsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionForeignConstraintsResponse {
    return new GetConnectionForeignConstraintsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionForeignConstraintsResponse | PlainMessage<GetConnectionForeignConstraintsResponse> | undefined, b: GetConnectionForeignConstraintsResponse | PlainMessage<GetConnectionForeignConstraintsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionForeignConstraintsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.InitStatementOptions
 */
export class InitStatementOptions extends Message<InitStatementOptions> {
  /**
   * @generated from field: bool init_schema = 1;
   */
  initSchema = false;

  /**
   * @generated from field: bool truncate_before_insert = 2;
   */
  truncateBeforeInsert = false;

  /**
   * @generated from field: bool truncate_cascade = 3;
   */
  truncateCascade = false;

  constructor(data?: PartialMessage<InitStatementOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.InitStatementOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "init_schema", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "truncate_before_insert", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "truncate_cascade", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitStatementOptions {
    return new InitStatementOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitStatementOptions {
    return new InitStatementOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitStatementOptions {
    return new InitStatementOptions().fromJsonString(jsonString, options);
  }

  static equals(a: InitStatementOptions | PlainMessage<InitStatementOptions> | undefined, b: InitStatementOptions | PlainMessage<InitStatementOptions> | undefined): boolean {
    return proto3.util.equals(InitStatementOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionInitStatementsRequest
 */
export class GetConnectionInitStatementsRequest extends Message<GetConnectionInitStatementsRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.InitStatementOptions options = 2;
   */
  options?: InitStatementOptions;

  constructor(data?: PartialMessage<GetConnectionInitStatementsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionInitStatementsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "options", kind: "message", T: InitStatementOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionInitStatementsRequest {
    return new GetConnectionInitStatementsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionInitStatementsRequest {
    return new GetConnectionInitStatementsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionInitStatementsRequest {
    return new GetConnectionInitStatementsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionInitStatementsRequest | PlainMessage<GetConnectionInitStatementsRequest> | undefined, b: GetConnectionInitStatementsRequest | PlainMessage<GetConnectionInitStatementsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionInitStatementsRequest, a, b);
  }
}

/**
 * Init statement for a specific table
 *
 * @generated from message mgmt.v1alpha1.GetConnectionInitStatementsResponse
 */
export class GetConnectionInitStatementsResponse extends Message<GetConnectionInitStatementsResponse> {
  /**
   * the key here is <schema>.<table> and value is the table init statement.
   *
   * @generated from field: map<string, string> table_init_statements = 1;
   */
  tableInitStatements: { [key: string]: string } = {};

  constructor(data?: PartialMessage<GetConnectionInitStatementsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionInitStatementsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_init_statements", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionInitStatementsResponse {
    return new GetConnectionInitStatementsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionInitStatementsResponse {
    return new GetConnectionInitStatementsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionInitStatementsResponse {
    return new GetConnectionInitStatementsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionInitStatementsResponse | PlainMessage<GetConnectionInitStatementsResponse> | undefined, b: GetConnectionInitStatementsResponse | PlainMessage<GetConnectionInitStatementsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionInitStatementsResponse, a, b);
  }
}

