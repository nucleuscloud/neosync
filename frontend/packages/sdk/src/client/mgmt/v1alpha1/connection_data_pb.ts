// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=.js"
// @generated from file mgmt/v1alpha1/connection_data.proto (package mgmt.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct } from "@bufbuild/protobuf";

/**
 * @generated from message mgmt.v1alpha1.PostgresStreamConfig
 */
export class PostgresStreamConfig extends Message<PostgresStreamConfig> {
  constructor(data?: PartialMessage<PostgresStreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresStreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresStreamConfig {
    return new PostgresStreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresStreamConfig {
    return new PostgresStreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresStreamConfig {
    return new PostgresStreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresStreamConfig | PlainMessage<PostgresStreamConfig> | undefined, b: PostgresStreamConfig | PlainMessage<PostgresStreamConfig> | undefined): boolean {
    return proto3.util.equals(PostgresStreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlStreamConfig
 */
export class MysqlStreamConfig extends Message<MysqlStreamConfig> {
  constructor(data?: PartialMessage<MysqlStreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlStreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlStreamConfig {
    return new MysqlStreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlStreamConfig {
    return new MysqlStreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlStreamConfig {
    return new MysqlStreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlStreamConfig | PlainMessage<MysqlStreamConfig> | undefined, b: MysqlStreamConfig | PlainMessage<MysqlStreamConfig> | undefined): boolean {
    return proto3.util.equals(MysqlStreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AwsDynamoDBStreamConfig
 */
export class AwsDynamoDBStreamConfig extends Message<AwsDynamoDBStreamConfig> {
  constructor(data?: PartialMessage<AwsDynamoDBStreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsDynamoDBStreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsDynamoDBStreamConfig {
    return new AwsDynamoDBStreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsDynamoDBStreamConfig {
    return new AwsDynamoDBStreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsDynamoDBStreamConfig {
    return new AwsDynamoDBStreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AwsDynamoDBStreamConfig | PlainMessage<AwsDynamoDBStreamConfig> | undefined, b: AwsDynamoDBStreamConfig | PlainMessage<AwsDynamoDBStreamConfig> | undefined): boolean {
    return proto3.util.equals(AwsDynamoDBStreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AwsS3StreamConfig
 */
export class AwsS3StreamConfig extends Message<AwsS3StreamConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.AwsS3StreamConfig.id
   */
  id: {
    /**
     * @generated from field: string job_id = 1;
     */
    value: string;
    case: "jobId";
  } | {
    /**
     * @generated from field: string job_run_id = 2;
     */
    value: string;
    case: "jobRunId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AwsS3StreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsS3StreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
    { no: 2, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3StreamConfig {
    return new AwsS3StreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3StreamConfig {
    return new AwsS3StreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3StreamConfig {
    return new AwsS3StreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3StreamConfig | PlainMessage<AwsS3StreamConfig> | undefined, b: AwsS3StreamConfig | PlainMessage<AwsS3StreamConfig> | undefined): boolean {
    return proto3.util.equals(AwsS3StreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GcpCloudStorageStreamConfig
 */
export class GcpCloudStorageStreamConfig extends Message<GcpCloudStorageStreamConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.GcpCloudStorageStreamConfig.id
   */
  id: {
    /**
     * @generated from field: string job_id = 1;
     */
    value: string;
    case: "jobId";
  } | {
    /**
     * @generated from field: string job_run_id = 2;
     */
    value: string;
    case: "jobRunId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GcpCloudStorageStreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GcpCloudStorageStreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
    { no: 2, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GcpCloudStorageStreamConfig {
    return new GcpCloudStorageStreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GcpCloudStorageStreamConfig {
    return new GcpCloudStorageStreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GcpCloudStorageStreamConfig {
    return new GcpCloudStorageStreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: GcpCloudStorageStreamConfig | PlainMessage<GcpCloudStorageStreamConfig> | undefined, b: GcpCloudStorageStreamConfig | PlainMessage<GcpCloudStorageStreamConfig> | undefined): boolean {
    return proto3.util.equals(GcpCloudStorageStreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ConnectionStreamConfig
 */
export class ConnectionStreamConfig extends Message<ConnectionStreamConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.ConnectionStreamConfig.config
   */
  config: {
    /**
     * @generated from field: mgmt.v1alpha1.PostgresStreamConfig pg_config = 1;
     */
    value: PostgresStreamConfig;
    case: "pgConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.AwsS3StreamConfig aws_s3_config = 2;
     */
    value: AwsS3StreamConfig;
    case: "awsS3Config";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MysqlStreamConfig mysql_config = 3;
     */
    value: MysqlStreamConfig;
    case: "mysqlConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.GcpCloudStorageStreamConfig gcp_cloudstorage_config = 4;
     */
    value: GcpCloudStorageStreamConfig;
    case: "gcpCloudstorageConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.AwsDynamoDBStreamConfig dynamodb_config = 5;
     */
    value: AwsDynamoDBStreamConfig;
    case: "dynamodbConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ConnectionStreamConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ConnectionStreamConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pg_config", kind: "message", T: PostgresStreamConfig, oneof: "config" },
    { no: 2, name: "aws_s3_config", kind: "message", T: AwsS3StreamConfig, oneof: "config" },
    { no: 3, name: "mysql_config", kind: "message", T: MysqlStreamConfig, oneof: "config" },
    { no: 4, name: "gcp_cloudstorage_config", kind: "message", T: GcpCloudStorageStreamConfig, oneof: "config" },
    { no: 5, name: "dynamodb_config", kind: "message", T: AwsDynamoDBStreamConfig, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionStreamConfig {
    return new ConnectionStreamConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionStreamConfig {
    return new ConnectionStreamConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionStreamConfig {
    return new ConnectionStreamConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionStreamConfig | PlainMessage<ConnectionStreamConfig> | undefined, b: ConnectionStreamConfig | PlainMessage<ConnectionStreamConfig> | undefined): boolean {
    return proto3.util.equals(ConnectionStreamConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionDataStreamRequest
 */
export class GetConnectionDataStreamRequest extends Message<GetConnectionDataStreamRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.ConnectionStreamConfig stream_config = 2;
   */
  streamConfig?: ConnectionStreamConfig;

  /**
   * @generated from field: string schema = 3;
   */
  schema = "";

  /**
   * @generated from field: string table = 4;
   */
  table = "";

  constructor(data?: PartialMessage<GetConnectionDataStreamRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionDataStreamRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "stream_config", kind: "message", T: ConnectionStreamConfig },
    { no: 3, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionDataStreamRequest {
    return new GetConnectionDataStreamRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionDataStreamRequest {
    return new GetConnectionDataStreamRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionDataStreamRequest {
    return new GetConnectionDataStreamRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionDataStreamRequest | PlainMessage<GetConnectionDataStreamRequest> | undefined, b: GetConnectionDataStreamRequest | PlainMessage<GetConnectionDataStreamRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionDataStreamRequest, a, b);
  }
}

/**
 * Each stream response is a single row in the requested schema and table
 *
 * @generated from message mgmt.v1alpha1.GetConnectionDataStreamResponse
 */
export class GetConnectionDataStreamResponse extends Message<GetConnectionDataStreamResponse> {
  /**
   * A map of column name to the bytes value of the data that was found for that column and row
   *
   * @generated from field: map<string, bytes> row = 1;
   */
  row: { [key: string]: Uint8Array } = {};

  constructor(data?: PartialMessage<GetConnectionDataStreamResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionDataStreamResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 12 /* ScalarType.BYTES */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionDataStreamResponse {
    return new GetConnectionDataStreamResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionDataStreamResponse {
    return new GetConnectionDataStreamResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionDataStreamResponse {
    return new GetConnectionDataStreamResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionDataStreamResponse | PlainMessage<GetConnectionDataStreamResponse> | undefined, b: GetConnectionDataStreamResponse | PlainMessage<GetConnectionDataStreamResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionDataStreamResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PostgresSchemaConfig
 */
export class PostgresSchemaConfig extends Message<PostgresSchemaConfig> {
  constructor(data?: PartialMessage<PostgresSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PostgresSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PostgresSchemaConfig {
    return new PostgresSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PostgresSchemaConfig {
    return new PostgresSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PostgresSchemaConfig {
    return new PostgresSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PostgresSchemaConfig | PlainMessage<PostgresSchemaConfig> | undefined, b: PostgresSchemaConfig | PlainMessage<PostgresSchemaConfig> | undefined): boolean {
    return proto3.util.equals(PostgresSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MysqlSchemaConfig
 */
export class MysqlSchemaConfig extends Message<MysqlSchemaConfig> {
  constructor(data?: PartialMessage<MysqlSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MysqlSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MysqlSchemaConfig {
    return new MysqlSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MysqlSchemaConfig {
    return new MysqlSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MysqlSchemaConfig {
    return new MysqlSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MysqlSchemaConfig | PlainMessage<MysqlSchemaConfig> | undefined, b: MysqlSchemaConfig | PlainMessage<MysqlSchemaConfig> | undefined): boolean {
    return proto3.util.equals(MysqlSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MssqlSchemaConfig
 */
export class MssqlSchemaConfig extends Message<MssqlSchemaConfig> {
  constructor(data?: PartialMessage<MssqlSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MssqlSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MssqlSchemaConfig {
    return new MssqlSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MssqlSchemaConfig {
    return new MssqlSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MssqlSchemaConfig {
    return new MssqlSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MssqlSchemaConfig | PlainMessage<MssqlSchemaConfig> | undefined, b: MssqlSchemaConfig | PlainMessage<MssqlSchemaConfig> | undefined): boolean {
    return proto3.util.equals(MssqlSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.AwsS3SchemaConfig
 */
export class AwsS3SchemaConfig extends Message<AwsS3SchemaConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.AwsS3SchemaConfig.id
   */
  id: {
    /**
     * @generated from field: string job_id = 1;
     */
    value: string;
    case: "jobId";
  } | {
    /**
     * @generated from field: string job_run_id = 2;
     */
    value: string;
    case: "jobRunId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AwsS3SchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.AwsS3SchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
    { no: 2, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3SchemaConfig {
    return new AwsS3SchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3SchemaConfig {
    return new AwsS3SchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3SchemaConfig {
    return new AwsS3SchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3SchemaConfig | PlainMessage<AwsS3SchemaConfig> | undefined, b: AwsS3SchemaConfig | PlainMessage<AwsS3SchemaConfig> | undefined): boolean {
    return proto3.util.equals(AwsS3SchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.MongoSchemaConfig
 */
export class MongoSchemaConfig extends Message<MongoSchemaConfig> {
  constructor(data?: PartialMessage<MongoSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.MongoSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MongoSchemaConfig {
    return new MongoSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MongoSchemaConfig {
    return new MongoSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MongoSchemaConfig {
    return new MongoSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MongoSchemaConfig | PlainMessage<MongoSchemaConfig> | undefined, b: MongoSchemaConfig | PlainMessage<MongoSchemaConfig> | undefined): boolean {
    return proto3.util.equals(MongoSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DynamoDBSchemaConfig
 */
export class DynamoDBSchemaConfig extends Message<DynamoDBSchemaConfig> {
  constructor(data?: PartialMessage<DynamoDBSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DynamoDBSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamoDBSchemaConfig {
    return new DynamoDBSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamoDBSchemaConfig {
    return new DynamoDBSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamoDBSchemaConfig {
    return new DynamoDBSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: DynamoDBSchemaConfig | PlainMessage<DynamoDBSchemaConfig> | undefined, b: DynamoDBSchemaConfig | PlainMessage<DynamoDBSchemaConfig> | undefined): boolean {
    return proto3.util.equals(DynamoDBSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GcpCloudStorageSchemaConfig
 */
export class GcpCloudStorageSchemaConfig extends Message<GcpCloudStorageSchemaConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.GcpCloudStorageSchemaConfig.id
   */
  id: {
    /**
     * @generated from field: string job_id = 1;
     */
    value: string;
    case: "jobId";
  } | {
    /**
     * @generated from field: string job_run_id = 2;
     */
    value: string;
    case: "jobRunId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GcpCloudStorageSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GcpCloudStorageSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "job_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
    { no: 2, name: "job_run_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GcpCloudStorageSchemaConfig {
    return new GcpCloudStorageSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GcpCloudStorageSchemaConfig {
    return new GcpCloudStorageSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GcpCloudStorageSchemaConfig {
    return new GcpCloudStorageSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: GcpCloudStorageSchemaConfig | PlainMessage<GcpCloudStorageSchemaConfig> | undefined, b: GcpCloudStorageSchemaConfig | PlainMessage<GcpCloudStorageSchemaConfig> | undefined): boolean {
    return proto3.util.equals(GcpCloudStorageSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ConnectionSchemaConfig
 */
export class ConnectionSchemaConfig extends Message<ConnectionSchemaConfig> {
  /**
   * @generated from oneof mgmt.v1alpha1.ConnectionSchemaConfig.config
   */
  config: {
    /**
     * @generated from field: mgmt.v1alpha1.PostgresSchemaConfig pg_config = 1;
     */
    value: PostgresSchemaConfig;
    case: "pgConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.AwsS3SchemaConfig aws_s3_config = 2;
     */
    value: AwsS3SchemaConfig;
    case: "awsS3Config";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MysqlSchemaConfig mysql_config = 3;
     */
    value: MysqlSchemaConfig;
    case: "mysqlConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MongoSchemaConfig mongo_config = 4;
     */
    value: MongoSchemaConfig;
    case: "mongoConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.GcpCloudStorageSchemaConfig gcp_cloudstorage_config = 5;
     */
    value: GcpCloudStorageSchemaConfig;
    case: "gcpCloudstorageConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.DynamoDBSchemaConfig dynamodb_config = 6;
     */
    value: DynamoDBSchemaConfig;
    case: "dynamodbConfig";
  } | {
    /**
     * @generated from field: mgmt.v1alpha1.MssqlSchemaConfig mssql_config = 7;
     */
    value: MssqlSchemaConfig;
    case: "mssqlConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ConnectionSchemaConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ConnectionSchemaConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pg_config", kind: "message", T: PostgresSchemaConfig, oneof: "config" },
    { no: 2, name: "aws_s3_config", kind: "message", T: AwsS3SchemaConfig, oneof: "config" },
    { no: 3, name: "mysql_config", kind: "message", T: MysqlSchemaConfig, oneof: "config" },
    { no: 4, name: "mongo_config", kind: "message", T: MongoSchemaConfig, oneof: "config" },
    { no: 5, name: "gcp_cloudstorage_config", kind: "message", T: GcpCloudStorageSchemaConfig, oneof: "config" },
    { no: 6, name: "dynamodb_config", kind: "message", T: DynamoDBSchemaConfig, oneof: "config" },
    { no: 7, name: "mssql_config", kind: "message", T: MssqlSchemaConfig, oneof: "config" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionSchemaConfig {
    return new ConnectionSchemaConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionSchemaConfig {
    return new ConnectionSchemaConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionSchemaConfig {
    return new ConnectionSchemaConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionSchemaConfig | PlainMessage<ConnectionSchemaConfig> | undefined, b: ConnectionSchemaConfig | PlainMessage<ConnectionSchemaConfig> | undefined): boolean {
    return proto3.util.equals(ConnectionSchemaConfig, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DatabaseColumn
 */
export class DatabaseColumn extends Message<DatabaseColumn> {
  /**
   * The database schema. Ex: public
   *
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * The name of the table in the schema
   *
   * @generated from field: string table = 2;
   */
  table = "";

  /**
   * The name of the column
   *
   * @generated from field: string column = 3;
   */
  column = "";

  /**
   * The datatype of the column
   *
   * @generated from field: string data_type = 4;
   */
  dataType = "";

  /**
   * The isNullable Flag of the column
   *
   * @generated from field: string is_nullable = 5;
   */
  isNullable = "";

  /**
   * The default value of the column if available
   *
   * @generated from field: optional string column_default = 6;
   */
  columnDefault?: string;

  /**
   * Populated if the column is generated. The value is the type of generated column it is. For example, postgres is 's' for stored
   * May be other values in the future, or other DB providers may use a different value types.
   *
   * @generated from field: optional string generated_type = 7;
   */
  generatedType?: string;

  /**
   * Populated if the column is an identity. The value is the type of the identity column it is. For example, postgres is 'd' for generated by default, or 'a' for generated always.
   *
   * @generated from field: optional string identity_generation = 8;
   */
  identityGeneration?: string;

  constructor(data?: PartialMessage<DatabaseColumn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DatabaseColumn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "data_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "is_nullable", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "column_default", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "generated_type", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "identity_generation", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseColumn {
    return new DatabaseColumn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseColumn {
    return new DatabaseColumn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseColumn {
    return new DatabaseColumn().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseColumn | PlainMessage<DatabaseColumn> | undefined, b: DatabaseColumn | PlainMessage<DatabaseColumn> | undefined): boolean {
    return proto3.util.equals(DatabaseColumn, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionSchemaRequest
 */
export class GetConnectionSchemaRequest extends Message<GetConnectionSchemaRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.ConnectionSchemaConfig schema_config = 2;
   */
  schemaConfig?: ConnectionSchemaConfig;

  constructor(data?: PartialMessage<GetConnectionSchemaRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionSchemaRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schema_config", kind: "message", T: ConnectionSchemaConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionSchemaRequest {
    return new GetConnectionSchemaRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionSchemaRequest {
    return new GetConnectionSchemaRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionSchemaRequest {
    return new GetConnectionSchemaRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionSchemaRequest | PlainMessage<GetConnectionSchemaRequest> | undefined, b: GetConnectionSchemaRequest | PlainMessage<GetConnectionSchemaRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionSchemaRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionSchemaResponse
 */
export class GetConnectionSchemaResponse extends Message<GetConnectionSchemaResponse> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.DatabaseColumn schemas = 1;
   */
  schemas: DatabaseColumn[] = [];

  constructor(data?: PartialMessage<GetConnectionSchemaResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionSchemaResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schemas", kind: "message", T: DatabaseColumn, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionSchemaResponse {
    return new GetConnectionSchemaResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionSchemaResponse {
    return new GetConnectionSchemaResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionSchemaResponse {
    return new GetConnectionSchemaResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionSchemaResponse | PlainMessage<GetConnectionSchemaResponse> | undefined, b: GetConnectionSchemaResponse | PlainMessage<GetConnectionSchemaResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionSchemaResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionSchemaMapRequest
 */
export class GetConnectionSchemaMapRequest extends Message<GetConnectionSchemaMapRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.ConnectionSchemaConfig schema_config = 2;
   */
  schemaConfig?: ConnectionSchemaConfig;

  constructor(data?: PartialMessage<GetConnectionSchemaMapRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionSchemaMapRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schema_config", kind: "message", T: ConnectionSchemaConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionSchemaMapRequest {
    return new GetConnectionSchemaMapRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionSchemaMapRequest {
    return new GetConnectionSchemaMapRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionSchemaMapRequest {
    return new GetConnectionSchemaMapRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionSchemaMapRequest | PlainMessage<GetConnectionSchemaMapRequest> | undefined, b: GetConnectionSchemaMapRequest | PlainMessage<GetConnectionSchemaMapRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionSchemaMapRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionSchemaMapResponse
 */
export class GetConnectionSchemaMapResponse extends Message<GetConnectionSchemaMapResponse> {
  /**
   * Returns the database columns separated by the fully qualified <schema>.<table>
   *
   * @generated from field: map<string, mgmt.v1alpha1.GetConnectionSchemaResponse> schema_map = 1;
   */
  schemaMap: { [key: string]: GetConnectionSchemaResponse } = {};

  constructor(data?: PartialMessage<GetConnectionSchemaMapResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionSchemaMapResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema_map", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: GetConnectionSchemaResponse} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionSchemaMapResponse {
    return new GetConnectionSchemaMapResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionSchemaMapResponse {
    return new GetConnectionSchemaMapResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionSchemaMapResponse {
    return new GetConnectionSchemaMapResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionSchemaMapResponse | PlainMessage<GetConnectionSchemaMapResponse> | undefined, b: GetConnectionSchemaMapResponse | PlainMessage<GetConnectionSchemaMapResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionSchemaMapResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionSchemaMapsRequest
 */
export class GetConnectionSchemaMapsRequest extends Message<GetConnectionSchemaMapsRequest> {
  /**
   * List of connection schema maps to request
   *
   * @generated from field: repeated mgmt.v1alpha1.GetConnectionSchemaMapRequest requests = 1;
   */
  requests: GetConnectionSchemaMapRequest[] = [];

  constructor(data?: PartialMessage<GetConnectionSchemaMapsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionSchemaMapsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "requests", kind: "message", T: GetConnectionSchemaMapRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionSchemaMapsRequest {
    return new GetConnectionSchemaMapsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionSchemaMapsRequest {
    return new GetConnectionSchemaMapsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionSchemaMapsRequest {
    return new GetConnectionSchemaMapsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionSchemaMapsRequest | PlainMessage<GetConnectionSchemaMapsRequest> | undefined, b: GetConnectionSchemaMapsRequest | PlainMessage<GetConnectionSchemaMapsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionSchemaMapsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionSchemaMapsResponse
 */
export class GetConnectionSchemaMapsResponse extends Message<GetConnectionSchemaMapsResponse> {
  /**
   * List of responses in the same order as the input
   *
   * @generated from field: repeated mgmt.v1alpha1.GetConnectionSchemaMapResponse responses = 1;
   */
  responses: GetConnectionSchemaMapResponse[] = [];

  /**
   * Parallel array of each connection id that matches with the response
   *
   * @generated from field: repeated string connection_ids = 2;
   */
  connectionIds: string[] = [];

  constructor(data?: PartialMessage<GetConnectionSchemaMapsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionSchemaMapsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "responses", kind: "message", T: GetConnectionSchemaMapResponse, repeated: true },
    { no: 2, name: "connection_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionSchemaMapsResponse {
    return new GetConnectionSchemaMapsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionSchemaMapsResponse {
    return new GetConnectionSchemaMapsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionSchemaMapsResponse {
    return new GetConnectionSchemaMapsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionSchemaMapsResponse | PlainMessage<GetConnectionSchemaMapsResponse> | undefined, b: GetConnectionSchemaMapsResponse | PlainMessage<GetConnectionSchemaMapsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionSchemaMapsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionForeignConstraintsRequest
 */
export class GetConnectionForeignConstraintsRequest extends Message<GetConnectionForeignConstraintsRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  constructor(data?: PartialMessage<GetConnectionForeignConstraintsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionForeignConstraintsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionForeignConstraintsRequest {
    return new GetConnectionForeignConstraintsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionForeignConstraintsRequest {
    return new GetConnectionForeignConstraintsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionForeignConstraintsRequest {
    return new GetConnectionForeignConstraintsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionForeignConstraintsRequest | PlainMessage<GetConnectionForeignConstraintsRequest> | undefined, b: GetConnectionForeignConstraintsRequest | PlainMessage<GetConnectionForeignConstraintsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionForeignConstraintsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ForeignKey
 */
export class ForeignKey extends Message<ForeignKey> {
  /**
   * @generated from field: string table = 1;
   */
  table = "";

  /**
   * @deprecated - use columns
   *
   * @generated from field: string column = 2;
   */
  column = "";

  /**
   * @generated from field: repeated string columns = 3;
   */
  columns: string[] = [];

  constructor(data?: PartialMessage<ForeignKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ForeignKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForeignKey {
    return new ForeignKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForeignKey {
    return new ForeignKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForeignKey {
    return new ForeignKey().fromJsonString(jsonString, options);
  }

  static equals(a: ForeignKey | PlainMessage<ForeignKey> | undefined, b: ForeignKey | PlainMessage<ForeignKey> | undefined): boolean {
    return proto3.util.equals(ForeignKey, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ForeignConstraint
 */
export class ForeignConstraint extends Message<ForeignConstraint> {
  /**
   * @deprecated - use columns
   *
   * @generated from field: string column = 1;
   */
  column = "";

  /**
   * @deprecated - use not_nullable
   *
   * @generated from field: bool is_nullable = 2;
   */
  isNullable = false;

  /**
   * @generated from field: mgmt.v1alpha1.ForeignKey foreign_key = 3;
   */
  foreignKey?: ForeignKey;

  /**
   * @generated from field: repeated string columns = 4;
   */
  columns: string[] = [];

  /**
   * @generated from field: repeated bool not_nullable = 5;
   */
  notNullable: boolean[] = [];

  constructor(data?: PartialMessage<ForeignConstraint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ForeignConstraint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_nullable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "foreign_key", kind: "message", T: ForeignKey },
    { no: 4, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "not_nullable", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForeignConstraint {
    return new ForeignConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForeignConstraint {
    return new ForeignConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForeignConstraint {
    return new ForeignConstraint().fromJsonString(jsonString, options);
  }

  static equals(a: ForeignConstraint | PlainMessage<ForeignConstraint> | undefined, b: ForeignConstraint | PlainMessage<ForeignConstraint> | undefined): boolean {
    return proto3.util.equals(ForeignConstraint, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.ForeignConstraintTables
 */
export class ForeignConstraintTables extends Message<ForeignConstraintTables> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.ForeignConstraint constraints = 1;
   */
  constraints: ForeignConstraint[] = [];

  constructor(data?: PartialMessage<ForeignConstraintTables>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.ForeignConstraintTables";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "constraints", kind: "message", T: ForeignConstraint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ForeignConstraintTables {
    return new ForeignConstraintTables().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ForeignConstraintTables {
    return new ForeignConstraintTables().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ForeignConstraintTables {
    return new ForeignConstraintTables().fromJsonString(jsonString, options);
  }

  static equals(a: ForeignConstraintTables | PlainMessage<ForeignConstraintTables> | undefined, b: ForeignConstraintTables | PlainMessage<ForeignConstraintTables> | undefined): boolean {
    return proto3.util.equals(ForeignConstraintTables, a, b);
  }
}

/**
 * Dependency constraints for a specific table
 *
 * @generated from message mgmt.v1alpha1.GetConnectionForeignConstraintsResponse
 */
export class GetConnectionForeignConstraintsResponse extends Message<GetConnectionForeignConstraintsResponse> {
  /**
   * the key here is <schema>.<table> and the list of tables that it depends on, also `<schema>.<table>` format.
   *
   * @generated from field: map<string, mgmt.v1alpha1.ForeignConstraintTables> table_constraints = 1;
   */
  tableConstraints: { [key: string]: ForeignConstraintTables } = {};

  constructor(data?: PartialMessage<GetConnectionForeignConstraintsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionForeignConstraintsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_constraints", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ForeignConstraintTables} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionForeignConstraintsResponse {
    return new GetConnectionForeignConstraintsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionForeignConstraintsResponse {
    return new GetConnectionForeignConstraintsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionForeignConstraintsResponse {
    return new GetConnectionForeignConstraintsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionForeignConstraintsResponse | PlainMessage<GetConnectionForeignConstraintsResponse> | undefined, b: GetConnectionForeignConstraintsResponse | PlainMessage<GetConnectionForeignConstraintsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionForeignConstraintsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.InitStatementOptions
 */
export class InitStatementOptions extends Message<InitStatementOptions> {
  /**
   * @generated from field: bool init_schema = 1;
   */
  initSchema = false;

  /**
   * @generated from field: bool truncate_before_insert = 2;
   */
  truncateBeforeInsert = false;

  /**
   * @generated from field: bool truncate_cascade = 3;
   */
  truncateCascade = false;

  constructor(data?: PartialMessage<InitStatementOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.InitStatementOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "init_schema", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "truncate_before_insert", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "truncate_cascade", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InitStatementOptions {
    return new InitStatementOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InitStatementOptions {
    return new InitStatementOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InitStatementOptions {
    return new InitStatementOptions().fromJsonString(jsonString, options);
  }

  static equals(a: InitStatementOptions | PlainMessage<InitStatementOptions> | undefined, b: InitStatementOptions | PlainMessage<InitStatementOptions> | undefined): boolean {
    return proto3.util.equals(InitStatementOptions, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionInitStatementsRequest
 */
export class GetConnectionInitStatementsRequest extends Message<GetConnectionInitStatementsRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.InitStatementOptions options = 2;
   */
  options?: InitStatementOptions;

  constructor(data?: PartialMessage<GetConnectionInitStatementsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionInitStatementsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "options", kind: "message", T: InitStatementOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionInitStatementsRequest {
    return new GetConnectionInitStatementsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionInitStatementsRequest {
    return new GetConnectionInitStatementsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionInitStatementsRequest {
    return new GetConnectionInitStatementsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionInitStatementsRequest | PlainMessage<GetConnectionInitStatementsRequest> | undefined, b: GetConnectionInitStatementsRequest | PlainMessage<GetConnectionInitStatementsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionInitStatementsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.SchemaInitStatements
 */
export class SchemaInitStatements extends Message<SchemaInitStatements> {
  /**
   * @generated from field: string label = 1;
   */
  label = "";

  /**
   * @generated from field: repeated string statements = 2;
   */
  statements: string[] = [];

  constructor(data?: PartialMessage<SchemaInitStatements>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.SchemaInitStatements";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "statements", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaInitStatements {
    return new SchemaInitStatements().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaInitStatements {
    return new SchemaInitStatements().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaInitStatements {
    return new SchemaInitStatements().fromJsonString(jsonString, options);
  }

  static equals(a: SchemaInitStatements | PlainMessage<SchemaInitStatements> | undefined, b: SchemaInitStatements | PlainMessage<SchemaInitStatements> | undefined): boolean {
    return proto3.util.equals(SchemaInitStatements, a, b);
  }
}

/**
 * Init statement for a specific table
 *
 * @generated from message mgmt.v1alpha1.GetConnectionInitStatementsResponse
 */
export class GetConnectionInitStatementsResponse extends Message<GetConnectionInitStatementsResponse> {
  /**
   * the key here is <schema>.<table> and value is the table init statement.
   *
   * @generated from field: map<string, string> table_init_statements = 1;
   */
  tableInitStatements: { [key: string]: string } = {};

  /**
   * the key here is <schema>.<table> and value is the table truncate statement.
   *
   * @generated from field: map<string, string> table_truncate_statements = 2;
   */
  tableTruncateStatements: { [key: string]: string } = {};

  /**
   * @generated from field: repeated mgmt.v1alpha1.SchemaInitStatements schema_init_statements = 3;
   */
  schemaInitStatements: SchemaInitStatements[] = [];

  constructor(data?: PartialMessage<GetConnectionInitStatementsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionInitStatementsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_init_statements", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 2, name: "table_truncate_statements", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "schema_init_statements", kind: "message", T: SchemaInitStatements, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionInitStatementsResponse {
    return new GetConnectionInitStatementsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionInitStatementsResponse {
    return new GetConnectionInitStatementsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionInitStatementsResponse {
    return new GetConnectionInitStatementsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionInitStatementsResponse | PlainMessage<GetConnectionInitStatementsResponse> | undefined, b: GetConnectionInitStatementsResponse | PlainMessage<GetConnectionInitStatementsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionInitStatementsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.PrimaryConstraint
 */
export class PrimaryConstraint extends Message<PrimaryConstraint> {
  /**
   * @generated from field: repeated string columns = 1;
   */
  columns: string[] = [];

  constructor(data?: PartialMessage<PrimaryConstraint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.PrimaryConstraint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrimaryConstraint {
    return new PrimaryConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrimaryConstraint {
    return new PrimaryConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrimaryConstraint {
    return new PrimaryConstraint().fromJsonString(jsonString, options);
  }

  static equals(a: PrimaryConstraint | PlainMessage<PrimaryConstraint> | undefined, b: PrimaryConstraint | PlainMessage<PrimaryConstraint> | undefined): boolean {
    return proto3.util.equals(PrimaryConstraint, a, b);
  }
}

/**
 * Primary constraints for a specific table
 *
 * @generated from message mgmt.v1alpha1.GetConnectionPrimaryConstraintsRequest
 */
export class GetConnectionPrimaryConstraintsRequest extends Message<GetConnectionPrimaryConstraintsRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  constructor(data?: PartialMessage<GetConnectionPrimaryConstraintsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionPrimaryConstraintsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionPrimaryConstraintsRequest {
    return new GetConnectionPrimaryConstraintsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionPrimaryConstraintsRequest {
    return new GetConnectionPrimaryConstraintsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionPrimaryConstraintsRequest {
    return new GetConnectionPrimaryConstraintsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionPrimaryConstraintsRequest | PlainMessage<GetConnectionPrimaryConstraintsRequest> | undefined, b: GetConnectionPrimaryConstraintsRequest | PlainMessage<GetConnectionPrimaryConstraintsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionPrimaryConstraintsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionPrimaryConstraintsResponse
 */
export class GetConnectionPrimaryConstraintsResponse extends Message<GetConnectionPrimaryConstraintsResponse> {
  /**
   * the key here is <schema>.<table> and value is the primary constraint
   *
   * @generated from field: map<string, mgmt.v1alpha1.PrimaryConstraint> table_constraints = 1;
   */
  tableConstraints: { [key: string]: PrimaryConstraint } = {};

  constructor(data?: PartialMessage<GetConnectionPrimaryConstraintsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionPrimaryConstraintsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_constraints", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: PrimaryConstraint} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionPrimaryConstraintsResponse {
    return new GetConnectionPrimaryConstraintsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionPrimaryConstraintsResponse {
    return new GetConnectionPrimaryConstraintsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionPrimaryConstraintsResponse {
    return new GetConnectionPrimaryConstraintsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionPrimaryConstraintsResponse | PlainMessage<GetConnectionPrimaryConstraintsResponse> | undefined, b: GetConnectionPrimaryConstraintsResponse | PlainMessage<GetConnectionPrimaryConstraintsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionPrimaryConstraintsResponse, a, b);
  }
}

/**
 * Unique constraints for a specific table
 *
 * @generated from message mgmt.v1alpha1.GetConnectionUniqueConstraintsRequest
 */
export class GetConnectionUniqueConstraintsRequest extends Message<GetConnectionUniqueConstraintsRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  constructor(data?: PartialMessage<GetConnectionUniqueConstraintsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionUniqueConstraintsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionUniqueConstraintsRequest {
    return new GetConnectionUniqueConstraintsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionUniqueConstraintsRequest {
    return new GetConnectionUniqueConstraintsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionUniqueConstraintsRequest {
    return new GetConnectionUniqueConstraintsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionUniqueConstraintsRequest | PlainMessage<GetConnectionUniqueConstraintsRequest> | undefined, b: GetConnectionUniqueConstraintsRequest | PlainMessage<GetConnectionUniqueConstraintsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionUniqueConstraintsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionUniqueConstraintsResponse
 */
export class GetConnectionUniqueConstraintsResponse extends Message<GetConnectionUniqueConstraintsResponse> {
  /**
   * the key here is <schema>.<table> and value is the unique constraint
   *
   * @generated from field: map<string, mgmt.v1alpha1.UniqueConstraint> table_constraints = 1;
   */
  tableConstraints: { [key: string]: UniqueConstraint } = {};

  constructor(data?: PartialMessage<GetConnectionUniqueConstraintsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionUniqueConstraintsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_constraints", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: UniqueConstraint} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionUniqueConstraintsResponse {
    return new GetConnectionUniqueConstraintsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionUniqueConstraintsResponse {
    return new GetConnectionUniqueConstraintsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionUniqueConstraintsResponse {
    return new GetConnectionUniqueConstraintsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionUniqueConstraintsResponse | PlainMessage<GetConnectionUniqueConstraintsResponse> | undefined, b: GetConnectionUniqueConstraintsResponse | PlainMessage<GetConnectionUniqueConstraintsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionUniqueConstraintsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UniqueConstraint
 */
export class UniqueConstraint extends Message<UniqueConstraint> {
  /**
   * @generated from field: repeated string columns = 1;
   */
  columns: string[] = [];

  constructor(data?: PartialMessage<UniqueConstraint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UniqueConstraint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UniqueConstraint {
    return new UniqueConstraint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UniqueConstraint {
    return new UniqueConstraint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UniqueConstraint {
    return new UniqueConstraint().fromJsonString(jsonString, options);
  }

  static equals(a: UniqueConstraint | PlainMessage<UniqueConstraint> | undefined, b: UniqueConstraint | PlainMessage<UniqueConstraint> | undefined): boolean {
    return proto3.util.equals(UniqueConstraint, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetAiGeneratedDataRequest
 */
export class GetAiGeneratedDataRequest extends Message<GetAiGeneratedDataRequest> {
  /**
   * @generated from field: string ai_connection_id = 1;
   */
  aiConnectionId = "";

  /**
   * @generated from field: int64 count = 2;
   */
  count = protoInt64.zero;

  /**
   * @generated from field: string model_name = 3;
   */
  modelName = "";

  /**
   * @generated from field: optional string user_prompt = 4;
   */
  userPrompt?: string;

  /**
   * @generated from field: string data_connection_id = 5;
   */
  dataConnectionId = "";

  /**
   * @generated from field: mgmt.v1alpha1.DatabaseTable table = 6;
   */
  table?: DatabaseTable;

  constructor(data?: PartialMessage<GetAiGeneratedDataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetAiGeneratedDataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ai_connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "model_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "user_prompt", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "data_connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "table", kind: "message", T: DatabaseTable },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAiGeneratedDataRequest {
    return new GetAiGeneratedDataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAiGeneratedDataRequest {
    return new GetAiGeneratedDataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAiGeneratedDataRequest {
    return new GetAiGeneratedDataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAiGeneratedDataRequest | PlainMessage<GetAiGeneratedDataRequest> | undefined, b: GetAiGeneratedDataRequest | PlainMessage<GetAiGeneratedDataRequest> | undefined): boolean {
    return proto3.util.equals(GetAiGeneratedDataRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.DatabaseTable
 */
export class DatabaseTable extends Message<DatabaseTable> {
  /**
   * @generated from field: string schema = 1;
   */
  schema = "";

  /**
   * @generated from field: string table = 2;
   */
  table = "";

  constructor(data?: PartialMessage<DatabaseTable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.DatabaseTable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseTable {
    return new DatabaseTable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseTable {
    return new DatabaseTable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseTable {
    return new DatabaseTable().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseTable | PlainMessage<DatabaseTable> | undefined, b: DatabaseTable | PlainMessage<DatabaseTable> | undefined): boolean {
    return proto3.util.equals(DatabaseTable, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetAiGeneratedDataResponse
 */
export class GetAiGeneratedDataResponse extends Message<GetAiGeneratedDataResponse> {
  /**
   * A list of generated records
   *
   * @generated from field: repeated google.protobuf.Struct records = 1;
   */
  records: Struct[] = [];

  constructor(data?: PartialMessage<GetAiGeneratedDataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetAiGeneratedDataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "records", kind: "message", T: Struct, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAiGeneratedDataResponse {
    return new GetAiGeneratedDataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAiGeneratedDataResponse {
    return new GetAiGeneratedDataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAiGeneratedDataResponse {
    return new GetAiGeneratedDataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAiGeneratedDataResponse | PlainMessage<GetAiGeneratedDataResponse> | undefined, b: GetAiGeneratedDataResponse | PlainMessage<GetAiGeneratedDataResponse> | undefined): boolean {
    return proto3.util.equals(GetAiGeneratedDataResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionTableConstraintsRequest
 */
export class GetConnectionTableConstraintsRequest extends Message<GetConnectionTableConstraintsRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  constructor(data?: PartialMessage<GetConnectionTableConstraintsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionTableConstraintsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionTableConstraintsRequest {
    return new GetConnectionTableConstraintsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionTableConstraintsRequest {
    return new GetConnectionTableConstraintsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionTableConstraintsRequest {
    return new GetConnectionTableConstraintsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionTableConstraintsRequest | PlainMessage<GetConnectionTableConstraintsRequest> | undefined, b: GetConnectionTableConstraintsRequest | PlainMessage<GetConnectionTableConstraintsRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionTableConstraintsRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.UniqueConstraints
 */
export class UniqueConstraints extends Message<UniqueConstraints> {
  /**
   * @generated from field: repeated mgmt.v1alpha1.UniqueConstraint constraints = 1;
   */
  constraints: UniqueConstraint[] = [];

  constructor(data?: PartialMessage<UniqueConstraints>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.UniqueConstraints";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "constraints", kind: "message", T: UniqueConstraint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UniqueConstraints {
    return new UniqueConstraints().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UniqueConstraints {
    return new UniqueConstraints().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UniqueConstraints {
    return new UniqueConstraints().fromJsonString(jsonString, options);
  }

  static equals(a: UniqueConstraints | PlainMessage<UniqueConstraints> | undefined, b: UniqueConstraints | PlainMessage<UniqueConstraints> | undefined): boolean {
    return proto3.util.equals(UniqueConstraints, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetConnectionTableConstraintsResponse
 */
export class GetConnectionTableConstraintsResponse extends Message<GetConnectionTableConstraintsResponse> {
  /**
   * the key here is <schema>.<table> and the list of tables that it depends on, also `<schema>.<table>` format.
   *
   * @generated from field: map<string, mgmt.v1alpha1.ForeignConstraintTables> foreign_key_constraints = 1;
   */
  foreignKeyConstraints: { [key: string]: ForeignConstraintTables } = {};

  /**
   * the key here is <schema>.<table> and value is the primary constraint
   *
   * @generated from field: map<string, mgmt.v1alpha1.PrimaryConstraint> primary_key_constraints = 2;
   */
  primaryKeyConstraints: { [key: string]: PrimaryConstraint } = {};

  /**
   * the key here is <schema>.<table> and value is the unique constraint
   *
   * @generated from field: map<string, mgmt.v1alpha1.UniqueConstraints> unique_constraints = 3;
   */
  uniqueConstraints: { [key: string]: UniqueConstraints } = {};

  constructor(data?: PartialMessage<GetConnectionTableConstraintsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetConnectionTableConstraintsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "foreign_key_constraints", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ForeignConstraintTables} },
    { no: 2, name: "primary_key_constraints", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: PrimaryConstraint} },
    { no: 3, name: "unique_constraints", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: UniqueConstraints} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionTableConstraintsResponse {
    return new GetConnectionTableConstraintsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionTableConstraintsResponse {
    return new GetConnectionTableConstraintsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionTableConstraintsResponse {
    return new GetConnectionTableConstraintsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionTableConstraintsResponse | PlainMessage<GetConnectionTableConstraintsResponse> | undefined, b: GetConnectionTableConstraintsResponse | PlainMessage<GetConnectionTableConstraintsResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionTableConstraintsResponse, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetTableRowCountRequest
 */
export class GetTableRowCountRequest extends Message<GetTableRowCountRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  /**
   * @generated from field: string schema = 2;
   */
  schema = "";

  /**
   * @generated from field: string table = 3;
   */
  table = "";

  /**
   * @generated from field: optional string where_clause = 4;
   */
  whereClause?: string;

  constructor(data?: PartialMessage<GetTableRowCountRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetTableRowCountRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "schema", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "where_clause", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTableRowCountRequest {
    return new GetTableRowCountRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTableRowCountRequest {
    return new GetTableRowCountRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTableRowCountRequest {
    return new GetTableRowCountRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTableRowCountRequest | PlainMessage<GetTableRowCountRequest> | undefined, b: GetTableRowCountRequest | PlainMessage<GetTableRowCountRequest> | undefined): boolean {
    return proto3.util.equals(GetTableRowCountRequest, a, b);
  }
}

/**
 * @generated from message mgmt.v1alpha1.GetTableRowCountResponse
 */
export class GetTableRowCountResponse extends Message<GetTableRowCountResponse> {
  /**
   * @generated from field: int64 count = 1;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<GetTableRowCountResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "mgmt.v1alpha1.GetTableRowCountResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTableRowCountResponse {
    return new GetTableRowCountResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTableRowCountResponse {
    return new GetTableRowCountResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTableRowCountResponse {
    return new GetTableRowCountResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTableRowCountResponse | PlainMessage<GetTableRowCountResponse> | undefined, b: GetTableRowCountResponse | PlainMessage<GetTableRowCountResponse> | undefined): boolean {
    return proto3.util.equals(GetTableRowCountResponse, a, b);
  }
}

