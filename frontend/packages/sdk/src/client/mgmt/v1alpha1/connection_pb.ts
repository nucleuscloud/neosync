// @generated by protoc-gen-es v2.2.3 with parameter "target=ts,import_extension=.js"
// @generated from file mgmt/v1alpha1/connection.proto (package mgmt.v1alpha1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../buf/validate/validate_pb.js";
import type { FieldMask, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_field_mask, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file mgmt/v1alpha1/connection.proto.
 */
export const file_mgmt_v1alpha1_connection: GenFile = /*@__PURE__*/
  fileDesc("Ch5tZ210L3YxYWxwaGExL2Nvbm5lY3Rpb24ucHJvdG8SDW1nbXQudjFhbHBoYTEiUAoVR2V0Q29ubmVjdGlvbnNSZXF1ZXN0EhwKCmFjY291bnRfaWQYASABKAlCCLpIBXIDsAEBEhkKEWV4Y2x1ZGVfc2Vuc2l0aXZlGAIgASgIIkgKFkdldENvbm5lY3Rpb25zUmVzcG9uc2USLgoLY29ubmVjdGlvbnMYASADKAsyGS5tZ210LnYxYWxwaGExLkNvbm5lY3Rpb24iRwoUR2V0Q29ubmVjdGlvblJlcXVlc3QSFAoCaWQYASABKAlCCLpIBXIDsAEBEhkKEWV4Y2x1ZGVfc2Vuc2l0aXZlGAIgASgIIkYKFUdldENvbm5lY3Rpb25SZXNwb25zZRItCgpjb25uZWN0aW9uGAEgASgLMhkubWdtdC52MWFscGhhMS5Db25uZWN0aW9uIpwBChdDcmVhdGVDb25uZWN0aW9uUmVxdWVzdBIcCgphY2NvdW50X2lkGAEgASgJQgi6SAVyA7ABARInCgRuYW1lGAIgASgJQhm6SBZyFDISXlthLXowLTktXXszLDEwMH0kEjoKEWNvbm5lY3Rpb25fY29uZmlnGAMgASgLMh8ubWdtdC52MWFscGhhMS5Db25uZWN0aW9uQ29uZmlnIkkKGENyZWF0ZUNvbm5lY3Rpb25SZXNwb25zZRItCgpjb25uZWN0aW9uGAEgASgLMhkubWdtdC52MWFscGhhMS5Db25uZWN0aW9uItoBChdVcGRhdGVDb25uZWN0aW9uUmVxdWVzdBIUCgJpZBgBIAEoCUIIukgFcgOwAQESJwoEbmFtZRgCIAEoCUIZukgWchQyEl5bYS16MC05LV17MywxMDB9JBI6ChFjb25uZWN0aW9uX2NvbmZpZxgDIAEoCzIfLm1nbXQudjFhbHBoYTEuQ29ubmVjdGlvbkNvbmZpZxI0Cgt1cGRhdGVfbWFzaxgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5GaWVsZE1hc2tIAIgBAUIOCgxfdXBkYXRlX21hc2siSQoYVXBkYXRlQ29ubmVjdGlvblJlc3BvbnNlEi0KCmNvbm5lY3Rpb24YASABKAsyGS5tZ210LnYxYWxwaGExLkNvbm5lY3Rpb24iLwoXRGVsZXRlQ29ubmVjdGlvblJlcXVlc3QSFAoCaWQYASABKAlCCLpIBXIDsAEBIhoKGERlbGV0ZUNvbm5lY3Rpb25SZXNwb25zZSJaChxDaGVja0Nvbm5lY3Rpb25Db25maWdSZXF1ZXN0EjoKEWNvbm5lY3Rpb25fY29uZmlnGAEgASgLMh8ubWdtdC52MWFscGhhMS5Db25uZWN0aW9uQ29uZmlnIjgKIENoZWNrQ29ubmVjdGlvbkNvbmZpZ0J5SWRSZXF1ZXN0EhQKAmlkGAEgASgJQgi6SAVyA7ABASKpAQohQ2hlY2tDb25uZWN0aW9uQ29uZmlnQnlJZFJlc3BvbnNlEhQKDGlzX2Nvbm5lY3RlZBgBIAEoCBIdChBjb25uZWN0aW9uX2Vycm9yGAIgASgJSACIAQESOgoKcHJpdmlsZWdlcxgDIAMoCzImLm1nbXQudjFhbHBoYTEuQ29ubmVjdGlvblJvbGVQcml2aWxlZ2VCEwoRX2Nvbm5lY3Rpb25fZXJyb3IipQEKHUNoZWNrQ29ubmVjdGlvbkNvbmZpZ1Jlc3BvbnNlEhQKDGlzX2Nvbm5lY3RlZBgBIAEoCBIdChBjb25uZWN0aW9uX2Vycm9yGAIgASgJSACIAQESOgoKcHJpdmlsZWdlcxgDIAMoCzImLm1nbXQudjFhbHBoYTEuQ29ubmVjdGlvblJvbGVQcml2aWxlZ2VCEwoRX2Nvbm5lY3Rpb25fZXJyb3IiYQoXQ29ubmVjdGlvblJvbGVQcml2aWxlZ2USDwoHZ3JhbnRlZRgBIAEoCRIOCgZzY2hlbWEYAiABKAkSDQoFdGFibGUYAyABKAkSFgoOcHJpdmlsZWdlX3R5cGUYBCADKAkijgIKCkNvbm5lY3Rpb24SCgoCaWQYASABKAkSDAoEbmFtZRgCIAEoCRI6ChFjb25uZWN0aW9uX2NvbmZpZxgDIAEoCzIfLm1nbXQudjFhbHBoYTEuQ29ubmVjdGlvbkNvbmZpZxIaChJjcmVhdGVkX2J5X3VzZXJfaWQYBCABKAkSLgoKY3JlYXRlZF9hdBgFIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASGgoSdXBkYXRlZF9ieV91c2VyX2lkGAYgASgJEi4KCnVwZGF0ZWRfYXQYByABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhIKCmFjY291bnRfaWQYCCABKAki/AQKEENvbm5lY3Rpb25Db25maWcSPAoJcGdfY29uZmlnGAEgASgLMicubWdtdC52MWFscGhhMS5Qb3N0Z3Jlc0Nvbm5lY3Rpb25Db25maWdIABI9Cg1hd3NfczNfY29uZmlnGAIgASgLMiQubWdtdC52MWFscGhhMS5Bd3NTM0Nvbm5lY3Rpb25Db25maWdIABI8CgxteXNxbF9jb25maWcYAyABKAsyJC5tZ210LnYxYWxwaGExLk15c3FsQ29ubmVjdGlvbkNvbmZpZ0gAEkkKEGxvY2FsX2Rpcl9jb25maWcYBCABKAsyLS5tZ210LnYxYWxwaGExLkxvY2FsRGlyZWN0b3J5Q29ubmVjdGlvbkNvbmZpZ0gAEj4KDW9wZW5haV9jb25maWcYBSABKAsyJS5tZ210LnYxYWxwaGExLk9wZW5BaUNvbm5lY3Rpb25Db25maWdIABI8Cgxtb25nb19jb25maWcYBiABKAsyJC5tZ210LnYxYWxwaGExLk1vbmdvQ29ubmVjdGlvbkNvbmZpZ0gAElEKF2djcF9jbG91ZHN0b3JhZ2VfY29uZmlnGAcgASgLMi4ubWdtdC52MWFscGhhMS5HY3BDbG91ZFN0b3JhZ2VDb25uZWN0aW9uQ29uZmlnSAASQgoPZHluYW1vZGJfY29uZmlnGAggASgLMicubWdtdC52MWFscGhhMS5EeW5hbW9EQkNvbm5lY3Rpb25Db25maWdIABI8Cgxtc3NxbF9jb25maWcYCSABKAsyJC5tZ210LnYxYWxwaGExLk1zc3FsQ29ubmVjdGlvbkNvbmZpZ0gAQg8KBmNvbmZpZxIFukgCCAEi+QEKFU1zc3FsQ29ubmVjdGlvbkNvbmZpZxINCgN1cmwYASABKAlIABIWCgx1cmxfZnJvbV9lbnYYBSABKAlIABI/ChJjb25uZWN0aW9uX29wdGlvbnMYAiABKAsyIy5tZ210LnYxYWxwaGExLlNxbENvbm5lY3Rpb25PcHRpb25zEigKBnR1bm5lbBgDIAEoCzIYLm1nbXQudjFhbHBoYTEuU1NIVHVubmVsEjIKCmNsaWVudF90bHMYBCABKAsyHi5tZ210LnYxYWxwaGExLkNsaWVudFRsc0NvbmZpZ0IaChFjb25uZWN0aW9uX2NvbmZpZxIFukgCCAEiqQEKGER5bmFtb0RCQ29ubmVjdGlvbkNvbmZpZxI5CgtjcmVkZW50aWFscxgBIAEoCzIfLm1nbXQudjFhbHBoYTEuQXdzUzNDcmVkZW50aWFsc0gAiAEBEhMKBnJlZ2lvbhgCIAEoCUgBiAEBEhUKCGVuZHBvaW50GAMgASgJSAKIAQFCDgoMX2NyZWRlbnRpYWxzQgkKB19yZWdpb25CCwoJX2VuZHBvaW50IqABChVNb25nb0Nvbm5lY3Rpb25Db25maWcSDQoDdXJsGAEgASgJSAASKAoGdHVubmVsGAIgASgLMhgubWdtdC52MWFscGhhMS5TU0hUdW5uZWwSMgoKY2xpZW50X3RscxgDIAEoCzIeLm1nbXQudjFhbHBoYTEuQ2xpZW50VGxzQ29uZmlnQhoKEWNvbm5lY3Rpb25fY29uZmlnEgW6SAIIASI6ChZPcGVuQWlDb25uZWN0aW9uQ29uZmlnEg8KB2FwaV9rZXkYASABKAkSDwoHYXBpX3VybBgCIAEoCSI3Ch5Mb2NhbERpcmVjdG9yeUNvbm5lY3Rpb25Db25maWcSFQoEcGF0aBgBIAEoCUIHukgEcgIQASK1AgoYUG9zdGdyZXNDb25uZWN0aW9uQ29uZmlnEg0KA3VybBgBIAEoCUgAEjcKCmNvbm5lY3Rpb24YAiABKAsyIS5tZ210LnYxYWxwaGExLlBvc3RncmVzQ29ubmVjdGlvbkgAEhYKDHVybF9mcm9tX2VudhgGIAEoCUgAEigKBnR1bm5lbBgDIAEoCzIYLm1nbXQudjFhbHBoYTEuU1NIVHVubmVsEj8KEmNvbm5lY3Rpb25fb3B0aW9ucxgEIAEoCzIjLm1nbXQudjFhbHBoYTEuU3FsQ29ubmVjdGlvbk9wdGlvbnMSMgoKY2xpZW50X3RscxgFIAEoCzIeLm1nbXQudjFhbHBoYTEuQ2xpZW50VGxzQ29uZmlnQhoKEWNvbm5lY3Rpb25fY29uZmlnEgW6SAIIASKzAQoPQ2xpZW50VGxzQ29uZmlnEhYKCXJvb3RfY2VydBgBIAEoCUgAiAEBEhgKC2NsaWVudF9jZXJ0GAIgASgJSAGIAQESFwoKY2xpZW50X2tleRgDIAEoCUgCiAEBEhgKC3NlcnZlcl9uYW1lGAQgASgJSAOIAQFCDAoKX3Jvb3RfY2VydEIOCgxfY2xpZW50X2NlcnRCDQoLX2NsaWVudF9rZXlCDgoMX3NlcnZlcl9uYW1lIvoBChRTcWxDb25uZWN0aW9uT3B0aW9ucxIhChRtYXhfY29ubmVjdGlvbl9saW1pdBgBIAEoBUgAiAEBEiEKFG1heF9pZGxlX2Nvbm5lY3Rpb25zGAIgASgFSAGIAQESHgoRbWF4X2lkbGVfZHVyYXRpb24YAyABKAlIAogBARIeChFtYXhfb3Blbl9kdXJhdGlvbhgEIAEoCUgDiAEBQhcKFV9tYXhfY29ubmVjdGlvbl9saW1pdEIXChVfbWF4X2lkbGVfY29ubmVjdGlvbnNCFAoSX21heF9pZGxlX2R1cmF0aW9uQhQKEl9tYXhfb3Blbl9kdXJhdGlvbiLRAQoJU1NIVHVubmVsEhUKBGhvc3QYASABKAlCB7pIBHICEAESFQoEcG9ydBgCIAEoBUIHukgEGgIoABIVCgR1c2VyGAMgASgJQge6SARyAhABEisKFWtub3duX2hvc3RfcHVibGljX2tleRgEIAEoCUIHukgEcgIQAUgAiAEBEjgKDmF1dGhlbnRpY2F0aW9uGAUgASgLMiAubWdtdC52MWFscGhhMS5TU0hBdXRoZW50aWNhdGlvbkIYChZfa25vd25faG9zdF9wdWJsaWNfa2V5IpIBChFTU0hBdXRoZW50aWNhdGlvbhIyCgpwYXNzcGhyYXNlGAEgASgLMhwubWdtdC52MWFscGhhMS5TU0hQYXNzcGhyYXNlSAASMwoLcHJpdmF0ZV9rZXkYAiABKAsyHC5tZ210LnYxYWxwaGExLlNTSFByaXZhdGVLZXlIAEIUCgthdXRoX2NvbmZpZxIFukgCCAEiJwoNU1NIUGFzc3BocmFzZRIWCgV2YWx1ZRgBIAEoCUIHukgEcgIQASJPCg1TU0hQcml2YXRlS2V5EhYKBXZhbHVlGAEgASgJQge6SARyAhABEhcKCnBhc3NwaHJhc2UYAiABKAlIAIgBAUINCgtfcGFzc3BocmFzZSJ+ChJQb3N0Z3Jlc0Nvbm5lY3Rpb24SDAoEaG9zdBgBIAEoCRIMCgRwb3J0GAIgASgFEgwKBG5hbWUYAyABKAkSDAoEdXNlchgEIAEoCRIMCgRwYXNzGAUgASgJEhUKCHNzbF9tb2RlGAYgASgJSACIAQFCCwoJX3NzbF9tb2RlImkKD015c3FsQ29ubmVjdGlvbhIMCgR1c2VyGAEgASgJEgwKBHBhc3MYAiABKAkSEAoIcHJvdG9jb2wYAyABKAkSDAoEaG9zdBgEIAEoCRIMCgRwb3J0GAUgASgFEgwKBG5hbWUYBiABKAkirwIKFU15c3FsQ29ubmVjdGlvbkNvbmZpZxINCgN1cmwYASABKAlIABI0Cgpjb25uZWN0aW9uGAIgASgLMh4ubWdtdC52MWFscGhhMS5NeXNxbENvbm5lY3Rpb25IABIWCgx1cmxfZnJvbV9lbnYYBiABKAlIABIoCgZ0dW5uZWwYAyABKAsyGC5tZ210LnYxYWxwaGExLlNTSFR1bm5lbBI/ChJjb25uZWN0aW9uX29wdGlvbnMYBCABKAsyIy5tZ210LnYxYWxwaGExLlNxbENvbm5lY3Rpb25PcHRpb25zEjIKCmNsaWVudF90bHMYBSABKAsyHi5tZ210LnYxYWxwaGExLkNsaWVudFRsc0NvbmZpZ0IaChFjb25uZWN0aW9uX2NvbmZpZxIFukgCCAEi7wEKFUF3c1MzQ29ubmVjdGlvbkNvbmZpZxIYCgtwYXRoX3ByZWZpeBgCIAEoCUgAiAEBEjkKC2NyZWRlbnRpYWxzGAMgASgLMh8ubWdtdC52MWFscGhhMS5Bd3NTM0NyZWRlbnRpYWxzSAGIAQESEwoGcmVnaW9uGAQgASgJSAKIAQESFQoIZW5kcG9pbnQYBSABKAlIA4gBARIXCgZidWNrZXQYBiABKAlCB7pIBHICEAFCDgoMX3BhdGhfcHJlZml4Qg4KDF9jcmVkZW50aWFsc0IJCgdfcmVnaW9uQgsKCV9lbmRwb2ludEoECAEQAiLMAgoQQXdzUzNDcmVkZW50aWFscxIUCgdwcm9maWxlGAEgASgJSACIAQESGgoNYWNjZXNzX2tleV9pZBgCIAEoCUgBiAEBEh4KEXNlY3JldF9hY2Nlc3Nfa2V5GAMgASgJSAKIAQESGgoNc2Vzc2lvbl90b2tlbhgEIAEoCUgDiAEBEhoKDWZyb21fZWMyX3JvbGUYBSABKAhIBIgBARIVCghyb2xlX2FybhgGIAEoCUgFiAEBEh0KEHJvbGVfZXh0ZXJuYWxfaWQYByABKAlIBogBAUIKCghfcHJvZmlsZUIQCg5fYWNjZXNzX2tleV9pZEIUChJfc2VjcmV0X2FjY2Vzc19rZXlCEAoOX3Nlc3Npb25fdG9rZW5CEAoOX2Zyb21fZWMyX3JvbGVCCwoJX3JvbGVfYXJuQhMKEV9yb2xlX2V4dGVybmFsX2lkIq4BCh9HY3BDbG91ZFN0b3JhZ2VDb25uZWN0aW9uQ29uZmlnEhcKBmJ1Y2tldBgBIAEoCUIHukgEcgIQARIYCgtwYXRoX3ByZWZpeBgCIAEoCUgAiAEBEigKG3NlcnZpY2VfYWNjb3VudF9jcmVkZW50aWFscxgDIAEoCUgBiAEBQg4KDF9wYXRoX3ByZWZpeEIeChxfc2VydmljZV9hY2NvdW50X2NyZWRlbnRpYWxzInQKIElzQ29ubmVjdGlvbk5hbWVBdmFpbGFibGVSZXF1ZXN0EhwKCmFjY291bnRfaWQYASABKAlCCLpIBXIDsAEBEjIKD2Nvbm5lY3Rpb25fbmFtZRgCIAEoCUIZukgWchQyEl5bYS16MC05LV17MywxMDB9JCI5CiFJc0Nvbm5lY3Rpb25OYW1lQXZhaWxhYmxlUmVzcG9uc2USFAoMaXNfYXZhaWxhYmxlGAEgASgIIkQKFENoZWNrU3FsUXVlcnlSZXF1ZXN0EhQKAmlkGAEgASgJQgi6SAVyA7ABARIWCgVxdWVyeRgCIAEoCUIHukgEcgIQASJXChVDaGVja1NxbFF1ZXJ5UmVzcG9uc2USEAoIaXNfdmFsaWQYASABKAgSGgoNZXJvcnJfbWVzc2FnZRgCIAEoCUgAiAEBQhAKDl9lcm9ycl9tZXNzYWdlMucHChFDb25uZWN0aW9uU2VydmljZRJiCg5HZXRDb25uZWN0aW9ucxIkLm1nbXQudjFhbHBoYTEuR2V0Q29ubmVjdGlvbnNSZXF1ZXN0GiUubWdtdC52MWFscGhhMS5HZXRDb25uZWN0aW9uc1Jlc3BvbnNlIgOQAgESXwoNR2V0Q29ubmVjdGlvbhIjLm1nbXQudjFhbHBoYTEuR2V0Q29ubmVjdGlvblJlcXVlc3QaJC5tZ210LnYxYWxwaGExLkdldENvbm5lY3Rpb25SZXNwb25zZSIDkAIBEmUKEENyZWF0ZUNvbm5lY3Rpb24SJi5tZ210LnYxYWxwaGExLkNyZWF0ZUNvbm5lY3Rpb25SZXF1ZXN0GicubWdtdC52MWFscGhhMS5DcmVhdGVDb25uZWN0aW9uUmVzcG9uc2UiABJlChBVcGRhdGVDb25uZWN0aW9uEiYubWdtdC52MWFscGhhMS5VcGRhdGVDb25uZWN0aW9uUmVxdWVzdBonLm1nbXQudjFhbHBoYTEuVXBkYXRlQ29ubmVjdGlvblJlc3BvbnNlIgASZQoQRGVsZXRlQ29ubmVjdGlvbhImLm1nbXQudjFhbHBoYTEuRGVsZXRlQ29ubmVjdGlvblJlcXVlc3QaJy5tZ210LnYxYWxwaGExLkRlbGV0ZUNvbm5lY3Rpb25SZXNwb25zZSIAEoABChlJc0Nvbm5lY3Rpb25OYW1lQXZhaWxhYmxlEi8ubWdtdC52MWFscGhhMS5Jc0Nvbm5lY3Rpb25OYW1lQXZhaWxhYmxlUmVxdWVzdBowLm1nbXQudjFhbHBoYTEuSXNDb25uZWN0aW9uTmFtZUF2YWlsYWJsZVJlc3BvbnNlIgASdAoVQ2hlY2tDb25uZWN0aW9uQ29uZmlnEisubWdtdC52MWFscGhhMS5DaGVja0Nvbm5lY3Rpb25Db25maWdSZXF1ZXN0GiwubWdtdC52MWFscGhhMS5DaGVja0Nvbm5lY3Rpb25Db25maWdSZXNwb25zZSIAEoABChlDaGVja0Nvbm5lY3Rpb25Db25maWdCeUlkEi8ubWdtdC52MWFscGhhMS5DaGVja0Nvbm5lY3Rpb25Db25maWdCeUlkUmVxdWVzdBowLm1nbXQudjFhbHBoYTEuQ2hlY2tDb25uZWN0aW9uQ29uZmlnQnlJZFJlc3BvbnNlIgASXAoNQ2hlY2tTcWxRdWVyeRIjLm1nbXQudjFhbHBoYTEuQ2hlY2tTcWxRdWVyeVJlcXVlc3QaJC5tZ210LnYxYWxwaGExLkNoZWNrU3FsUXVlcnlSZXNwb25zZSIAQssBChFjb20ubWdtdC52MWFscGhhMUIPQ29ubmVjdGlvblByb3RvUAFaUGdpdGh1Yi5jb20vbnVjbGV1c2Nsb3VkL25lb3N5bmMvYmFja2VuZC9nZW4vZ28vcHJvdG9zL21nbXQvdjFhbHBoYTE7bWdtdHYxYWxwaGExogIDTVhYqgINTWdtdC5WMWFscGhhMcoCDU1nbXRcVjFhbHBoYTHiAhlNZ210XFYxYWxwaGExXEdQQk1ldGFkYXRh6gIOTWdtdDo6VjFhbHBoYTFiBnByb3RvMw", [file_buf_validate_validate, file_google_protobuf_field_mask, file_google_protobuf_timestamp]);

/**
 * @generated from message mgmt.v1alpha1.GetConnectionsRequest
 */
export type GetConnectionsRequest = Message<"mgmt.v1alpha1.GetConnectionsRequest"> & {
  /**
   * The unique identifier of the account to get connections for
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * Whether or not to exclude sensitive data from the connection
   * If the caller does not have permission to view sensitive data, the connection will always be returned without sensitive data
   * This behavior exists to preserve backwards compatibility that originally always returned sensitive data
   *
   * @generated from field: bool exclude_sensitive = 2;
   */
  excludeSensitive: boolean;
};

/**
 * Describes the message mgmt.v1alpha1.GetConnectionsRequest.
 * Use `create(GetConnectionsRequestSchema)` to create a new message.
 */
export const GetConnectionsRequestSchema: GenMessage<GetConnectionsRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 0);

/**
 * @generated from message mgmt.v1alpha1.GetConnectionsResponse
 */
export type GetConnectionsResponse = Message<"mgmt.v1alpha1.GetConnectionsResponse"> & {
  /**
   * The connections
   *
   * @generated from field: repeated mgmt.v1alpha1.Connection connections = 1;
   */
  connections: Connection[];
};

/**
 * Describes the message mgmt.v1alpha1.GetConnectionsResponse.
 * Use `create(GetConnectionsResponseSchema)` to create a new message.
 */
export const GetConnectionsResponseSchema: GenMessage<GetConnectionsResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 1);

/**
 * @generated from message mgmt.v1alpha1.GetConnectionRequest
 */
export type GetConnectionRequest = Message<"mgmt.v1alpha1.GetConnectionRequest"> & {
  /**
   * The unique identifier of the connection to get
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Whether or not to exclude sensitive data from the connection
   * If the caller does not have permission to view sensitive data, the connection will always be returned without sensitive data
   * This behavior exists to preserve backwards compatibility that originally always returned sensitive data
   *
   * @generated from field: bool exclude_sensitive = 2;
   */
  excludeSensitive: boolean;
};

/**
 * Describes the message mgmt.v1alpha1.GetConnectionRequest.
 * Use `create(GetConnectionRequestSchema)` to create a new message.
 */
export const GetConnectionRequestSchema: GenMessage<GetConnectionRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 2);

/**
 * @generated from message mgmt.v1alpha1.GetConnectionResponse
 */
export type GetConnectionResponse = Message<"mgmt.v1alpha1.GetConnectionResponse"> & {
  /**
   * The connection
   *
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;
};

/**
 * Describes the message mgmt.v1alpha1.GetConnectionResponse.
 * Use `create(GetConnectionResponseSchema)` to create a new message.
 */
export const GetConnectionResponseSchema: GenMessage<GetConnectionResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 3);

/**
 * @generated from message mgmt.v1alpha1.CreateConnectionRequest
 */
export type CreateConnectionRequest = Message<"mgmt.v1alpha1.CreateConnectionRequest"> & {
  /**
   * The unique identifier of the account to create the connection for
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The friendly name of the connection
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The connection configuration to use for the connection
   *
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;
};

/**
 * Describes the message mgmt.v1alpha1.CreateConnectionRequest.
 * Use `create(CreateConnectionRequestSchema)` to create a new message.
 */
export const CreateConnectionRequestSchema: GenMessage<CreateConnectionRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 4);

/**
 * @generated from message mgmt.v1alpha1.CreateConnectionResponse
 */
export type CreateConnectionResponse = Message<"mgmt.v1alpha1.CreateConnectionResponse"> & {
  /**
   * The created connection
   *
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;
};

/**
 * Describes the message mgmt.v1alpha1.CreateConnectionResponse.
 * Use `create(CreateConnectionResponseSchema)` to create a new message.
 */
export const CreateConnectionResponseSchema: GenMessage<CreateConnectionResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 5);

/**
 * @generated from message mgmt.v1alpha1.UpdateConnectionRequest
 */
export type UpdateConnectionRequest = Message<"mgmt.v1alpha1.UpdateConnectionRequest"> & {
  /**
   * The unique identifier of the connection to update
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The friendly name of the connection
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The connection configuration to use for the connection
   *
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;

  /**
   * The field mask to update
   *
   * @generated from field: optional google.protobuf.FieldMask update_mask = 4;
   */
  updateMask?: FieldMask;
};

/**
 * Describes the message mgmt.v1alpha1.UpdateConnectionRequest.
 * Use `create(UpdateConnectionRequestSchema)` to create a new message.
 */
export const UpdateConnectionRequestSchema: GenMessage<UpdateConnectionRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 6);

/**
 * @generated from message mgmt.v1alpha1.UpdateConnectionResponse
 */
export type UpdateConnectionResponse = Message<"mgmt.v1alpha1.UpdateConnectionResponse"> & {
  /**
   * The updated connection
   *
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;
};

/**
 * Describes the message mgmt.v1alpha1.UpdateConnectionResponse.
 * Use `create(UpdateConnectionResponseSchema)` to create a new message.
 */
export const UpdateConnectionResponseSchema: GenMessage<UpdateConnectionResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 7);

/**
 * @generated from message mgmt.v1alpha1.DeleteConnectionRequest
 */
export type DeleteConnectionRequest = Message<"mgmt.v1alpha1.DeleteConnectionRequest"> & {
  /**
   * The unique identifier of the connection to delete
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message mgmt.v1alpha1.DeleteConnectionRequest.
 * Use `create(DeleteConnectionRequestSchema)` to create a new message.
 */
export const DeleteConnectionRequestSchema: GenMessage<DeleteConnectionRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 8);

/**
 * @generated from message mgmt.v1alpha1.DeleteConnectionResponse
 */
export type DeleteConnectionResponse = Message<"mgmt.v1alpha1.DeleteConnectionResponse"> & {
};

/**
 * Describes the message mgmt.v1alpha1.DeleteConnectionResponse.
 * Use `create(DeleteConnectionResponseSchema)` to create a new message.
 */
export const DeleteConnectionResponseSchema: GenMessage<DeleteConnectionResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 9);

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigRequest
 */
export type CheckConnectionConfigRequest = Message<"mgmt.v1alpha1.CheckConnectionConfigRequest"> & {
  /**
   * The connection configuration to validate
   *
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 1;
   */
  connectionConfig?: ConnectionConfig;
};

/**
 * Describes the message mgmt.v1alpha1.CheckConnectionConfigRequest.
 * Use `create(CheckConnectionConfigRequestSchema)` to create a new message.
 */
export const CheckConnectionConfigRequestSchema: GenMessage<CheckConnectionConfigRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 10);

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigByIdRequest
 */
export type CheckConnectionConfigByIdRequest = Message<"mgmt.v1alpha1.CheckConnectionConfigByIdRequest"> & {
  /**
   * The connection id to validate
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message mgmt.v1alpha1.CheckConnectionConfigByIdRequest.
 * Use `create(CheckConnectionConfigByIdRequestSchema)` to create a new message.
 */
export const CheckConnectionConfigByIdRequestSchema: GenMessage<CheckConnectionConfigByIdRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 11);

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigByIdResponse
 */
export type CheckConnectionConfigByIdResponse = Message<"mgmt.v1alpha1.CheckConnectionConfigByIdResponse"> & {
  /**
   * Whether or not the API was able to ping the connection
   *
   * @generated from field: bool is_connected = 1;
   */
  isConnected: boolean;

  /**
   * This is the error that was received if the API was unable to connect
   *
   * @generated from field: optional string connection_error = 2;
   */
  connectionError?: string;

  /**
   * The privileges the role has to the connection
   *
   * @generated from field: repeated mgmt.v1alpha1.ConnectionRolePrivilege privileges = 3;
   */
  privileges: ConnectionRolePrivilege[];
};

/**
 * Describes the message mgmt.v1alpha1.CheckConnectionConfigByIdResponse.
 * Use `create(CheckConnectionConfigByIdResponseSchema)` to create a new message.
 */
export const CheckConnectionConfigByIdResponseSchema: GenMessage<CheckConnectionConfigByIdResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 12);

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigResponse
 */
export type CheckConnectionConfigResponse = Message<"mgmt.v1alpha1.CheckConnectionConfigResponse"> & {
  /**
   * Whether or not the API was able to ping the connection
   *
   * @generated from field: bool is_connected = 1;
   */
  isConnected: boolean;

  /**
   * This is the error that was received if the API was unable to connect
   *
   * @generated from field: optional string connection_error = 2;
   */
  connectionError?: string;

  /**
   * @generated from field: repeated mgmt.v1alpha1.ConnectionRolePrivilege privileges = 3;
   */
  privileges: ConnectionRolePrivilege[];
};

/**
 * Describes the message mgmt.v1alpha1.CheckConnectionConfigResponse.
 * Use `create(CheckConnectionConfigResponseSchema)` to create a new message.
 */
export const CheckConnectionConfigResponseSchema: GenMessage<CheckConnectionConfigResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 13);

/**
 * @generated from message mgmt.v1alpha1.ConnectionRolePrivilege
 */
export type ConnectionRolePrivilege = Message<"mgmt.v1alpha1.ConnectionRolePrivilege"> & {
  /**
   * The role that was given the permissions
   *
   * @generated from field: string grantee = 1;
   */
  grantee: string;

  /**
   * The database schema. Ex: public
   *
   * @generated from field: string schema = 2;
   */
  schema: string;

  /**
   * The name of the table in the schema
   *
   * @generated from field: string table = 3;
   */
  table: string;

  /**
   * The privileges given to that role
   *
   * @generated from field: repeated string privilege_type = 4;
   */
  privilegeType: string[];
};

/**
 * Describes the message mgmt.v1alpha1.ConnectionRolePrivilege.
 * Use `create(ConnectionRolePrivilegeSchema)` to create a new message.
 */
export const ConnectionRolePrivilegeSchema: GenMessage<ConnectionRolePrivilege> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 14);

/**
 * @generated from message mgmt.v1alpha1.Connection
 */
export type Connection = Message<"mgmt.v1alpha1.Connection"> & {
  /**
   * The unique identifier of the connection
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The unique, friendly name of the connection
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Contains the connection configuration and connection type
   *
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;

  /**
   * The user id of the user that created the connection
   *
   * @generated from field: string created_by_user_id = 4;
   */
  createdByUserId: string;

  /**
   * When the connection was created
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * Who last updated the connection
   *
   * @generated from field: string updated_by_user_id = 6;
   */
  updatedByUserId: string;

  /**
   * When the connection was last updated
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 7;
   */
  updatedAt?: Timestamp;

  /**
   * The unique account that owns this connection
   *
   * @generated from field: string account_id = 8;
   */
  accountId: string;
};

/**
 * Describes the message mgmt.v1alpha1.Connection.
 * Use `create(ConnectionSchema)` to create a new message.
 */
export const ConnectionSchema: GenMessage<Connection> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 15);

/**
 * Configuration for all of the supported Neosync connection types
 *
 * @generated from message mgmt.v1alpha1.ConnectionConfig
 */
export type ConnectionConfig = Message<"mgmt.v1alpha1.ConnectionConfig"> & {
  /**
   * @generated from oneof mgmt.v1alpha1.ConnectionConfig.config
   */
  config: {
    /**
     * Configures a PostgreSQL connection
     *
     * @generated from field: mgmt.v1alpha1.PostgresConnectionConfig pg_config = 1;
     */
    value: PostgresConnectionConfig;
    case: "pgConfig";
  } | {
    /**
     * Configures an AWS S3 Connection
     *
     * @generated from field: mgmt.v1alpha1.AwsS3ConnectionConfig aws_s3_config = 2;
     */
    value: AwsS3ConnectionConfig;
    case: "awsS3Config";
  } | {
    /**
     * Configures a MySQL connection
     *
     * @generated from field: mgmt.v1alpha1.MysqlConnectionConfig mysql_config = 3;
     */
    value: MysqlConnectionConfig;
    case: "mysqlConfig";
  } | {
    /**
     * Configures a connection to a directory available on the local file system
     *
     * @generated from field: mgmt.v1alpha1.LocalDirectoryConnectionConfig local_dir_config = 4;
     */
    value: LocalDirectoryConnectionConfig;
    case: "localDirConfig";
  } | {
    /**
     * Connection config for an OpenAI (or compatible) Connection
     *
     * @generated from field: mgmt.v1alpha1.OpenAiConnectionConfig openai_config = 5;
     */
    value: OpenAiConnectionConfig;
    case: "openaiConfig";
  } | {
    /**
     * Configures a MongoDB Connection
     *
     * @generated from field: mgmt.v1alpha1.MongoConnectionConfig mongo_config = 6;
     */
    value: MongoConnectionConfig;
    case: "mongoConfig";
  } | {
    /**
     * Configures a GCP Cloud Storage Connection
     *
     * @generated from field: mgmt.v1alpha1.GcpCloudStorageConnectionConfig gcp_cloudstorage_config = 7;
     */
    value: GcpCloudStorageConnectionConfig;
    case: "gcpCloudstorageConfig";
  } | {
    /**
     * Configures a DynamoDB Connection
     *
     * @generated from field: mgmt.v1alpha1.DynamoDBConnectionConfig dynamodb_config = 8;
     */
    value: DynamoDBConnectionConfig;
    case: "dynamodbConfig";
  } | {
    /**
     * Configures a Microsoft SQL Server (mssql) Connection
     *
     * @generated from field: mgmt.v1alpha1.MssqlConnectionConfig mssql_config = 9;
     */
    value: MssqlConnectionConfig;
    case: "mssqlConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message mgmt.v1alpha1.ConnectionConfig.
 * Use `create(ConnectionConfigSchema)` to create a new message.
 */
export const ConnectionConfigSchema: GenMessage<ConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 16);

/**
 * Configuration for a Mssql Connection
 *
 * @generated from message mgmt.v1alpha1.MssqlConnectionConfig
 */
export type MssqlConnectionConfig = Message<"mgmt.v1alpha1.MssqlConnectionConfig"> & {
  /**
   * May provide a raw string url or in the future other methods of connection
   *
   * @generated from oneof mgmt.v1alpha1.MssqlConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * The URL with sqlserver scheme.
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | {
    /**
     * Source a url from an environment variable.
     * The value is expected to be in the same format as the "url" field above.
     * The key is the name of the environment variable to source. It must contain a prefix of "USER_DEFINED_"
     *
     * @generated from field: string url_from_env = 5;
     */
    value: string;
    case: "urlFromEnv";
  } | { case: undefined; value?: undefined };

  /**
   * Provide connection options that can be used to further fine-tune the connection
   *
   * @generated from field: mgmt.v1alpha1.SqlConnectionOptions connection_options = 2;
   */
  connectionOptions?: SqlConnectionOptions;

  /**
   * Provide tunnel configuration that can be used to access a postgres connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 3;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 4;
   */
  clientTls?: ClientTlsConfig;
};

/**
 * Describes the message mgmt.v1alpha1.MssqlConnectionConfig.
 * Use `create(MssqlConnectionConfigSchema)` to create a new message.
 */
export const MssqlConnectionConfigSchema: GenMessage<MssqlConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 17);

/**
 * Configuration for a DynaomDB Connection
 *
 * @generated from message mgmt.v1alpha1.DynamoDBConnectionConfig
 */
export type DynamoDBConnectionConfig = Message<"mgmt.v1alpha1.DynamoDBConnectionConfig"> & {
  /**
   * Optional credentials that may be provided and will be used to connect to the DynamoDB Instance.
   * If self-hosting, this may be provided by the environment in lieu of specifying these here
   *
   * @generated from field: optional mgmt.v1alpha1.AwsS3Credentials credentials = 1;
   */
  credentials?: AwsS3Credentials;

  /**
   * Optionally specify the region that the dynamodb instance lives in if not provided by the environment.
   *
   * @generated from field: optional string region = 2;
   */
  region?: string;

  /**
   * Optionally specify the endpoint that will be used by the AWS SDK.
   *
   * @generated from field: optional string endpoint = 3;
   */
  endpoint?: string;
};

/**
 * Describes the message mgmt.v1alpha1.DynamoDBConnectionConfig.
 * Use `create(DynamoDBConnectionConfigSchema)` to create a new message.
 */
export const DynamoDBConnectionConfigSchema: GenMessage<DynamoDBConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 18);

/**
 * @generated from message mgmt.v1alpha1.MongoConnectionConfig
 */
export type MongoConnectionConfig = Message<"mgmt.v1alpha1.MongoConnectionConfig"> & {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.MongoConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * The full mongo connection url
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | { case: undefined; value?: undefined };

  /**
   * Provide tunnel configuration that can be used to access a connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 2;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 3;
   */
  clientTls?: ClientTlsConfig;
};

/**
 * Describes the message mgmt.v1alpha1.MongoConnectionConfig.
 * Use `create(MongoConnectionConfigSchema)` to create a new message.
 */
export const MongoConnectionConfigSchema: GenMessage<MongoConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 19);

/**
 * Configures a connection to OpenAI or OpenAI compatible API.
 *
 * @generated from message mgmt.v1alpha1.OpenAiConnectionConfig
 */
export type OpenAiConnectionConfig = Message<"mgmt.v1alpha1.OpenAiConnectionConfig"> & {
  /**
   * OpenAI Api Key
   *
   * @generated from field: string api_key = 1;
   */
  apiKey: string;

  /**
   * OpenAI URL (if using a custom endpoint)
   *
   * @generated from field: string api_url = 2;
   */
  apiUrl: string;
};

/**
 * Describes the message mgmt.v1alpha1.OpenAiConnectionConfig.
 * Use `create(OpenAiConnectionConfigSchema)` to create a new message.
 */
export const OpenAiConnectionConfigSchema: GenMessage<OpenAiConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 20);

/**
 * Configures a connection to a directory available on the local file system
 *
 * @generated from message mgmt.v1alpha1.LocalDirectoryConnectionConfig
 */
export type LocalDirectoryConnectionConfig = Message<"mgmt.v1alpha1.LocalDirectoryConnectionConfig"> & {
  /**
   * The absolute path to a directory that is available on the local file system to the API and Worker nodes
   *
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * Describes the message mgmt.v1alpha1.LocalDirectoryConnectionConfig.
 * Use `create(LocalDirectoryConnectionConfigSchema)` to create a new message.
 */
export const LocalDirectoryConnectionConfigSchema: GenMessage<LocalDirectoryConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 21);

/**
 * @generated from message mgmt.v1alpha1.PostgresConnectionConfig
 */
export type PostgresConnectionConfig = Message<"mgmt.v1alpha1.PostgresConnectionConfig"> & {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.PostgresConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * A raw string url that will be used to construct the connection. Must be URI format.
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | {
    /**
     * A structured representation of the connection that will be used to construct the url
     *
     * @generated from field: mgmt.v1alpha1.PostgresConnection connection = 2;
     */
    value: PostgresConnection;
    case: "connection";
  } | {
    /**
     * Source a url from an environment variable.
     * The value is expected to be in the same format as the "url" field above.
     * The key is the name of the environment variable to source. It must contain a prefix of "USER_DEFINED_"
     *
     * @generated from field: string url_from_env = 6;
     */
    value: string;
    case: "urlFromEnv";
  } | { case: undefined; value?: undefined };

  /**
   * Provide tunnel configuration that can be used to access a postgres connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 3;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide connection options that can be used to further fine-tune the connection
   *
   * @generated from field: mgmt.v1alpha1.SqlConnectionOptions connection_options = 4;
   */
  connectionOptions?: SqlConnectionOptions;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 5;
   */
  clientTls?: ClientTlsConfig;
};

/**
 * Describes the message mgmt.v1alpha1.PostgresConnectionConfig.
 * Use `create(PostgresConnectionConfigSchema)` to create a new message.
 */
export const PostgresConnectionConfigSchema: GenMessage<PostgresConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 22);

/**
 * Config for providing client-side TLS certificates
 *
 * @generated from message mgmt.v1alpha1.ClientTlsConfig
 */
export type ClientTlsConfig = Message<"mgmt.v1alpha1.ClientTlsConfig"> & {
  /**
   * Root Certificate in PEM Format
   *
   * @generated from field: optional string root_cert = 1;
   */
  rootCert?: string;

  /**
   * Client Certificate in PEM format. Must also provide key.
   *
   * @generated from field: optional string client_cert = 2;
   */
  clientCert?: string;

  /**
   * Client Key in PEM format. Must also provide cert.
   *
   * @generated from field: optional string client_key = 3;
   */
  clientKey?: string;

  /**
   * Provide the expected server name. Depending on the driver or encryption mode, this may be required
   * In order to fully validate the server certificate.
   *
   * @generated from field: optional string server_name = 4;
   */
  serverName?: string;
};

/**
 * Describes the message mgmt.v1alpha1.ClientTlsConfig.
 * Use `create(ClientTlsConfigSchema)` to create a new message.
 */
export const ClientTlsConfigSchema: GenMessage<ClientTlsConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 23);

/**
 * @generated from message mgmt.v1alpha1.SqlConnectionOptions
 */
export type SqlConnectionOptions = Message<"mgmt.v1alpha1.SqlConnectionOptions"> & {
  /**
   * Sets the maximum number of open connections
   * If this value is greater than 0, but less than the max_idle_connections, then max_idle_connections will be reduced to match the max_connection_limit
   * If this value is less than or equal to 0, then there is no limit on the number of open connections. If not provided, the default is 0 (unlimited).
   *
   * @generated from field: optional int32 max_connection_limit = 1;
   */
  maxConnectionLimit?: number;

  /**
   * Sets the maximum number of connections in the idle connection pool.
   * This value will be reduced at runtime to match the max_connection_limit if max_connection_limit is greater than 0 but less than this value.
   * If this value is less than or equal to 0, then no idle connections are maintained. If not provided, the default is 2, which may change in a future release.
   *
   * @generated from field: optional int32 max_idle_connections = 2;
   */
  maxIdleConnections?: number;

  /**
   * Sets the maximum amount of time a connection may be idle.
   * Expired connections may be closed lazily before reuse.
   * if this value is less than or equal to 0, connections are not closed due to a connection's idle time.
   * This value is parsed as a Go duration string (ex: 1s, 1m, 500ms)
   *
   * @generated from field: optional string max_idle_duration = 3;
   */
  maxIdleDuration?: string;

  /**
   * Sets the maximum amount of time a connection may be reused.
   * Expired connections may be closed lazily before reuse.
   * If this value is less than or equal to 0, connections may not be closed due to a connection's age.
   * This value is parsed as a Go duration string (ex: 1s, 1m, 500ms)
   *
   * @generated from field: optional string max_open_duration = 4;
   */
  maxOpenDuration?: string;
};

/**
 * Describes the message mgmt.v1alpha1.SqlConnectionOptions.
 * Use `create(SqlConnectionOptionsSchema)` to create a new message.
 */
export const SqlConnectionOptionsSchema: GenMessage<SqlConnectionOptions> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 24);

/**
 * @generated from message mgmt.v1alpha1.SSHTunnel
 */
export type SSHTunnel = Message<"mgmt.v1alpha1.SSHTunnel"> & {
  /**
   * The host of the SSH server
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The port of the SSH server, typically 22
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * The user that will be used to authenticate
   *
   * @generated from field: string user = 3;
   */
  user: string;

  /**
   * Optionally provide the public key of the known host of the SSH tunnel that we are connecting to.
   * If this is not provided, the server will blindly connect to the host with the given credentials.
   * This is not recommended for production use!
   *
   * @generated from field: optional string known_host_public_key = 4;
   */
  knownHostPublicKey?: string;

  /**
   * Provide the authentication required to successfully connect to the SSH server for tunneling
   *
   * @generated from field: mgmt.v1alpha1.SSHAuthentication authentication = 5;
   */
  authentication?: SSHAuthentication;
};

/**
 * Describes the message mgmt.v1alpha1.SSHTunnel.
 * Use `create(SSHTunnelSchema)` to create a new message.
 */
export const SSHTunnelSchema: GenMessage<SSHTunnel> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 25);

/**
 * SSH Authentication
 *
 * @generated from message mgmt.v1alpha1.SSHAuthentication
 */
export type SSHAuthentication = Message<"mgmt.v1alpha1.SSHAuthentication"> & {
  /**
   * @generated from oneof mgmt.v1alpha1.SSHAuthentication.auth_config
   */
  authConfig: {
    /**
     * Password authentication
     *
     * @generated from field: mgmt.v1alpha1.SSHPassphrase passphrase = 1;
     */
    value: SSHPassphrase;
    case: "passphrase";
  } | {
    /**
     * Private key authentication
     *
     * @generated from field: mgmt.v1alpha1.SSHPrivateKey private_key = 2;
     */
    value: SSHPrivateKey;
    case: "privateKey";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message mgmt.v1alpha1.SSHAuthentication.
 * Use `create(SSHAuthenticationSchema)` to create a new message.
 */
export const SSHAuthenticationSchema: GenMessage<SSHAuthentication> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 26);

/**
 * Contains the configuration needed to retrieve the SSH passphrase for the tunnel
 *
 * @generated from message mgmt.v1alpha1.SSHPassphrase
 */
export type SSHPassphrase = Message<"mgmt.v1alpha1.SSHPassphrase"> & {
  /**
   * The password to be used to connect to the SSH server
   *
   * eventually we can expand this to allow pulling from other sources.
   *
   * @generated from field: string value = 1;
   */
  value: string;
};

/**
 * Describes the message mgmt.v1alpha1.SSHPassphrase.
 * Use `create(SSHPassphraseSchema)` to create a new message.
 */
export const SSHPassphraseSchema: GenMessage<SSHPassphrase> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 27);

/**
 * Contains the configuration needed to retrieve the SSH private key for the tunnel
 *
 * @generated from message mgmt.v1alpha1.SSHPrivateKey
 */
export type SSHPrivateKey = Message<"mgmt.v1alpha1.SSHPrivateKey"> & {
  /**
   * The private key in PEM format.
   *
   * @generated from field: string value = 1;
   */
  value: string;

  /**
   * If the private key is encrypted, this value should decrypt it.
   *
   * @generated from field: optional string passphrase = 2;
   */
  passphrase?: string;
};

/**
 * Describes the message mgmt.v1alpha1.SSHPrivateKey.
 * Use `create(SSHPrivateKeySchema)` to create a new message.
 */
export const SSHPrivateKeySchema: GenMessage<SSHPrivateKey> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 28);

/**
 * @generated from message mgmt.v1alpha1.PostgresConnection
 */
export type PostgresConnection = Message<"mgmt.v1alpha1.PostgresConnection"> & {
  /**
   * The host to use for the connection
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The port to use for the connection
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * The name of the database to use for the connection
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * The user to use for the connection
   *
   * @generated from field: string user = 4;
   */
  user: string;

  /**
   * The password to use for the connection
   *
   * @generated from field: string pass = 5;
   */
  pass: string;

  /**
   * The SSL mode to use for the connection
   *
   * @generated from field: optional string ssl_mode = 6;
   */
  sslMode?: string;
};

/**
 * Describes the message mgmt.v1alpha1.PostgresConnection.
 * Use `create(PostgresConnectionSchema)` to create a new message.
 */
export const PostgresConnectionSchema: GenMessage<PostgresConnection> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 29);

/**
 * @generated from message mgmt.v1alpha1.MysqlConnection
 */
export type MysqlConnection = Message<"mgmt.v1alpha1.MysqlConnection"> & {
  /**
   * The user to use for the connection
   *
   * @generated from field: string user = 1;
   */
  user: string;

  /**
   * The password to use for the connection
   *
   * @generated from field: string pass = 2;
   */
  pass: string;

  /**
   * The protocol to use for the connection
   *
   * @generated from field: string protocol = 3;
   */
  protocol: string;

  /**
   * The host to use for the connection
   *
   * @generated from field: string host = 4;
   */
  host: string;

  /**
   * The port to use for the connection
   *
   * @generated from field: int32 port = 5;
   */
  port: number;

  /**
   * The name of the database to use for the connection
   *
   * @generated from field: string name = 6;
   */
  name: string;
};

/**
 * Describes the message mgmt.v1alpha1.MysqlConnection.
 * Use `create(MysqlConnectionSchema)` to create a new message.
 */
export const MysqlConnectionSchema: GenMessage<MysqlConnection> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 30);

/**
 * @generated from message mgmt.v1alpha1.MysqlConnectionConfig
 */
export type MysqlConnectionConfig = Message<"mgmt.v1alpha1.MysqlConnectionConfig"> & {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.MysqlConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * A raw string url that will be used to construct the connection. DSN format. URI format also supported but more limited.
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | {
    /**
     * A structured representation of the connection that will be used to construct the url
     *
     * @generated from field: mgmt.v1alpha1.MysqlConnection connection = 2;
     */
    value: MysqlConnection;
    case: "connection";
  } | {
    /**
     * Source a url from an environment variable.
     * The value is expected to be in the same format as the "url" field above.
     * The key is the name of the environment variable to source. It must contain a prefix of "USER_DEFINED_"
     *
     * @generated from field: string url_from_env = 6;
     */
    value: string;
    case: "urlFromEnv";
  } | { case: undefined; value?: undefined };

  /**
   * Provide tunnel configuration that can be used to access a postgres connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 3;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide connection options that can be used to further fine-tune the connection
   *
   * @generated from field: mgmt.v1alpha1.SqlConnectionOptions connection_options = 4;
   */
  connectionOptions?: SqlConnectionOptions;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 5;
   */
  clientTls?: ClientTlsConfig;
};

/**
 * Describes the message mgmt.v1alpha1.MysqlConnectionConfig.
 * Use `create(MysqlConnectionConfigSchema)` to create a new message.
 */
export const MysqlConnectionConfigSchema: GenMessage<MysqlConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 31);

/**
 * @generated from message mgmt.v1alpha1.AwsS3ConnectionConfig
 */
export type AwsS3ConnectionConfig = Message<"mgmt.v1alpha1.AwsS3ConnectionConfig"> & {
  /**
   * The bucket path prefix that will be appended to each file
   *
   * @generated from field: optional string path_prefix = 2;
   */
  pathPrefix?: string;

  /**
   * The credentials to use for the S3 bucket
   *
   * @generated from field: optional mgmt.v1alpha1.AwsS3Credentials credentials = 3;
   */
  credentials?: AwsS3Credentials;

  /**
   * The region of the S3 bucket
   *
   * @generated from field: optional string region = 4;
   */
  region?: string;

  /**
   * The endpoint of the S3 bucket (if using a custom endpoint like region specific endpoints or S3-compatible APIs)
   *
   * @generated from field: optional string endpoint = 5;
   */
  endpoint?: string;

  /**
   * The name of the S3 bucket
   *
   * @generated from field: string bucket = 6;
   */
  bucket: string;
};

/**
 * Describes the message mgmt.v1alpha1.AwsS3ConnectionConfig.
 * Use `create(AwsS3ConnectionConfigSchema)` to create a new message.
 */
export const AwsS3ConnectionConfigSchema: GenMessage<AwsS3ConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 32);

/**
 * S3 Credentials that are used by the worker process.
 * Note: this may be optionally provided if the worker that is being hosted has environment credentials to the S3 bucket instead.
 *
 * @generated from message mgmt.v1alpha1.AwsS3Credentials
 */
export type AwsS3Credentials = Message<"mgmt.v1alpha1.AwsS3Credentials"> & {
  /**
   * The profile to use for the S3 credentials
   *
   * @generated from field: optional string profile = 1;
   */
  profile?: string;

  /**
   * The access key id to use for the S3 credentials
   *
   * @generated from field: optional string access_key_id = 2;
   */
  accessKeyId?: string;

  /**
   * The secret access key to use for the S3 credentials
   *
   * @generated from field: optional string secret_access_key = 3;
   */
  secretAccessKey?: string;

  /**
   * The session token to use for the S3 credentials
   *
   * @generated from field: optional string session_token = 4;
   */
  sessionToken?: string;

  /**
   * Whether or not the credentials are from an EC2 role
   *
   * @generated from field: optional bool from_ec2_role = 5;
   */
  fromEc2Role?: boolean;

  /**
   * The ARN of the role to use for the S3 credentials
   *
   * @generated from field: optional string role_arn = 6;
   */
  roleArn?: string;

  /**
   * The role's external ID to use for the S3 credentials
   *
   * @generated from field: optional string role_external_id = 7;
   */
  roleExternalId?: string;
};

/**
 * Describes the message mgmt.v1alpha1.AwsS3Credentials.
 * Use `create(AwsS3CredentialsSchema)` to create a new message.
 */
export const AwsS3CredentialsSchema: GenMessage<AwsS3Credentials> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 33);

/**
 * Configuration for GCP Cloud Storage Buckets
 *
 * @generated from message mgmt.v1alpha1.GcpCloudStorageConnectionConfig
 */
export type GcpCloudStorageConnectionConfig = Message<"mgmt.v1alpha1.GcpCloudStorageConnectionConfig"> & {
  /**
   * The GCP Cloud Storage bucket that will be accessed.
   *
   * @generated from field: string bucket = 1;
   */
  bucket: string;

  /**
   * The path prefix that will be appended to each file
   *
   * @generated from field: optional string path_prefix = 2;
   */
  pathPrefix?: string;

  /**
   * stringified json of the service account credentials file
   *
   * @generated from field: optional string service_account_credentials = 3;
   */
  serviceAccountCredentials?: string;
};

/**
 * Describes the message mgmt.v1alpha1.GcpCloudStorageConnectionConfig.
 * Use `create(GcpCloudStorageConnectionConfigSchema)` to create a new message.
 */
export const GcpCloudStorageConnectionConfigSchema: GenMessage<GcpCloudStorageConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 34);

/**
 * @generated from message mgmt.v1alpha1.IsConnectionNameAvailableRequest
 */
export type IsConnectionNameAvailableRequest = Message<"mgmt.v1alpha1.IsConnectionNameAvailableRequest"> & {
  /**
   * The unique identifier of the account to check the connection name for
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The connection name to check for availability
   *
   * @generated from field: string connection_name = 2;
   */
  connectionName: string;
};

/**
 * Describes the message mgmt.v1alpha1.IsConnectionNameAvailableRequest.
 * Use `create(IsConnectionNameAvailableRequestSchema)` to create a new message.
 */
export const IsConnectionNameAvailableRequestSchema: GenMessage<IsConnectionNameAvailableRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 35);

/**
 * @generated from message mgmt.v1alpha1.IsConnectionNameAvailableResponse
 */
export type IsConnectionNameAvailableResponse = Message<"mgmt.v1alpha1.IsConnectionNameAvailableResponse"> & {
  /**
   * Whether or not the connection name is available
   *
   * @generated from field: bool is_available = 1;
   */
  isAvailable: boolean;
};

/**
 * Describes the message mgmt.v1alpha1.IsConnectionNameAvailableResponse.
 * Use `create(IsConnectionNameAvailableResponseSchema)` to create a new message.
 */
export const IsConnectionNameAvailableResponseSchema: GenMessage<IsConnectionNameAvailableResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 36);

/**
 * @generated from message mgmt.v1alpha1.CheckSqlQueryRequest
 */
export type CheckSqlQueryRequest = Message<"mgmt.v1alpha1.CheckSqlQueryRequest"> & {
  /**
   * The connection id that the query will be checked against
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The full query that will be run through a PREPARE statement
   *
   * @generated from field: string query = 2;
   */
  query: string;
};

/**
 * Describes the message mgmt.v1alpha1.CheckSqlQueryRequest.
 * Use `create(CheckSqlQueryRequestSchema)` to create a new message.
 */
export const CheckSqlQueryRequestSchema: GenMessage<CheckSqlQueryRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 37);

/**
 * @generated from message mgmt.v1alpha1.CheckSqlQueryResponse
 */
export type CheckSqlQueryResponse = Message<"mgmt.v1alpha1.CheckSqlQueryResponse"> & {
  /**
   * The query is run through PREPARE. Returns valid if it correctly compiled
   *
   * @generated from field: bool is_valid = 1;
   */
  isValid: boolean;

  /**
   * The error message returned by the sql client if the prepare did not return successfully
   *
   * @generated from field: optional string erorr_message = 2;
   */
  erorrMessage?: string;
};

/**
 * Describes the message mgmt.v1alpha1.CheckSqlQueryResponse.
 * Use `create(CheckSqlQueryResponseSchema)` to create a new message.
 */
export const CheckSqlQueryResponseSchema: GenMessage<CheckSqlQueryResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 38);

/**
 * Service for managing datasource connections.
 * This is a primary data model in Neosync and is used in reference when hooking up Jobs to synchronize and generate data.
 *
 * @generated from service mgmt.v1alpha1.ConnectionService
 */
export const ConnectionService: GenService<{
  /**
   * Returns a list of connections associated with the account
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.GetConnections
   */
  getConnections: {
    methodKind: "unary";
    input: typeof GetConnectionsRequestSchema;
    output: typeof GetConnectionsResponseSchema;
  },
  /**
   * Returns a single connection
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.GetConnection
   */
  getConnection: {
    methodKind: "unary";
    input: typeof GetConnectionRequestSchema;
    output: typeof GetConnectionResponseSchema;
  },
  /**
   * Creates a new connection
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.CreateConnection
   */
  createConnection: {
    methodKind: "unary";
    input: typeof CreateConnectionRequestSchema;
    output: typeof CreateConnectionResponseSchema;
  },
  /**
   * Updates an existing connection
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.UpdateConnection
   */
  updateConnection: {
    methodKind: "unary";
    input: typeof UpdateConnectionRequestSchema;
    output: typeof UpdateConnectionResponseSchema;
  },
  /**
   * Removes a connection from the system.
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.DeleteConnection
   */
  deleteConnection: {
    methodKind: "unary";
    input: typeof DeleteConnectionRequestSchema;
    output: typeof DeleteConnectionResponseSchema;
  },
  /**
   * Connections have friendly names, this method checks if the requested name is available in the system based on the account
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.IsConnectionNameAvailable
   */
  isConnectionNameAvailable: {
    methodKind: "unary";
    input: typeof IsConnectionNameAvailableRequestSchema;
    output: typeof IsConnectionNameAvailableResponseSchema;
  },
  /**
   * Checks if the connection config is connectable by the backend.
   * Used mostly to verify that a connection is valid prior to creating a Connection object.
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.CheckConnectionConfig
   */
  checkConnectionConfig: {
    methodKind: "unary";
    input: typeof CheckConnectionConfigRequestSchema;
    output: typeof CheckConnectionConfigResponseSchema;
  },
  /**
   * Checks if the connection id is connectable by the backend.
   * Used to verify that a connection is still connectable.
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.CheckConnectionConfigById
   */
  checkConnectionConfigById: {
    methodKind: "unary";
    input: typeof CheckConnectionConfigByIdRequestSchema;
    output: typeof CheckConnectionConfigByIdResponseSchema;
  },
  /**
   * Checks a constructed SQL query against a sql-based connection to see if it's valid based on that connection's data schema
   * This is useful when constructing subsets to see if the WHERE clause is correct
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.CheckSqlQuery
   */
  checkSqlQuery: {
    methodKind: "unary";
    input: typeof CheckSqlQueryRequestSchema;
    output: typeof CheckSqlQueryResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_mgmt_v1alpha1_connection, 0);

