// @generated by protoc-gen-es v2.2.3 with parameter "target=ts,import_extension=.js"
// @generated from file mgmt/v1alpha1/connection.proto (package mgmt.v1alpha1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../buf/validate/validate_pb.js";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file mgmt/v1alpha1/connection.proto.
 */
export const file_mgmt_v1alpha1_connection: GenFile = /*@__PURE__*/
  fileDesc("Ch5tZ210L3YxYWxwaGExL2Nvbm5lY3Rpb24ucHJvdG8SDW1nbXQudjFhbHBoYTEiUAoVR2V0Q29ubmVjdGlvbnNSZXF1ZXN0EhwKCmFjY291bnRfaWQYASABKAlCCLpIBXIDsAEBEhkKEWV4Y2x1ZGVfc2Vuc2l0aXZlGAIgASgIIkgKFkdldENvbm5lY3Rpb25zUmVzcG9uc2USLgoLY29ubmVjdGlvbnMYASADKAsyGS5tZ210LnYxYWxwaGExLkNvbm5lY3Rpb24iRwoUR2V0Q29ubmVjdGlvblJlcXVlc3QSFAoCaWQYASABKAlCCLpIBXIDsAEBEhkKEWV4Y2x1ZGVfc2Vuc2l0aXZlGAIgASgIIkYKFUdldENvbm5lY3Rpb25SZXNwb25zZRItCgpjb25uZWN0aW9uGAEgASgLMhkubWdtdC52MWFscGhhMS5Db25uZWN0aW9uIpwBChdDcmVhdGVDb25uZWN0aW9uUmVxdWVzdBIcCgphY2NvdW50X2lkGAEgASgJQgi6SAVyA7ABARInCgRuYW1lGAIgASgJQhm6SBZyFDISXlthLXowLTktXXszLDEwMH0kEjoKEWNvbm5lY3Rpb25fY29uZmlnGAMgASgLMh8ubWdtdC52MWFscGhhMS5Db25uZWN0aW9uQ29uZmlnIkkKGENyZWF0ZUNvbm5lY3Rpb25SZXNwb25zZRItCgpjb25uZWN0aW9uGAEgASgLMhkubWdtdC52MWFscGhhMS5Db25uZWN0aW9uIpQBChdVcGRhdGVDb25uZWN0aW9uUmVxdWVzdBIUCgJpZBgBIAEoCUIIukgFcgOwAQESJwoEbmFtZRgCIAEoCUIZukgWchQyEl5bYS16MC05LV17MywxMDB9JBI6ChFjb25uZWN0aW9uX2NvbmZpZxgDIAEoCzIfLm1nbXQudjFhbHBoYTEuQ29ubmVjdGlvbkNvbmZpZyJJChhVcGRhdGVDb25uZWN0aW9uUmVzcG9uc2USLQoKY29ubmVjdGlvbhgBIAEoCzIZLm1nbXQudjFhbHBoYTEuQ29ubmVjdGlvbiIvChdEZWxldGVDb25uZWN0aW9uUmVxdWVzdBIUCgJpZBgBIAEoCUIIukgFcgOwAQEiGgoYRGVsZXRlQ29ubmVjdGlvblJlc3BvbnNlIloKHENoZWNrQ29ubmVjdGlvbkNvbmZpZ1JlcXVlc3QSOgoRY29ubmVjdGlvbl9jb25maWcYASABKAsyHy5tZ210LnYxYWxwaGExLkNvbm5lY3Rpb25Db25maWciOAogQ2hlY2tDb25uZWN0aW9uQ29uZmlnQnlJZFJlcXVlc3QSFAoCaWQYASABKAlCCLpIBXIDsAEBIqkBCiFDaGVja0Nvbm5lY3Rpb25Db25maWdCeUlkUmVzcG9uc2USFAoMaXNfY29ubmVjdGVkGAEgASgIEh0KEGNvbm5lY3Rpb25fZXJyb3IYAiABKAlIAIgBARI6Cgpwcml2aWxlZ2VzGAMgAygLMiYubWdtdC52MWFscGhhMS5Db25uZWN0aW9uUm9sZVByaXZpbGVnZUITChFfY29ubmVjdGlvbl9lcnJvciKlAQodQ2hlY2tDb25uZWN0aW9uQ29uZmlnUmVzcG9uc2USFAoMaXNfY29ubmVjdGVkGAEgASgIEh0KEGNvbm5lY3Rpb25fZXJyb3IYAiABKAlIAIgBARI6Cgpwcml2aWxlZ2VzGAMgAygLMiYubWdtdC52MWFscGhhMS5Db25uZWN0aW9uUm9sZVByaXZpbGVnZUITChFfY29ubmVjdGlvbl9lcnJvciJhChdDb25uZWN0aW9uUm9sZVByaXZpbGVnZRIPCgdncmFudGVlGAEgASgJEg4KBnNjaGVtYRgCIAEoCRINCgV0YWJsZRgDIAEoCRIWCg5wcml2aWxlZ2VfdHlwZRgEIAMoCSKOAgoKQ29ubmVjdGlvbhIKCgJpZBgBIAEoCRIMCgRuYW1lGAIgASgJEjoKEWNvbm5lY3Rpb25fY29uZmlnGAMgASgLMh8ubWdtdC52MWFscGhhMS5Db25uZWN0aW9uQ29uZmlnEhoKEmNyZWF0ZWRfYnlfdXNlcl9pZBgEIAEoCRIuCgpjcmVhdGVkX2F0GAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIaChJ1cGRhdGVkX2J5X3VzZXJfaWQYBiABKAkSLgoKdXBkYXRlZF9hdBgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASEgoKYWNjb3VudF9pZBgIIAEoCSL8BAoQQ29ubmVjdGlvbkNvbmZpZxI8CglwZ19jb25maWcYASABKAsyJy5tZ210LnYxYWxwaGExLlBvc3RncmVzQ29ubmVjdGlvbkNvbmZpZ0gAEj0KDWF3c19zM19jb25maWcYAiABKAsyJC5tZ210LnYxYWxwaGExLkF3c1MzQ29ubmVjdGlvbkNvbmZpZ0gAEjwKDG15c3FsX2NvbmZpZxgDIAEoCzIkLm1nbXQudjFhbHBoYTEuTXlzcWxDb25uZWN0aW9uQ29uZmlnSAASSQoQbG9jYWxfZGlyX2NvbmZpZxgEIAEoCzItLm1nbXQudjFhbHBoYTEuTG9jYWxEaXJlY3RvcnlDb25uZWN0aW9uQ29uZmlnSAASPgoNb3BlbmFpX2NvbmZpZxgFIAEoCzIlLm1nbXQudjFhbHBoYTEuT3BlbkFpQ29ubmVjdGlvbkNvbmZpZ0gAEjwKDG1vbmdvX2NvbmZpZxgGIAEoCzIkLm1nbXQudjFhbHBoYTEuTW9uZ29Db25uZWN0aW9uQ29uZmlnSAASUQoXZ2NwX2Nsb3Vkc3RvcmFnZV9jb25maWcYByABKAsyLi5tZ210LnYxYWxwaGExLkdjcENsb3VkU3RvcmFnZUNvbm5lY3Rpb25Db25maWdIABJCCg9keW5hbW9kYl9jb25maWcYCCABKAsyJy5tZ210LnYxYWxwaGExLkR5bmFtb0RCQ29ubmVjdGlvbkNvbmZpZ0gAEjwKDG1zc3FsX2NvbmZpZxgJIAEoCzIkLm1nbXQudjFhbHBoYTEuTXNzcWxDb25uZWN0aW9uQ29uZmlnSABCDwoGY29uZmlnEgW6SAIIASL5AQoVTXNzcWxDb25uZWN0aW9uQ29uZmlnEg0KA3VybBgBIAEoCUgAEhYKDHVybF9mcm9tX2VudhgFIAEoCUgAEj8KEmNvbm5lY3Rpb25fb3B0aW9ucxgCIAEoCzIjLm1nbXQudjFhbHBoYTEuU3FsQ29ubmVjdGlvbk9wdGlvbnMSKAoGdHVubmVsGAMgASgLMhgubWdtdC52MWFscGhhMS5TU0hUdW5uZWwSMgoKY2xpZW50X3RscxgEIAEoCzIeLm1nbXQudjFhbHBoYTEuQ2xpZW50VGxzQ29uZmlnQhoKEWNvbm5lY3Rpb25fY29uZmlnEgW6SAIIASKpAQoYRHluYW1vREJDb25uZWN0aW9uQ29uZmlnEjkKC2NyZWRlbnRpYWxzGAEgASgLMh8ubWdtdC52MWFscGhhMS5Bd3NTM0NyZWRlbnRpYWxzSACIAQESEwoGcmVnaW9uGAIgASgJSAGIAQESFQoIZW5kcG9pbnQYAyABKAlIAogBAUIOCgxfY3JlZGVudGlhbHNCCQoHX3JlZ2lvbkILCglfZW5kcG9pbnQioAEKFU1vbmdvQ29ubmVjdGlvbkNvbmZpZxINCgN1cmwYASABKAlIABIoCgZ0dW5uZWwYAiABKAsyGC5tZ210LnYxYWxwaGExLlNTSFR1bm5lbBIyCgpjbGllbnRfdGxzGAMgASgLMh4ubWdtdC52MWFscGhhMS5DbGllbnRUbHNDb25maWdCGgoRY29ubmVjdGlvbl9jb25maWcSBbpIAggBIjoKFk9wZW5BaUNvbm5lY3Rpb25Db25maWcSDwoHYXBpX2tleRgBIAEoCRIPCgdhcGlfdXJsGAIgASgJIjcKHkxvY2FsRGlyZWN0b3J5Q29ubmVjdGlvbkNvbmZpZxIVCgRwYXRoGAEgASgJQge6SARyAhABIrUCChhQb3N0Z3Jlc0Nvbm5lY3Rpb25Db25maWcSDQoDdXJsGAEgASgJSAASNwoKY29ubmVjdGlvbhgCIAEoCzIhLm1nbXQudjFhbHBoYTEuUG9zdGdyZXNDb25uZWN0aW9uSAASFgoMdXJsX2Zyb21fZW52GAYgASgJSAASKAoGdHVubmVsGAMgASgLMhgubWdtdC52MWFscGhhMS5TU0hUdW5uZWwSPwoSY29ubmVjdGlvbl9vcHRpb25zGAQgASgLMiMubWdtdC52MWFscGhhMS5TcWxDb25uZWN0aW9uT3B0aW9ucxIyCgpjbGllbnRfdGxzGAUgASgLMh4ubWdtdC52MWFscGhhMS5DbGllbnRUbHNDb25maWdCGgoRY29ubmVjdGlvbl9jb25maWcSBbpIAggBIrMBCg9DbGllbnRUbHNDb25maWcSFgoJcm9vdF9jZXJ0GAEgASgJSACIAQESGAoLY2xpZW50X2NlcnQYAiABKAlIAYgBARIXCgpjbGllbnRfa2V5GAMgASgJSAKIAQESGAoLc2VydmVyX25hbWUYBCABKAlIA4gBAUIMCgpfcm9vdF9jZXJ0Qg4KDF9jbGllbnRfY2VydEINCgtfY2xpZW50X2tleUIOCgxfc2VydmVyX25hbWUi+gEKFFNxbENvbm5lY3Rpb25PcHRpb25zEiEKFG1heF9jb25uZWN0aW9uX2xpbWl0GAEgASgFSACIAQESIQoUbWF4X2lkbGVfY29ubmVjdGlvbnMYAiABKAVIAYgBARIeChFtYXhfaWRsZV9kdXJhdGlvbhgDIAEoCUgCiAEBEh4KEW1heF9vcGVuX2R1cmF0aW9uGAQgASgJSAOIAQFCFwoVX21heF9jb25uZWN0aW9uX2xpbWl0QhcKFV9tYXhfaWRsZV9jb25uZWN0aW9uc0IUChJfbWF4X2lkbGVfZHVyYXRpb25CFAoSX21heF9vcGVuX2R1cmF0aW9uItEBCglTU0hUdW5uZWwSFQoEaG9zdBgBIAEoCUIHukgEcgIQARIVCgRwb3J0GAIgASgFQge6SAQaAigAEhUKBHVzZXIYAyABKAlCB7pIBHICEAESKwoVa25vd25faG9zdF9wdWJsaWNfa2V5GAQgASgJQge6SARyAhABSACIAQESOAoOYXV0aGVudGljYXRpb24YBSABKAsyIC5tZ210LnYxYWxwaGExLlNTSEF1dGhlbnRpY2F0aW9uQhgKFl9rbm93bl9ob3N0X3B1YmxpY19rZXkikgEKEVNTSEF1dGhlbnRpY2F0aW9uEjIKCnBhc3NwaHJhc2UYASABKAsyHC5tZ210LnYxYWxwaGExLlNTSFBhc3NwaHJhc2VIABIzCgtwcml2YXRlX2tleRgCIAEoCzIcLm1nbXQudjFhbHBoYTEuU1NIUHJpdmF0ZUtleUgAQhQKC2F1dGhfY29uZmlnEgW6SAIIASInCg1TU0hQYXNzcGhyYXNlEhYKBXZhbHVlGAEgASgJQge6SARyAhABIk8KDVNTSFByaXZhdGVLZXkSFgoFdmFsdWUYASABKAlCB7pIBHICEAESFwoKcGFzc3BocmFzZRgCIAEoCUgAiAEBQg0KC19wYXNzcGhyYXNlIn4KElBvc3RncmVzQ29ubmVjdGlvbhIMCgRob3N0GAEgASgJEgwKBHBvcnQYAiABKAUSDAoEbmFtZRgDIAEoCRIMCgR1c2VyGAQgASgJEgwKBHBhc3MYBSABKAkSFQoIc3NsX21vZGUYBiABKAlIAIgBAUILCglfc3NsX21vZGUiaQoPTXlzcWxDb25uZWN0aW9uEgwKBHVzZXIYASABKAkSDAoEcGFzcxgCIAEoCRIQCghwcm90b2NvbBgDIAEoCRIMCgRob3N0GAQgASgJEgwKBHBvcnQYBSABKAUSDAoEbmFtZRgGIAEoCSKvAgoVTXlzcWxDb25uZWN0aW9uQ29uZmlnEg0KA3VybBgBIAEoCUgAEjQKCmNvbm5lY3Rpb24YAiABKAsyHi5tZ210LnYxYWxwaGExLk15c3FsQ29ubmVjdGlvbkgAEhYKDHVybF9mcm9tX2VudhgGIAEoCUgAEigKBnR1bm5lbBgDIAEoCzIYLm1nbXQudjFhbHBoYTEuU1NIVHVubmVsEj8KEmNvbm5lY3Rpb25fb3B0aW9ucxgEIAEoCzIjLm1nbXQudjFhbHBoYTEuU3FsQ29ubmVjdGlvbk9wdGlvbnMSMgoKY2xpZW50X3RscxgFIAEoCzIeLm1nbXQudjFhbHBoYTEuQ2xpZW50VGxzQ29uZmlnQhoKEWNvbm5lY3Rpb25fY29uZmlnEgW6SAIIASLvAQoVQXdzUzNDb25uZWN0aW9uQ29uZmlnEhgKC3BhdGhfcHJlZml4GAIgASgJSACIAQESOQoLY3JlZGVudGlhbHMYAyABKAsyHy5tZ210LnYxYWxwaGExLkF3c1MzQ3JlZGVudGlhbHNIAYgBARITCgZyZWdpb24YBCABKAlIAogBARIVCghlbmRwb2ludBgFIAEoCUgDiAEBEhcKBmJ1Y2tldBgGIAEoCUIHukgEcgIQAUIOCgxfcGF0aF9wcmVmaXhCDgoMX2NyZWRlbnRpYWxzQgkKB19yZWdpb25CCwoJX2VuZHBvaW50SgQIARACIswCChBBd3NTM0NyZWRlbnRpYWxzEhQKB3Byb2ZpbGUYASABKAlIAIgBARIaCg1hY2Nlc3Nfa2V5X2lkGAIgASgJSAGIAQESHgoRc2VjcmV0X2FjY2Vzc19rZXkYAyABKAlIAogBARIaCg1zZXNzaW9uX3Rva2VuGAQgASgJSAOIAQESGgoNZnJvbV9lYzJfcm9sZRgFIAEoCEgEiAEBEhUKCHJvbGVfYXJuGAYgASgJSAWIAQESHQoQcm9sZV9leHRlcm5hbF9pZBgHIAEoCUgGiAEBQgoKCF9wcm9maWxlQhAKDl9hY2Nlc3Nfa2V5X2lkQhQKEl9zZWNyZXRfYWNjZXNzX2tleUIQCg5fc2Vzc2lvbl90b2tlbkIQCg5fZnJvbV9lYzJfcm9sZUILCglfcm9sZV9hcm5CEwoRX3JvbGVfZXh0ZXJuYWxfaWQirgEKH0djcENsb3VkU3RvcmFnZUNvbm5lY3Rpb25Db25maWcSFwoGYnVja2V0GAEgASgJQge6SARyAhABEhgKC3BhdGhfcHJlZml4GAIgASgJSACIAQESKAobc2VydmljZV9hY2NvdW50X2NyZWRlbnRpYWxzGAMgASgJSAGIAQFCDgoMX3BhdGhfcHJlZml4Qh4KHF9zZXJ2aWNlX2FjY291bnRfY3JlZGVudGlhbHMidAogSXNDb25uZWN0aW9uTmFtZUF2YWlsYWJsZVJlcXVlc3QSHAoKYWNjb3VudF9pZBgBIAEoCUIIukgFcgOwAQESMgoPY29ubmVjdGlvbl9uYW1lGAIgASgJQhm6SBZyFDISXlthLXowLTktXXszLDEwMH0kIjkKIUlzQ29ubmVjdGlvbk5hbWVBdmFpbGFibGVSZXNwb25zZRIUCgxpc19hdmFpbGFibGUYASABKAgiRAoUQ2hlY2tTcWxRdWVyeVJlcXVlc3QSFAoCaWQYASABKAlCCLpIBXIDsAEBEhYKBXF1ZXJ5GAIgASgJQge6SARyAhABIlcKFUNoZWNrU3FsUXVlcnlSZXNwb25zZRIQCghpc192YWxpZBgBIAEoCBIaCg1lcm9ycl9tZXNzYWdlGAIgASgJSACIAQFCEAoOX2Vyb3JyX21lc3NhZ2Uy5wcKEUNvbm5lY3Rpb25TZXJ2aWNlEmIKDkdldENvbm5lY3Rpb25zEiQubWdtdC52MWFscGhhMS5HZXRDb25uZWN0aW9uc1JlcXVlc3QaJS5tZ210LnYxYWxwaGExLkdldENvbm5lY3Rpb25zUmVzcG9uc2UiA5ACARJfCg1HZXRDb25uZWN0aW9uEiMubWdtdC52MWFscGhhMS5HZXRDb25uZWN0aW9uUmVxdWVzdBokLm1nbXQudjFhbHBoYTEuR2V0Q29ubmVjdGlvblJlc3BvbnNlIgOQAgESZQoQQ3JlYXRlQ29ubmVjdGlvbhImLm1nbXQudjFhbHBoYTEuQ3JlYXRlQ29ubmVjdGlvblJlcXVlc3QaJy5tZ210LnYxYWxwaGExLkNyZWF0ZUNvbm5lY3Rpb25SZXNwb25zZSIAEmUKEFVwZGF0ZUNvbm5lY3Rpb24SJi5tZ210LnYxYWxwaGExLlVwZGF0ZUNvbm5lY3Rpb25SZXF1ZXN0GicubWdtdC52MWFscGhhMS5VcGRhdGVDb25uZWN0aW9uUmVzcG9uc2UiABJlChBEZWxldGVDb25uZWN0aW9uEiYubWdtdC52MWFscGhhMS5EZWxldGVDb25uZWN0aW9uUmVxdWVzdBonLm1nbXQudjFhbHBoYTEuRGVsZXRlQ29ubmVjdGlvblJlc3BvbnNlIgASgAEKGUlzQ29ubmVjdGlvbk5hbWVBdmFpbGFibGUSLy5tZ210LnYxYWxwaGExLklzQ29ubmVjdGlvbk5hbWVBdmFpbGFibGVSZXF1ZXN0GjAubWdtdC52MWFscGhhMS5Jc0Nvbm5lY3Rpb25OYW1lQXZhaWxhYmxlUmVzcG9uc2UiABJ0ChVDaGVja0Nvbm5lY3Rpb25Db25maWcSKy5tZ210LnYxYWxwaGExLkNoZWNrQ29ubmVjdGlvbkNvbmZpZ1JlcXVlc3QaLC5tZ210LnYxYWxwaGExLkNoZWNrQ29ubmVjdGlvbkNvbmZpZ1Jlc3BvbnNlIgASgAEKGUNoZWNrQ29ubmVjdGlvbkNvbmZpZ0J5SWQSLy5tZ210LnYxYWxwaGExLkNoZWNrQ29ubmVjdGlvbkNvbmZpZ0J5SWRSZXF1ZXN0GjAubWdtdC52MWFscGhhMS5DaGVja0Nvbm5lY3Rpb25Db25maWdCeUlkUmVzcG9uc2UiABJcCg1DaGVja1NxbFF1ZXJ5EiMubWdtdC52MWFscGhhMS5DaGVja1NxbFF1ZXJ5UmVxdWVzdBokLm1nbXQudjFhbHBoYTEuQ2hlY2tTcWxRdWVyeVJlc3BvbnNlIgBCywEKEWNvbS5tZ210LnYxYWxwaGExQg9Db25uZWN0aW9uUHJvdG9QAVpQZ2l0aHViLmNvbS9udWNsZXVzY2xvdWQvbmVvc3luYy9iYWNrZW5kL2dlbi9nby9wcm90b3MvbWdtdC92MWFscGhhMTttZ210djFhbHBoYTGiAgNNWFiqAg1NZ210LlYxYWxwaGExygINTWdtdFxWMWFscGhhMeICGU1nbXRcVjFhbHBoYTFcR1BCTWV0YWRhdGHqAg5NZ210OjpWMWFscGhhMWIGcHJvdG8z", [file_buf_validate_validate, file_google_protobuf_timestamp]);

/**
 * @generated from message mgmt.v1alpha1.GetConnectionsRequest
 */
export type GetConnectionsRequest = Message<"mgmt.v1alpha1.GetConnectionsRequest"> & {
  /**
   * The unique identifier of the account to get connections for
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * Whether or not to exclude sensitive data from the connection
   * If the caller does not have permission to view sensitive data, the connection will always be returned without sensitive data
   * This behavior exists to preserve backwards compatibility that originally always returned sensitive data
   *
   * @generated from field: bool exclude_sensitive = 2;
   */
  excludeSensitive: boolean;
};

/**
 * Describes the message mgmt.v1alpha1.GetConnectionsRequest.
 * Use `create(GetConnectionsRequestSchema)` to create a new message.
 */
export const GetConnectionsRequestSchema: GenMessage<GetConnectionsRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 0);

/**
 * @generated from message mgmt.v1alpha1.GetConnectionsResponse
 */
export type GetConnectionsResponse = Message<"mgmt.v1alpha1.GetConnectionsResponse"> & {
  /**
   * The connections
   *
   * @generated from field: repeated mgmt.v1alpha1.Connection connections = 1;
   */
  connections: Connection[];
};

/**
 * Describes the message mgmt.v1alpha1.GetConnectionsResponse.
 * Use `create(GetConnectionsResponseSchema)` to create a new message.
 */
export const GetConnectionsResponseSchema: GenMessage<GetConnectionsResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 1);

/**
 * @generated from message mgmt.v1alpha1.GetConnectionRequest
 */
export type GetConnectionRequest = Message<"mgmt.v1alpha1.GetConnectionRequest"> & {
  /**
   * The unique identifier of the connection to get
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Whether or not to exclude sensitive data from the connection
   * If the caller does not have permission to view sensitive data, the connection will always be returned without sensitive data
   * This behavior exists to preserve backwards compatibility that originally always returned sensitive data
   *
   * @generated from field: bool exclude_sensitive = 2;
   */
  excludeSensitive: boolean;
};

/**
 * Describes the message mgmt.v1alpha1.GetConnectionRequest.
 * Use `create(GetConnectionRequestSchema)` to create a new message.
 */
export const GetConnectionRequestSchema: GenMessage<GetConnectionRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 2);

/**
 * @generated from message mgmt.v1alpha1.GetConnectionResponse
 */
export type GetConnectionResponse = Message<"mgmt.v1alpha1.GetConnectionResponse"> & {
  /**
   * The connection
   *
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;
};

/**
 * Describes the message mgmt.v1alpha1.GetConnectionResponse.
 * Use `create(GetConnectionResponseSchema)` to create a new message.
 */
export const GetConnectionResponseSchema: GenMessage<GetConnectionResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 3);

/**
 * @generated from message mgmt.v1alpha1.CreateConnectionRequest
 */
export type CreateConnectionRequest = Message<"mgmt.v1alpha1.CreateConnectionRequest"> & {
  /**
   * The unique identifier of the account to create the connection for
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The friendly name of the connection
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The connection configuration to use for the connection
   *
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;
};

/**
 * Describes the message mgmt.v1alpha1.CreateConnectionRequest.
 * Use `create(CreateConnectionRequestSchema)` to create a new message.
 */
export const CreateConnectionRequestSchema: GenMessage<CreateConnectionRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 4);

/**
 * @generated from message mgmt.v1alpha1.CreateConnectionResponse
 */
export type CreateConnectionResponse = Message<"mgmt.v1alpha1.CreateConnectionResponse"> & {
  /**
   * The created connection
   *
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;
};

/**
 * Describes the message mgmt.v1alpha1.CreateConnectionResponse.
 * Use `create(CreateConnectionResponseSchema)` to create a new message.
 */
export const CreateConnectionResponseSchema: GenMessage<CreateConnectionResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 5);

/**
 * @generated from message mgmt.v1alpha1.UpdateConnectionRequest
 */
export type UpdateConnectionRequest = Message<"mgmt.v1alpha1.UpdateConnectionRequest"> & {
  /**
   * The unique identifier of the connection to update
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The friendly name of the connection
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The connection configuration to use for the connection
   *
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;
};

/**
 * Describes the message mgmt.v1alpha1.UpdateConnectionRequest.
 * Use `create(UpdateConnectionRequestSchema)` to create a new message.
 */
export const UpdateConnectionRequestSchema: GenMessage<UpdateConnectionRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 6);

/**
 * @generated from message mgmt.v1alpha1.UpdateConnectionResponse
 */
export type UpdateConnectionResponse = Message<"mgmt.v1alpha1.UpdateConnectionResponse"> & {
  /**
   * The updated connection
   *
   * @generated from field: mgmt.v1alpha1.Connection connection = 1;
   */
  connection?: Connection;
};

/**
 * Describes the message mgmt.v1alpha1.UpdateConnectionResponse.
 * Use `create(UpdateConnectionResponseSchema)` to create a new message.
 */
export const UpdateConnectionResponseSchema: GenMessage<UpdateConnectionResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 7);

/**
 * @generated from message mgmt.v1alpha1.DeleteConnectionRequest
 */
export type DeleteConnectionRequest = Message<"mgmt.v1alpha1.DeleteConnectionRequest"> & {
  /**
   * The unique identifier of the connection to delete
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message mgmt.v1alpha1.DeleteConnectionRequest.
 * Use `create(DeleteConnectionRequestSchema)` to create a new message.
 */
export const DeleteConnectionRequestSchema: GenMessage<DeleteConnectionRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 8);

/**
 * @generated from message mgmt.v1alpha1.DeleteConnectionResponse
 */
export type DeleteConnectionResponse = Message<"mgmt.v1alpha1.DeleteConnectionResponse"> & {
};

/**
 * Describes the message mgmt.v1alpha1.DeleteConnectionResponse.
 * Use `create(DeleteConnectionResponseSchema)` to create a new message.
 */
export const DeleteConnectionResponseSchema: GenMessage<DeleteConnectionResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 9);

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigRequest
 */
export type CheckConnectionConfigRequest = Message<"mgmt.v1alpha1.CheckConnectionConfigRequest"> & {
  /**
   * The connection configuration to validate
   *
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 1;
   */
  connectionConfig?: ConnectionConfig;
};

/**
 * Describes the message mgmt.v1alpha1.CheckConnectionConfigRequest.
 * Use `create(CheckConnectionConfigRequestSchema)` to create a new message.
 */
export const CheckConnectionConfigRequestSchema: GenMessage<CheckConnectionConfigRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 10);

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigByIdRequest
 */
export type CheckConnectionConfigByIdRequest = Message<"mgmt.v1alpha1.CheckConnectionConfigByIdRequest"> & {
  /**
   * The connection id to validate
   *
   * @generated from field: string id = 1;
   */
  id: string;
};

/**
 * Describes the message mgmt.v1alpha1.CheckConnectionConfigByIdRequest.
 * Use `create(CheckConnectionConfigByIdRequestSchema)` to create a new message.
 */
export const CheckConnectionConfigByIdRequestSchema: GenMessage<CheckConnectionConfigByIdRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 11);

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigByIdResponse
 */
export type CheckConnectionConfigByIdResponse = Message<"mgmt.v1alpha1.CheckConnectionConfigByIdResponse"> & {
  /**
   * Whether or not the API was able to ping the connection
   *
   * @generated from field: bool is_connected = 1;
   */
  isConnected: boolean;

  /**
   * This is the error that was received if the API was unable to connect
   *
   * @generated from field: optional string connection_error = 2;
   */
  connectionError?: string;

  /**
   * The privileges the role has to the connection
   *
   * @generated from field: repeated mgmt.v1alpha1.ConnectionRolePrivilege privileges = 3;
   */
  privileges: ConnectionRolePrivilege[];
};

/**
 * Describes the message mgmt.v1alpha1.CheckConnectionConfigByIdResponse.
 * Use `create(CheckConnectionConfigByIdResponseSchema)` to create a new message.
 */
export const CheckConnectionConfigByIdResponseSchema: GenMessage<CheckConnectionConfigByIdResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 12);

/**
 * @generated from message mgmt.v1alpha1.CheckConnectionConfigResponse
 */
export type CheckConnectionConfigResponse = Message<"mgmt.v1alpha1.CheckConnectionConfigResponse"> & {
  /**
   * Whether or not the API was able to ping the connection
   *
   * @generated from field: bool is_connected = 1;
   */
  isConnected: boolean;

  /**
   * This is the error that was received if the API was unable to connect
   *
   * @generated from field: optional string connection_error = 2;
   */
  connectionError?: string;

  /**
   * @generated from field: repeated mgmt.v1alpha1.ConnectionRolePrivilege privileges = 3;
   */
  privileges: ConnectionRolePrivilege[];
};

/**
 * Describes the message mgmt.v1alpha1.CheckConnectionConfigResponse.
 * Use `create(CheckConnectionConfigResponseSchema)` to create a new message.
 */
export const CheckConnectionConfigResponseSchema: GenMessage<CheckConnectionConfigResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 13);

/**
 * @generated from message mgmt.v1alpha1.ConnectionRolePrivilege
 */
export type ConnectionRolePrivilege = Message<"mgmt.v1alpha1.ConnectionRolePrivilege"> & {
  /**
   * The role that was given the permissions
   *
   * @generated from field: string grantee = 1;
   */
  grantee: string;

  /**
   * The database schema. Ex: public
   *
   * @generated from field: string schema = 2;
   */
  schema: string;

  /**
   * The name of the table in the schema
   *
   * @generated from field: string table = 3;
   */
  table: string;

  /**
   * The privileges given to that role
   *
   * @generated from field: repeated string privilege_type = 4;
   */
  privilegeType: string[];
};

/**
 * Describes the message mgmt.v1alpha1.ConnectionRolePrivilege.
 * Use `create(ConnectionRolePrivilegeSchema)` to create a new message.
 */
export const ConnectionRolePrivilegeSchema: GenMessage<ConnectionRolePrivilege> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 14);

/**
 * @generated from message mgmt.v1alpha1.Connection
 */
export type Connection = Message<"mgmt.v1alpha1.Connection"> & {
  /**
   * The unique identifier of the connection
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The unique, friendly name of the connection
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * Contains the connection configuration and connection type
   *
   * @generated from field: mgmt.v1alpha1.ConnectionConfig connection_config = 3;
   */
  connectionConfig?: ConnectionConfig;

  /**
   * The user id of the user that created the connection
   *
   * @generated from field: string created_by_user_id = 4;
   */
  createdByUserId: string;

  /**
   * When the connection was created
   *
   * @generated from field: google.protobuf.Timestamp created_at = 5;
   */
  createdAt?: Timestamp;

  /**
   * Who last updated the connection
   *
   * @generated from field: string updated_by_user_id = 6;
   */
  updatedByUserId: string;

  /**
   * When the connection was last updated
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 7;
   */
  updatedAt?: Timestamp;

  /**
   * The unique account that owns this connection
   *
   * @generated from field: string account_id = 8;
   */
  accountId: string;
};

/**
 * Describes the message mgmt.v1alpha1.Connection.
 * Use `create(ConnectionSchema)` to create a new message.
 */
export const ConnectionSchema: GenMessage<Connection> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 15);

/**
 * Configuration for all of the supported Neosync connection types
 *
 * @generated from message mgmt.v1alpha1.ConnectionConfig
 */
export type ConnectionConfig = Message<"mgmt.v1alpha1.ConnectionConfig"> & {
  /**
   * @generated from oneof mgmt.v1alpha1.ConnectionConfig.config
   */
  config: {
    /**
     * Configures a PostgreSQL connection
     *
     * @generated from field: mgmt.v1alpha1.PostgresConnectionConfig pg_config = 1;
     */
    value: PostgresConnectionConfig;
    case: "pgConfig";
  } | {
    /**
     * Configures an AWS S3 Connection
     *
     * @generated from field: mgmt.v1alpha1.AwsS3ConnectionConfig aws_s3_config = 2;
     */
    value: AwsS3ConnectionConfig;
    case: "awsS3Config";
  } | {
    /**
     * Configures a MySQL connection
     *
     * @generated from field: mgmt.v1alpha1.MysqlConnectionConfig mysql_config = 3;
     */
    value: MysqlConnectionConfig;
    case: "mysqlConfig";
  } | {
    /**
     * Configures a connection to a directory available on the local file system
     *
     * @generated from field: mgmt.v1alpha1.LocalDirectoryConnectionConfig local_dir_config = 4;
     */
    value: LocalDirectoryConnectionConfig;
    case: "localDirConfig";
  } | {
    /**
     * Connection config for an OpenAI (or compatible) Connection
     *
     * @generated from field: mgmt.v1alpha1.OpenAiConnectionConfig openai_config = 5;
     */
    value: OpenAiConnectionConfig;
    case: "openaiConfig";
  } | {
    /**
     * Configures a MongoDB Connection
     *
     * @generated from field: mgmt.v1alpha1.MongoConnectionConfig mongo_config = 6;
     */
    value: MongoConnectionConfig;
    case: "mongoConfig";
  } | {
    /**
     * Configures a GCP Cloud Storage Connection
     *
     * @generated from field: mgmt.v1alpha1.GcpCloudStorageConnectionConfig gcp_cloudstorage_config = 7;
     */
    value: GcpCloudStorageConnectionConfig;
    case: "gcpCloudstorageConfig";
  } | {
    /**
     * Configures a DynamoDB Connection
     *
     * @generated from field: mgmt.v1alpha1.DynamoDBConnectionConfig dynamodb_config = 8;
     */
    value: DynamoDBConnectionConfig;
    case: "dynamodbConfig";
  } | {
    /**
     * Configures a Microsoft SQL Server (mssql) Connection
     *
     * @generated from field: mgmt.v1alpha1.MssqlConnectionConfig mssql_config = 9;
     */
    value: MssqlConnectionConfig;
    case: "mssqlConfig";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message mgmt.v1alpha1.ConnectionConfig.
 * Use `create(ConnectionConfigSchema)` to create a new message.
 */
export const ConnectionConfigSchema: GenMessage<ConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 16);

/**
 * Configuration for a Mssql Connection
 *
 * @generated from message mgmt.v1alpha1.MssqlConnectionConfig
 */
export type MssqlConnectionConfig = Message<"mgmt.v1alpha1.MssqlConnectionConfig"> & {
  /**
   * May provide a raw string url or in the future other methods of connection
   *
   * @generated from oneof mgmt.v1alpha1.MssqlConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * The URL with sqlserver scheme.
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | {
    /**
     * Source a url from an environment variable.
     * The value is expected to be in the same format as the "url" field above.
     * The key is the name of the environment variable to source. It must contain a prefix of "USER_DEFINED_"
     *
     * @generated from field: string url_from_env = 5;
     */
    value: string;
    case: "urlFromEnv";
  } | { case: undefined; value?: undefined };

  /**
   * Provide connection options that can be used to further fine-tune the connection
   *
   * @generated from field: mgmt.v1alpha1.SqlConnectionOptions connection_options = 2;
   */
  connectionOptions?: SqlConnectionOptions;

  /**
   * Provide tunnel configuration that can be used to access a postgres connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 3;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 4;
   */
  clientTls?: ClientTlsConfig;
};

/**
 * Describes the message mgmt.v1alpha1.MssqlConnectionConfig.
 * Use `create(MssqlConnectionConfigSchema)` to create a new message.
 */
export const MssqlConnectionConfigSchema: GenMessage<MssqlConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 17);

/**
 * Configuration for a DynaomDB Connection
 *
 * @generated from message mgmt.v1alpha1.DynamoDBConnectionConfig
 */
export type DynamoDBConnectionConfig = Message<"mgmt.v1alpha1.DynamoDBConnectionConfig"> & {
  /**
   * Optional credentials that may be provided and will be used to connect to the DynamoDB Instance.
   * If self-hosting, this may be provided by the environment in lieu of specifying these here
   *
   * @generated from field: optional mgmt.v1alpha1.AwsS3Credentials credentials = 1;
   */
  credentials?: AwsS3Credentials;

  /**
   * Optionally specify the region that the dynamodb instance lives in if not provided by the environment.
   *
   * @generated from field: optional string region = 2;
   */
  region?: string;

  /**
   * Optionally specify the endpoint that will be used by the AWS SDK.
   *
   * @generated from field: optional string endpoint = 3;
   */
  endpoint?: string;
};

/**
 * Describes the message mgmt.v1alpha1.DynamoDBConnectionConfig.
 * Use `create(DynamoDBConnectionConfigSchema)` to create a new message.
 */
export const DynamoDBConnectionConfigSchema: GenMessage<DynamoDBConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 18);

/**
 * @generated from message mgmt.v1alpha1.MongoConnectionConfig
 */
export type MongoConnectionConfig = Message<"mgmt.v1alpha1.MongoConnectionConfig"> & {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.MongoConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * The full mongo connection url
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | { case: undefined; value?: undefined };

  /**
   * Provide tunnel configuration that can be used to access a connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 2;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 3;
   */
  clientTls?: ClientTlsConfig;
};

/**
 * Describes the message mgmt.v1alpha1.MongoConnectionConfig.
 * Use `create(MongoConnectionConfigSchema)` to create a new message.
 */
export const MongoConnectionConfigSchema: GenMessage<MongoConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 19);

/**
 * Configures a connection to OpenAI or OpenAI compatible API.
 *
 * @generated from message mgmt.v1alpha1.OpenAiConnectionConfig
 */
export type OpenAiConnectionConfig = Message<"mgmt.v1alpha1.OpenAiConnectionConfig"> & {
  /**
   * OpenAI Api Key
   *
   * @generated from field: string api_key = 1;
   */
  apiKey: string;

  /**
   * OpenAI URL (if using a custom endpoint)
   *
   * @generated from field: string api_url = 2;
   */
  apiUrl: string;
};

/**
 * Describes the message mgmt.v1alpha1.OpenAiConnectionConfig.
 * Use `create(OpenAiConnectionConfigSchema)` to create a new message.
 */
export const OpenAiConnectionConfigSchema: GenMessage<OpenAiConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 20);

/**
 * Configures a connection to a directory available on the local file system
 *
 * @generated from message mgmt.v1alpha1.LocalDirectoryConnectionConfig
 */
export type LocalDirectoryConnectionConfig = Message<"mgmt.v1alpha1.LocalDirectoryConnectionConfig"> & {
  /**
   * The absolute path to a directory that is available on the local file system to the API and Worker nodes
   *
   * @generated from field: string path = 1;
   */
  path: string;
};

/**
 * Describes the message mgmt.v1alpha1.LocalDirectoryConnectionConfig.
 * Use `create(LocalDirectoryConnectionConfigSchema)` to create a new message.
 */
export const LocalDirectoryConnectionConfigSchema: GenMessage<LocalDirectoryConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 21);

/**
 * @generated from message mgmt.v1alpha1.PostgresConnectionConfig
 */
export type PostgresConnectionConfig = Message<"mgmt.v1alpha1.PostgresConnectionConfig"> & {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.PostgresConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * A raw string url that will be used to construct the connection. Must be URI format.
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | {
    /**
     * A structured representation of the connection that will be used to construct the url
     *
     * @generated from field: mgmt.v1alpha1.PostgresConnection connection = 2;
     */
    value: PostgresConnection;
    case: "connection";
  } | {
    /**
     * Source a url from an environment variable.
     * The value is expected to be in the same format as the "url" field above.
     * The key is the name of the environment variable to source. It must contain a prefix of "USER_DEFINED_"
     *
     * @generated from field: string url_from_env = 6;
     */
    value: string;
    case: "urlFromEnv";
  } | { case: undefined; value?: undefined };

  /**
   * Provide tunnel configuration that can be used to access a postgres connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 3;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide connection options that can be used to further fine-tune the connection
   *
   * @generated from field: mgmt.v1alpha1.SqlConnectionOptions connection_options = 4;
   */
  connectionOptions?: SqlConnectionOptions;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 5;
   */
  clientTls?: ClientTlsConfig;
};

/**
 * Describes the message mgmt.v1alpha1.PostgresConnectionConfig.
 * Use `create(PostgresConnectionConfigSchema)` to create a new message.
 */
export const PostgresConnectionConfigSchema: GenMessage<PostgresConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 22);

/**
 * Config for providing client-side TLS certificates
 *
 * @generated from message mgmt.v1alpha1.ClientTlsConfig
 */
export type ClientTlsConfig = Message<"mgmt.v1alpha1.ClientTlsConfig"> & {
  /**
   * Root Certificate in PEM Format
   *
   * @generated from field: optional string root_cert = 1;
   */
  rootCert?: string;

  /**
   * Client Certificate in PEM format. Must also provide key.
   *
   * @generated from field: optional string client_cert = 2;
   */
  clientCert?: string;

  /**
   * Client Key in PEM format. Must also provide cert.
   *
   * @generated from field: optional string client_key = 3;
   */
  clientKey?: string;

  /**
   * Provide the expected server name. Depending on the driver or encryption mode, this may be required
   * In order to fully validate the server certificate.
   *
   * @generated from field: optional string server_name = 4;
   */
  serverName?: string;
};

/**
 * Describes the message mgmt.v1alpha1.ClientTlsConfig.
 * Use `create(ClientTlsConfigSchema)` to create a new message.
 */
export const ClientTlsConfigSchema: GenMessage<ClientTlsConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 23);

/**
 * @generated from message mgmt.v1alpha1.SqlConnectionOptions
 */
export type SqlConnectionOptions = Message<"mgmt.v1alpha1.SqlConnectionOptions"> & {
  /**
   * Sets the maximum number of open connections
   * If this value is greater than 0, but less than the max_idle_connections, then max_idle_connections will be reduced to match the max_connection_limit
   * If this value is less than or equal to 0, then there is no limit on the number of open connections. If not provided, the default is 0 (unlimited).
   *
   * @generated from field: optional int32 max_connection_limit = 1;
   */
  maxConnectionLimit?: number;

  /**
   * Sets the maximum number of connections in the idle connection pool.
   * This value will be reduced at runtime to match the max_connection_limit if max_connection_limit is greater than 0 but less than this value.
   * If this value is less than or equal to 0, then no idle connections are maintained. If not provided, the default is 2, which may change in a future release.
   *
   * @generated from field: optional int32 max_idle_connections = 2;
   */
  maxIdleConnections?: number;

  /**
   * Sets the maximum amount of time a connection may be idle.
   * Expired connections may be closed lazily before reuse.
   * if this value is less than or equal to 0, connections are not closed due to a connection's idle time.
   * This value is parsed as a Go duration string (ex: 1s, 1m, 500ms)
   *
   * @generated from field: optional string max_idle_duration = 3;
   */
  maxIdleDuration?: string;

  /**
   * Sets the maximum amount of time a connection may be reused.
   * Expired connections may be closed lazily before reuse.
   * If this value is less than or equal to 0, connections may not be closed due to a connection's age.
   * This value is parsed as a Go duration string (ex: 1s, 1m, 500ms)
   *
   * @generated from field: optional string max_open_duration = 4;
   */
  maxOpenDuration?: string;
};

/**
 * Describes the message mgmt.v1alpha1.SqlConnectionOptions.
 * Use `create(SqlConnectionOptionsSchema)` to create a new message.
 */
export const SqlConnectionOptionsSchema: GenMessage<SqlConnectionOptions> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 24);

/**
 * @generated from message mgmt.v1alpha1.SSHTunnel
 */
export type SSHTunnel = Message<"mgmt.v1alpha1.SSHTunnel"> & {
  /**
   * The host of the SSH server
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The port of the SSH server, typically 22
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * The user that will be used to authenticate
   *
   * @generated from field: string user = 3;
   */
  user: string;

  /**
   * Optionally provide the public key of the known host of the SSH tunnel that we are connecting to.
   * If this is not provided, the server will blindly connect to the host with the given credentials.
   * This is not recommended for production use!
   *
   * @generated from field: optional string known_host_public_key = 4;
   */
  knownHostPublicKey?: string;

  /**
   * Provide the authentication required to successfully connect to the SSH server for tunneling
   *
   * @generated from field: mgmt.v1alpha1.SSHAuthentication authentication = 5;
   */
  authentication?: SSHAuthentication;
};

/**
 * Describes the message mgmt.v1alpha1.SSHTunnel.
 * Use `create(SSHTunnelSchema)` to create a new message.
 */
export const SSHTunnelSchema: GenMessage<SSHTunnel> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 25);

/**
 * SSH Authentication
 *
 * @generated from message mgmt.v1alpha1.SSHAuthentication
 */
export type SSHAuthentication = Message<"mgmt.v1alpha1.SSHAuthentication"> & {
  /**
   * @generated from oneof mgmt.v1alpha1.SSHAuthentication.auth_config
   */
  authConfig: {
    /**
     * Password authentication
     *
     * @generated from field: mgmt.v1alpha1.SSHPassphrase passphrase = 1;
     */
    value: SSHPassphrase;
    case: "passphrase";
  } | {
    /**
     * Private key authentication
     *
     * @generated from field: mgmt.v1alpha1.SSHPrivateKey private_key = 2;
     */
    value: SSHPrivateKey;
    case: "privateKey";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message mgmt.v1alpha1.SSHAuthentication.
 * Use `create(SSHAuthenticationSchema)` to create a new message.
 */
export const SSHAuthenticationSchema: GenMessage<SSHAuthentication> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 26);

/**
 * Contains the configuration needed to retrieve the SSH passphrase for the tunnel
 *
 * @generated from message mgmt.v1alpha1.SSHPassphrase
 */
export type SSHPassphrase = Message<"mgmt.v1alpha1.SSHPassphrase"> & {
  /**
   * The password to be used to connect to the SSH server
   *
   * eventually we can expand this to allow pulling from other sources.
   *
   * @generated from field: string value = 1;
   */
  value: string;
};

/**
 * Describes the message mgmt.v1alpha1.SSHPassphrase.
 * Use `create(SSHPassphraseSchema)` to create a new message.
 */
export const SSHPassphraseSchema: GenMessage<SSHPassphrase> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 27);

/**
 * Contains the configuration needed to retrieve the SSH private key for the tunnel
 *
 * @generated from message mgmt.v1alpha1.SSHPrivateKey
 */
export type SSHPrivateKey = Message<"mgmt.v1alpha1.SSHPrivateKey"> & {
  /**
   * The private key in PEM format.
   *
   * @generated from field: string value = 1;
   */
  value: string;

  /**
   * If the private key is encrypted, this value should decrypt it.
   *
   * @generated from field: optional string passphrase = 2;
   */
  passphrase?: string;
};

/**
 * Describes the message mgmt.v1alpha1.SSHPrivateKey.
 * Use `create(SSHPrivateKeySchema)` to create a new message.
 */
export const SSHPrivateKeySchema: GenMessage<SSHPrivateKey> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 28);

/**
 * @generated from message mgmt.v1alpha1.PostgresConnection
 */
export type PostgresConnection = Message<"mgmt.v1alpha1.PostgresConnection"> & {
  /**
   * The host to use for the connection
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * The port to use for the connection
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * The name of the database to use for the connection
   *
   * @generated from field: string name = 3;
   */
  name: string;

  /**
   * The user to use for the connection
   *
   * @generated from field: string user = 4;
   */
  user: string;

  /**
   * The password to use for the connection
   *
   * @generated from field: string pass = 5;
   */
  pass: string;

  /**
   * The SSL mode to use for the connection
   *
   * @generated from field: optional string ssl_mode = 6;
   */
  sslMode?: string;
};

/**
 * Describes the message mgmt.v1alpha1.PostgresConnection.
 * Use `create(PostgresConnectionSchema)` to create a new message.
 */
export const PostgresConnectionSchema: GenMessage<PostgresConnection> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 29);

/**
 * @generated from message mgmt.v1alpha1.MysqlConnection
 */
export type MysqlConnection = Message<"mgmt.v1alpha1.MysqlConnection"> & {
  /**
   * The user to use for the connection
   *
   * @generated from field: string user = 1;
   */
  user: string;

  /**
   * The password to use for the connection
   *
   * @generated from field: string pass = 2;
   */
  pass: string;

  /**
   * The protocol to use for the connection
   *
   * @generated from field: string protocol = 3;
   */
  protocol: string;

  /**
   * The host to use for the connection
   *
   * @generated from field: string host = 4;
   */
  host: string;

  /**
   * The port to use for the connection
   *
   * @generated from field: int32 port = 5;
   */
  port: number;

  /**
   * The name of the database to use for the connection
   *
   * @generated from field: string name = 6;
   */
  name: string;
};

/**
 * Describes the message mgmt.v1alpha1.MysqlConnection.
 * Use `create(MysqlConnectionSchema)` to create a new message.
 */
export const MysqlConnectionSchema: GenMessage<MysqlConnection> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 30);

/**
 * @generated from message mgmt.v1alpha1.MysqlConnectionConfig
 */
export type MysqlConnectionConfig = Message<"mgmt.v1alpha1.MysqlConnectionConfig"> & {
  /**
   * May provide either a raw string url, or a structured version
   *
   * @generated from oneof mgmt.v1alpha1.MysqlConnectionConfig.connection_config
   */
  connectionConfig: {
    /**
     * A raw string url that will be used to construct the connection. DSN format. URI format also supported but more limited.
     *
     * @generated from field: string url = 1;
     */
    value: string;
    case: "url";
  } | {
    /**
     * A structured representation of the connection that will be used to construct the url
     *
     * @generated from field: mgmt.v1alpha1.MysqlConnection connection = 2;
     */
    value: MysqlConnection;
    case: "connection";
  } | {
    /**
     * Source a url from an environment variable.
     * The value is expected to be in the same format as the "url" field above.
     * The key is the name of the environment variable to source. It must contain a prefix of "USER_DEFINED_"
     *
     * @generated from field: string url_from_env = 6;
     */
    value: string;
    case: "urlFromEnv";
  } | { case: undefined; value?: undefined };

  /**
   * Provide tunnel configuration that can be used to access a postgres connection that is not publicly accessible to the internet
   *
   * @generated from field: mgmt.v1alpha1.SSHTunnel tunnel = 3;
   */
  tunnel?: SSHTunnel;

  /**
   * Provide connection options that can be used to further fine-tune the connection
   *
   * @generated from field: mgmt.v1alpha1.SqlConnectionOptions connection_options = 4;
   */
  connectionOptions?: SqlConnectionOptions;

  /**
   * Provide client-side TLS Certificates
   *
   * @generated from field: mgmt.v1alpha1.ClientTlsConfig client_tls = 5;
   */
  clientTls?: ClientTlsConfig;
};

/**
 * Describes the message mgmt.v1alpha1.MysqlConnectionConfig.
 * Use `create(MysqlConnectionConfigSchema)` to create a new message.
 */
export const MysqlConnectionConfigSchema: GenMessage<MysqlConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 31);

/**
 * @generated from message mgmt.v1alpha1.AwsS3ConnectionConfig
 */
export type AwsS3ConnectionConfig = Message<"mgmt.v1alpha1.AwsS3ConnectionConfig"> & {
  /**
   * The bucket path prefix that will be appended to each file
   *
   * @generated from field: optional string path_prefix = 2;
   */
  pathPrefix?: string;

  /**
   * The credentials to use for the S3 bucket
   *
   * @generated from field: optional mgmt.v1alpha1.AwsS3Credentials credentials = 3;
   */
  credentials?: AwsS3Credentials;

  /**
   * The region of the S3 bucket
   *
   * @generated from field: optional string region = 4;
   */
  region?: string;

  /**
   * The endpoint of the S3 bucket (if using a custom endpoint like region specific endpoints or S3-compatible APIs)
   *
   * @generated from field: optional string endpoint = 5;
   */
  endpoint?: string;

  /**
   * The name of the S3 bucket
   *
   * @generated from field: string bucket = 6;
   */
  bucket: string;
};

/**
 * Describes the message mgmt.v1alpha1.AwsS3ConnectionConfig.
 * Use `create(AwsS3ConnectionConfigSchema)` to create a new message.
 */
export const AwsS3ConnectionConfigSchema: GenMessage<AwsS3ConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 32);

/**
 * S3 Credentials that are used by the worker process.
 * Note: this may be optionally provided if the worker that is being hosted has environment credentials to the S3 bucket instead.
 *
 * @generated from message mgmt.v1alpha1.AwsS3Credentials
 */
export type AwsS3Credentials = Message<"mgmt.v1alpha1.AwsS3Credentials"> & {
  /**
   * The profile to use for the S3 credentials
   *
   * @generated from field: optional string profile = 1;
   */
  profile?: string;

  /**
   * The access key id to use for the S3 credentials
   *
   * @generated from field: optional string access_key_id = 2;
   */
  accessKeyId?: string;

  /**
   * The secret access key to use for the S3 credentials
   *
   * @generated from field: optional string secret_access_key = 3;
   */
  secretAccessKey?: string;

  /**
   * The session token to use for the S3 credentials
   *
   * @generated from field: optional string session_token = 4;
   */
  sessionToken?: string;

  /**
   * Whether or not the credentials are from an EC2 role
   *
   * @generated from field: optional bool from_ec2_role = 5;
   */
  fromEc2Role?: boolean;

  /**
   * The ARN of the role to use for the S3 credentials
   *
   * @generated from field: optional string role_arn = 6;
   */
  roleArn?: string;

  /**
   * The role's external ID to use for the S3 credentials
   *
   * @generated from field: optional string role_external_id = 7;
   */
  roleExternalId?: string;
};

/**
 * Describes the message mgmt.v1alpha1.AwsS3Credentials.
 * Use `create(AwsS3CredentialsSchema)` to create a new message.
 */
export const AwsS3CredentialsSchema: GenMessage<AwsS3Credentials> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 33);

/**
 * Configuration for GCP Cloud Storage Buckets
 *
 * @generated from message mgmt.v1alpha1.GcpCloudStorageConnectionConfig
 */
export type GcpCloudStorageConnectionConfig = Message<"mgmt.v1alpha1.GcpCloudStorageConnectionConfig"> & {
  /**
   * The GCP Cloud Storage bucket that will be accessed.
   *
   * @generated from field: string bucket = 1;
   */
  bucket: string;

  /**
   * The path prefix that will be appended to each file
   *
   * @generated from field: optional string path_prefix = 2;
   */
  pathPrefix?: string;

  /**
   * stringified json of the service account credentials file
   *
   * @generated from field: optional string service_account_credentials = 3;
   */
  serviceAccountCredentials?: string;
};

/**
 * Describes the message mgmt.v1alpha1.GcpCloudStorageConnectionConfig.
 * Use `create(GcpCloudStorageConnectionConfigSchema)` to create a new message.
 */
export const GcpCloudStorageConnectionConfigSchema: GenMessage<GcpCloudStorageConnectionConfig> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 34);

/**
 * @generated from message mgmt.v1alpha1.IsConnectionNameAvailableRequest
 */
export type IsConnectionNameAvailableRequest = Message<"mgmt.v1alpha1.IsConnectionNameAvailableRequest"> & {
  /**
   * The unique identifier of the account to check the connection name for
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The connection name to check for availability
   *
   * @generated from field: string connection_name = 2;
   */
  connectionName: string;
};

/**
 * Describes the message mgmt.v1alpha1.IsConnectionNameAvailableRequest.
 * Use `create(IsConnectionNameAvailableRequestSchema)` to create a new message.
 */
export const IsConnectionNameAvailableRequestSchema: GenMessage<IsConnectionNameAvailableRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 35);

/**
 * @generated from message mgmt.v1alpha1.IsConnectionNameAvailableResponse
 */
export type IsConnectionNameAvailableResponse = Message<"mgmt.v1alpha1.IsConnectionNameAvailableResponse"> & {
  /**
   * Whether or not the connection name is available
   *
   * @generated from field: bool is_available = 1;
   */
  isAvailable: boolean;
};

/**
 * Describes the message mgmt.v1alpha1.IsConnectionNameAvailableResponse.
 * Use `create(IsConnectionNameAvailableResponseSchema)` to create a new message.
 */
export const IsConnectionNameAvailableResponseSchema: GenMessage<IsConnectionNameAvailableResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 36);

/**
 * @generated from message mgmt.v1alpha1.CheckSqlQueryRequest
 */
export type CheckSqlQueryRequest = Message<"mgmt.v1alpha1.CheckSqlQueryRequest"> & {
  /**
   * The connection id that the query will be checked against
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * The full query that will be run through a PREPARE statement
   *
   * @generated from field: string query = 2;
   */
  query: string;
};

/**
 * Describes the message mgmt.v1alpha1.CheckSqlQueryRequest.
 * Use `create(CheckSqlQueryRequestSchema)` to create a new message.
 */
export const CheckSqlQueryRequestSchema: GenMessage<CheckSqlQueryRequest> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 37);

/**
 * @generated from message mgmt.v1alpha1.CheckSqlQueryResponse
 */
export type CheckSqlQueryResponse = Message<"mgmt.v1alpha1.CheckSqlQueryResponse"> & {
  /**
   * The query is run through PREPARE. Returns valid if it correctly compiled
   *
   * @generated from field: bool is_valid = 1;
   */
  isValid: boolean;

  /**
   * The error message returned by the sql client if the prepare did not return successfully
   *
   * @generated from field: optional string erorr_message = 2;
   */
  erorrMessage?: string;
};

/**
 * Describes the message mgmt.v1alpha1.CheckSqlQueryResponse.
 * Use `create(CheckSqlQueryResponseSchema)` to create a new message.
 */
export const CheckSqlQueryResponseSchema: GenMessage<CheckSqlQueryResponse> = /*@__PURE__*/
  messageDesc(file_mgmt_v1alpha1_connection, 38);

/**
 * Service for managing datasource connections.
 * This is a primary data model in Neosync and is used in reference when hooking up Jobs to synchronize and generate data.
 *
 * @generated from service mgmt.v1alpha1.ConnectionService
 */
export const ConnectionService: GenService<{
  /**
   * Returns a list of connections associated with the account
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.GetConnections
   */
  getConnections: {
    methodKind: "unary";
    input: typeof GetConnectionsRequestSchema;
    output: typeof GetConnectionsResponseSchema;
  },
  /**
   * Returns a single connection
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.GetConnection
   */
  getConnection: {
    methodKind: "unary";
    input: typeof GetConnectionRequestSchema;
    output: typeof GetConnectionResponseSchema;
  },
  /**
   * Creates a new connection
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.CreateConnection
   */
  createConnection: {
    methodKind: "unary";
    input: typeof CreateConnectionRequestSchema;
    output: typeof CreateConnectionResponseSchema;
  },
  /**
   * Updates an existing connection
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.UpdateConnection
   */
  updateConnection: {
    methodKind: "unary";
    input: typeof UpdateConnectionRequestSchema;
    output: typeof UpdateConnectionResponseSchema;
  },
  /**
   * Removes a connection from the system.
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.DeleteConnection
   */
  deleteConnection: {
    methodKind: "unary";
    input: typeof DeleteConnectionRequestSchema;
    output: typeof DeleteConnectionResponseSchema;
  },
  /**
   * Connections have friendly names, this method checks if the requested name is available in the system based on the account
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.IsConnectionNameAvailable
   */
  isConnectionNameAvailable: {
    methodKind: "unary";
    input: typeof IsConnectionNameAvailableRequestSchema;
    output: typeof IsConnectionNameAvailableResponseSchema;
  },
  /**
   * Checks if the connection config is connectable by the backend.
   * Used mostly to verify that a connection is valid prior to creating a Connection object.
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.CheckConnectionConfig
   */
  checkConnectionConfig: {
    methodKind: "unary";
    input: typeof CheckConnectionConfigRequestSchema;
    output: typeof CheckConnectionConfigResponseSchema;
  },
  /**
   * Checks if the connection id is connectable by the backend.
   * Used to verify that a connection is still connectable.
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.CheckConnectionConfigById
   */
  checkConnectionConfigById: {
    methodKind: "unary";
    input: typeof CheckConnectionConfigByIdRequestSchema;
    output: typeof CheckConnectionConfigByIdResponseSchema;
  },
  /**
   * Checks a constructed SQL query against a sql-based connection to see if it's valid based on that connection's data schema
   * This is useful when constructing subsets to see if the WHERE clause is correct
   *
   * @generated from rpc mgmt.v1alpha1.ConnectionService.CheckSqlQuery
   */
  checkSqlQuery: {
    methodKind: "unary";
    input: typeof CheckSqlQueryRequestSchema;
    output: typeof CheckSqlQueryResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_mgmt_v1alpha1_connection, 0);

