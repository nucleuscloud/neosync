//go:build ignore

package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

type ParamInfo struct {
	Name       string
	Type       string
	IsOptional bool
	HasDefault bool
	Default    string
}

type FuncInfo struct {
	Name        string
	Description string
	Params      []*ParamInfo
	OrderdArgs  []string
	Type        string
	SourceFile  string
}

func main() {
	fileSet := token.NewFileSet()
	transformerFuncs := []*FuncInfo{}

	err := filepath.WalkDir(".", func(path string, d fs.DirEntry, err error) error {
		if !d.IsDir() && filepath.Ext(path) == ".go" {
			fmt.Println(path)
			node, err := parser.ParseFile(fileSet, path, nil, parser.ParseComments)
			if err != nil {
				log.Printf("Failed to parse file %s: %v", path, err)
				return nil
			}
			for _, cgroup := range node.Comments {
				for _, comment := range cgroup.List {
					if strings.HasPrefix(comment.Text, "// +javascriptFncBuilder:") {
						parts := strings.Split(comment.Text, ":")
						if len(parts) < 3 {
							continue
						}
						transformerFuncs = append(transformerFuncs, &FuncInfo{
							SourceFile: path,
							Name:       parts[2],
							Type:       parts[1],
						})

					}
				}
			}
		}
		return nil
	})
	if err != nil {
		log.Fatalf("impossible to walk directories: %s", err)
	}

	// bloblang.NewPluginSpec().
	// 	Param(bloblang.NewInt64Param("max_length").Default(10000)).
	// 	Param(bloblang.NewAnyParam("value").Optional()).
	// 	Param(bloblang.NewBoolParam("preserve_length").Default(false)).
	// 	Param(bloblang.NewInt64Param("seed").Optional())
	for _, tf := range transformerFuncs {
		readFile, err := os.Open(tf.SourceFile)

		if err != nil {
			fmt.Println(err)
		}
		fileScanner := bufio.NewScanner(readFile)
		fileScanner.Split(bufio.ScanLines)

    foundFunc := false
		for fileScanner.Scan() {
			line := fileScanner.Text()
			line = strings.TrimSpace(line)
      // parse bloblang spec
			if strings.HasPrefix(line, "Param(bloblang.") {
				splitLine := strings.Split(line, ".")
				fmt.Println("-------")
				param := &ParamInfo{}
				for _, piece := range splitLine {
					piece = strings.TrimSpace(piece)
					if strings.TrimSpace(piece) == "Param(bloblang" {
						continue
					}
					regex := regexp.MustCompile(`New(\w+)Param`)
					// Find the substring that matches the pattern
					matches := regex.FindStringSubmatch(piece)

					if len(matches) > 1 {
						// matches[1] contains the characters between "New" and "Param"
						param.Type = matches[1]
						regex := regexp.MustCompile(`"([^"]*)"`)

						// Find all substrings that match the pattern
						matches := regex.FindStringSubmatch(piece)
						if len(matches) > 1 {
							param.Name = matches[1]
						}
					}

					if strings.HasPrefix(piece, "Optional()") {
						param.IsOptional = true
					}
					if strings.HasPrefix(piece, "Default") {
						regex := regexp.MustCompile(`\(([^)]*)\)`)
						matches := regex.FindStringSubmatch(piece)
						fmt.Println(matches)
						param.HasDefault = true
						if len(matches) > 1 {
							param.Default = matches[1]
						}
					}
					fmt.Println(piece)

				}
				tf.Params = append(tf.Params, param)
			}

			// get function argument info
      // function definition on single line
			if strings.HasPrefix(line, fmt.Sprintf("func %s(", tf.Name)) && strings.HasSuffix(line, "error) {") {
        strings.


			}

      // function definition on mulitiple lines

		}

		jsonF, _ := json.MarshalIndent(transformerFuncs, "", " ")
		fmt.Printf("%s \n", string(jsonF))

		readFile.Close()
	}

}

const generateFunctionTemplate = `
// Code generated by Neosync goja_func_generator.go. DO NOT EDIT.
// source: {{ .SourceFile }}

package {{ .PackageName }}
var _ = registerVMRunnerFunction("{{.Name}}", ` + "" + `).
	Namespace({{ .Namespace }}).
	Param("opts", "object", "options config").
	FnCtor(func(r *vmRunner) jsFunction {
		return func(call goja.FunctionCall, rt *goja.Runtime, l *service.Logger) (interface{}, error) {
			var (
				opts map[string]interface{}
			)
			if err := parseArgs(call, &opts); err != nil {
				return "", err
			}
			var seed int64
			if opts != nil && opts["seed"] != nil {
				seed = opts["seed"].(int64)
			} else {
				var err error
				seed, err = transformer_utils.GenerateCryptoSeed()
				if err != nil {
					return nil, err
				}
			}
			{{range .Params}}
			{{if .HasDefault}}
      {{.Name}} := {{.Default}}
      if opts != nil && opts["{{.Name}}"] != nil {
				{{.Name}} = opts["{{.Name}}"].({{.Type}})
			}
			{{end}}
			{{end}}
			randomizer := rng.New(seed)
			return transformer.{{.Name}}(randomizer, name, preserveLength, maxLength)
		}
	})
`

const transformerFunctionTemplate = `
// Code generated by Neosync goja_func_generator.go. DO NOT EDIT.
// source: {{ .SourceFile }}

package {{ .PackageName }}
var _ = registerVMRunnerFunction("{{.Name}}", ` + "" + `).
	Namespace({{ .Namespace }}).
	Param("value", "any", "").
	Param("opts", "object", "options config").
	FnCtor(func(r *vmRunner) jsFunction {
		return func(call goja.FunctionCall, rt *goja.Runtime, l *service.Logger) (interface{}, error) {
			var (
        value {{.ValueType}}
				opts map[string]interface{}
			)
			if err := parseArgs(call, &opts); err != nil {
				return "", err
			}
			var seed int64
			if opts != nil && opts["seed"] != nil {
				seed = opts["seed"].(int64)
			} else {
				var err error
				seed, err = transformer_utils.GenerateCryptoSeed()
				if err != nil {
					return nil, err
				}
			}

			{{range $index, $param := .FunctInfo.Params}}
      {{if eq $param.Name "value"}}
        {{continue}}
      {{end}}
			{{if $param.HasDefault}}
      {{$param.Name}} := {{$param.Default}}
      if opts != nil && opts["{{$param.Name}}"] != nil {
				{{$param.Name}} = opts["{{$param.Name}}"].({{$param.Type}})
			}
      {{else if $param.IsOptional}}
      var {{$param.Name}} {{$param.Type}}
      if opts != nil && opts["{{$param.Name}}"] != nil {
				{{$param.Name}} = opts["{{$param.Name}}"].({{$param.Type}})
			}
      {{else}}
      if _, ok := opts["{{$param.Name}}"]; !ok {
        return nil, fmt.Errorf("missing required argument. function: %s argument: %s", {{.FunctInfo.Name}}, {{$param.Name}})
      } 
      {{$param.Name}} := opts["{{$param.Name}}"] 
			{{end}}
      
			{{end}}
			randomizer := rng.New(seed)
			return transformer.{{.FunctInfo.Name}}(randomizer, value, preserveLength, maxLength)
		}
	})
`

type TemplateData struct {
	SourceFile  string
	PackageName string
	Namespace   string
	FunctInfo   FuncInfo
	ValueType   *string
}

func formatTransformGojaFunction(pkgName, namespace string, funcInfo *FuncInfo) (string, error) {
	data := TemplateData{
		SourceFile:  funcInfo.SourceFile,
		PackageName: pkgName,
		Namespace:   namespace,
		FunctInfo:   *funcInfo,
	}
	for _, p := range funcInfo.Params {
		if p.Name == "value" {
			data.ValueType = &p.Type
		}
	}
	t := template.Must(template.New("gojaFunc").Parse(transformerFunctionTemplate))
	var out bytes.Buffer
	err := t.Execute(&out, data)
	if err != nil {
		return "", err
	}
	return out.String(), nil
}
