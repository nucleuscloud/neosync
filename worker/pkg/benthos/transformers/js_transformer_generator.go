//go:build ignore

package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

type ParamInfo struct {
	Name       string
	TypeStr    string
	IsOptional bool
	HasDefault bool
	Default    string
}

type FuncInfo struct {
	Name        string
	Description string
	Params      []*ParamInfo
	OrderdArgs  []string
	Type        string
	SourceFile  string
}

func main() {
	fileSet := token.NewFileSet()
	transformerFuncs := []*FuncInfo{}

	err := filepath.WalkDir(".", func(path string, d fs.DirEntry, err error) error {
		if !d.IsDir() && filepath.Ext(path) == ".go" {
			fmt.Println(path)
			node, err := parser.ParseFile(fileSet, path, nil, parser.ParseComments)
			if err != nil {
				log.Printf("Failed to parse file %s: %v", path, err)
				return nil
			}
			for _, cgroup := range node.Comments {
				for _, comment := range cgroup.List {
					if strings.HasPrefix(comment.Text, "// +javascriptFncBuilder:") {
						parts := strings.Split(comment.Text, ":")
						if len(parts) < 3 {
							continue
						}
						transformerFuncs = append(transformerFuncs, &FuncInfo{
							SourceFile:  path,
							Name:        parts[2],
							Type:        parts[1],
							Description: "",
						})

					}
				}
			}
		}
		return nil
	})
	if err != nil {
		log.Fatalf("impossible to walk directories: %s", err)
	}

	// bloblang.NewPluginSpec().
	// 	Param(bloblang.NewInt64Param("max_length").Default(10000)).
	// 	Param(bloblang.NewAnyParam("value").Optional()).
	// 	Param(bloblang.NewBoolParam("preserve_length").Default(false)).
	// 	Param(bloblang.NewInt64Param("seed").Optional())
	for _, tf := range transformerFuncs {
		readFile, err := os.Open(tf.SourceFile)

		if err != nil {
			fmt.Println(err)
		}
		fileScanner := bufio.NewScanner(readFile)
		fileScanner.Split(bufio.ScanLines)

		// foundFunc := false
		for fileScanner.Scan() {
			line := fileScanner.Text()
			line = strings.TrimSpace(line)
			// parse bloblang spec
			if strings.HasPrefix(line, "Param(bloblang.") {
				splitLine := strings.Split(line, ".")
				fmt.Println("-------")
				param := &ParamInfo{}
				for _, piece := range splitLine {
					piece = strings.TrimSpace(piece)
					if strings.TrimSpace(piece) == "Param(bloblang" {
						continue
					}
					regex := regexp.MustCompile(`New(\w+)Param`)
					// Find the substring that matches the pattern
					matches := regex.FindStringSubmatch(piece)

					if len(matches) > 1 {
						// matches[1] contains the characters between "New" and "Param"
						param.TypeStr = lowercaseFirst(matches[1])
						regex := regexp.MustCompile(`"([^"]*)"`)

						// Find all substrings that match the pattern
						matches := regex.FindStringSubmatch(piece)
						if len(matches) > 1 {
							param.Name = toCamelCase(matches[1])
						}
					}

					if strings.HasPrefix(piece, "Optional()") {
						param.IsOptional = true
					}
					if strings.HasPrefix(piece, "Default") {
						regex := regexp.MustCompile(`\(([^)]*)\)`)
						matches := regex.FindStringSubmatch(piece)
						fmt.Println(matches)
						param.HasDefault = true
						if len(matches) > 1 {
							param.Default = matches[1]
						}
					}

				}
				tf.Params = append(tf.Params, param)
			}

			// get function argument info
			// function definition on single line
			if strings.HasPrefix(line, fmt.Sprintf("func %s(", tf.Name)) && strings.HasSuffix(line, "error) {") {
				// strings.

			}

			// function definition on mulitiple lines

		}

		jsonF, _ := json.MarshalIndent(transformerFuncs, "", " ")
		fmt.Printf("%s \n", string(jsonF))

		readFile.Close()
	}

	for _, tf := range transformerFuncs {
		codeStr, err := formatTransformGojaFunction("transformers", tf)
		if err != nil {
			fmt.Println("Error writing to output file:", err)
			return
		}
		output := fmt.Sprintf("gen_%s", tf.SourceFile)
		outputFile, err := os.Create(output)
		if err != nil {
			fmt.Println("Error creating output file:", err)

			return
		}

		_, err = outputFile.WriteString(codeStr)
		if err != nil {
			fmt.Println("Error writing to output file:", err)
			return
		}
		outputFile.Close()
	}

}

const transformerTemplate = `
// Code generated by Neosync js_transformer_generator.go. DO NOT EDIT.
// source: {{.SourceFile}}

package {{.PackageName}}

import (
	"errors"
	"fmt"
	transformer_utils "github.com/nucleuscloud/neosync/worker/pkg/benthos/transformers/utils"
	"github.com/nucleuscloud/neosync/worker/pkg/rng"
)

type {{.StructName}} struct{}

type {{.StructName}}Opts struct {
	randomizer     rng.Rand
	{{- range $index, $param := .FunctInfo.Params }}
	{{- if eq $param.Name "value" }}{{ continue }}{{ end }}
	{{- if eq $param.Name "seed" }}{{ continue }}{{ end }}
	{{- if $param.IsOptional }}
	{{$param.Name}} *{{$param.TypeStr}}
	{{- else }}
	{{$param.Name}} {{$param.TypeStr}}
	{{- end }}
	{{- end }}
}

func New{{.StructName}}() *{{.StructName}} {
	return &{{.StructName}}{}
}

func (t *{{.StructName}}) GetJsTemplateData() (*TemplateData, error) {
	return &TemplateData{
		Name: "{{.FunctInfo.Name}}",
		Description: "{{.FunctInfo.Description}}",
	}, nil
}

func (t *{{.StructName}}) ParseOptions(opts map[string]any) (any, error) {
	transformerOpts := &{{.StructName}}Opts{}
	{{- range $index, $param := .FunctInfo.Params }}
	{{- if eq $param.Name "value" }}{{ continue }}{{ end }}

	{{- if eq $param.Name "seed" }}
	
	var seed int64
	seedArg, ok := opts["seed"].(int64)
	if ok {
		seed = seedArg
	} else {
		var err error
		seed, err = transformer_utils.GenerateCryptoSeed()
		if err != nil {
			return nil, err
		}
	}
	transformerOpts.randomizer = rng.New(seed)

	{{- continue }}
	{{ end }}
	{{- if $param.HasDefault }}

	{{$param.Name}}, ok := opts["{{$param.Name}}"].({{$param.TypeStr}})
	if !ok {
		{{$param.Name}} = {{$param.Default}}
	}

	{{- else if $param.IsOptional }}

	var {{$param.Name}} *{{$param.TypeStr}}
	if arg, ok := opts["{{$param.Name}}"].({{$param.TypeStr}}); ok {
		{{$param.Name}} = &arg
	}

	{{- else }}

	if _, ok := opts["{{$param.Name}}"].({{$param.TypeStr}}); !ok {
		return nil, fmt.Errorf("missing required argument. function: %s argument: %s", "{{.FunctInfo.Name}}", "{{$param.Name}}")
	}
	{{$param.Name}} := opts["{{$param.Name}}"].({{$param.TypeStr}})

	{{- end }}
	transformerOpts.{{$param.Name}} = {{$param.Name}}
	{{- end }}

	return transformerOpts, nil
}
`

type TemplateData struct {
	SourceFile  string
	PackageName string
	FunctInfo   FuncInfo
	StructName  string
}

func formatTransformGojaFunction(pkgName string, funcInfo *FuncInfo) (string, error) {
	data := TemplateData{
		SourceFile:  funcInfo.SourceFile,
		PackageName: pkgName,
		FunctInfo:   *funcInfo,
		StructName:  capitalizeFirst(funcInfo.Name),
	}
	t := template.Must(template.New("neosyncTransformerImpl").Parse(transformerTemplate))
	var out bytes.Buffer
	err := t.Execute(&out, data)
	if err != nil {
		return "", err
	}
	return out.String(), nil
}

func toCamelCase(snake string) string {
	var result string
	upperNext := false

	for i, char := range snake {
		if char == '_' {
			upperNext = true
		} else {
			if upperNext {
				result += strings.ToUpper(string(char))
				upperNext = false
			} else {
				if i == 0 {
					result += strings.ToLower(string(char))
				} else {
					result += string(char)
				}
			}
		}
	}

	return result
}

func capitalizeFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(string(s[0])) + s[1:]
}

func lowercaseFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(string(s[0])) + s[1:]
}
