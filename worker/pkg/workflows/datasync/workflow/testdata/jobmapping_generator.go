//go:build ignore

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"html/template"
	"io"
	"os"
	"strings"

	mgmtv1alpha1 "github.com/nucleuscloud/neosync/backend/gen/go/protos/mgmt/v1alpha1"
	pg_query "github.com/pganalyze/pg_query_go/v5"
	pgquery "github.com/wasilibs/go-pgquery"
	"github.com/xwb1989/sqlparser"
)

type Input struct {
	Folder  string `json:"folder"`
	SqlFile string `json:"sql_file"`
	Driver  string `json:"driver"`
}

type Column struct {
	Name string
}

type Table struct {
	Schema  string
	Name    string
	Columns []*Column
}

type JobMapping struct {
	Schema      string
	Table       string
	Column      string
	Transformer string
	Config      string
}

func parsePostegresStatements(sql string) ([]*Table, error) {
	tree, err := pgquery.Parse(sql)
	if err != nil {
		return nil, err
	}

	tables := []*Table{}
	var schema string
	for _, stmt := range tree.GetStmts() {
		s := stmt.GetStmt()
		switch s.Node.(type) {
		case *pg_query.Node_CreateSchemaStmt:
			schema = s.GetCreateSchemaStmt().GetSchemaname()
		case *pg_query.Node_CreateStmt:
			table := s.GetCreateStmt().GetRelation().GetRelname()
			columns := []*Column{}
			for _, col := range s.GetCreateStmt().GetTableElts() {
				if col.GetColumnDef() != nil {
					columns = append(columns, &Column{
						Name: col.GetColumnDef().Colname,
					})
				}
			}
			tables = append(tables, &Table{
				Schema:  schema,
				Name:    table,
				Columns: columns,
			})
		}
	}
	if schema == "" {
		return nil, fmt.Errorf("unable to determine schema")
	}
	return tables, nil
}

// todo parser breaks when there are foreign key constraints defined in the create table statements
// work around for now is to use alter table statements to add foreign key constraints to tables
func parseMysqlStatements(sql string) ([]*Table, error) {
	var tables []*Table
	var currentSchema string

	r := strings.NewReader(sql)

	tokens := sqlparser.NewTokenizer(r)
	for {
		parsedStmt, err := sqlparser.ParseNext(tokens)
		if err == io.EOF {
			break
		}
		switch stmt := parsedStmt.(type) {
		case *sqlparser.DBDDL:
			currentSchema = stmt.DBName
		case *sqlparser.DDL:
			switch stmt.Action {
			case sqlparser.CreateStr:
				if stmt.TableSpec != nil {
					s := stmt.NewName.Qualifier.String()
					if s == "" {
						s = currentSchema
					}
					table := &Table{
						Schema: s,
						Name:   stmt.NewName.Name.String(),
					}
					for _, col := range stmt.TableSpec.Columns {
						column := &Column{
							Name: col.Name.String(),
						}
						table.Columns = append(table.Columns, column)
					}
					tables = append(tables, table)
				}
			}
		case *sqlparser.Use:
			currentSchema = stmt.DBName.String()
		}
	}
	return tables, nil
}

func generateJobMapping(tables []*Table) []*mgmtv1alpha1.JobMapping {
	mappings := []*mgmtv1alpha1.JobMapping{}
	for _, t := range tables {
		for _, c := range t.Columns {
			mappings = append(mappings, &mgmtv1alpha1.JobMapping{
				Schema: t.Schema,
				Table:  t.Name,
				Column: c.Name,
				Transformer: &mgmtv1alpha1.JobMappingTransformer{
					Source: mgmtv1alpha1.TransformerSource_TRANSFORMER_SOURCE_PASSTHROUGH,
				},
			})

		}
	}
	return mappings
}

type TemplateData struct {
	SourceFile  string
	PackageName string
	Mappings    []*mgmtv1alpha1.JobMapping
}

func formatJobMappings(pkgName string, sqlFile string, mappings []*mgmtv1alpha1.JobMapping) (string, error) {
	const tmpl = `
// Code generated by Neosync jobmapping_generator. DO NOT EDIT.
// source: {{ .SourceFile }}

package {{ .PackageName }}

import (
	mgmtv1alpha1 "github.com/nucleuscloud/neosync/backend/gen/go/protos/mgmt/v1alpha1"
)

func GetDefaultSyncJobMappings()[]*mgmtv1alpha1.JobMapping {
  return []*mgmtv1alpha1.JobMapping{
		{{- range .Mappings }}
		{
			Schema: "{{ .Schema }}",
			Table:  "{{ .Table }}",
			Column: "{{ .Column }}",
			Transformer: &mgmtv1alpha1.JobMappingTransformer{
				Source: mgmtv1alpha1.TransformerSource_TRANSFORMER_SOURCE_PASSTHROUGH,
			},
		},
		{{- end }}
	} 
}

`
	data := TemplateData{
		SourceFile:  sqlFile,
		PackageName: pkgName,
		Mappings:    mappings,
	}
	t := template.Must(template.New("jobmappings").Parse(tmpl))
	var out bytes.Buffer
	err := t.Execute(&out, data)
	if err != nil {
		return "", err
	}
	return out.String(), nil
}

func main() {
	args := os.Args
	if len(args) < 3 {
		panic("must provide necessary args")
	}

	configFile := args[1]
	gopackage := args[2]

	packageSplit := strings.Split(gopackage, "_")
	goPkg := packageSplit[len(packageSplit)-1]

	jsonFile, err := os.Open(configFile)
	if err != nil {
		fmt.Println("failed to open file: %s", err)
		return
	}
	defer jsonFile.Close()

	byteValue, err := io.ReadAll(jsonFile)
	if err != nil {
		fmt.Println("failed to read file: %s", err)
		return
	}

	var inputs []Input
	if err := json.Unmarshal(byteValue, &inputs); err != nil {
		fmt.Println("failed to unmarshal JSON: %s", err)
		return
	}
	for _, input := range inputs {
		folderSplit := strings.Split(input.Folder, "/")
		var goPkgName string
		if len(folderSplit) == 1 {
			goPkgName = strings.ReplaceAll(fmt.Sprintf("%s_%s", goPkg, input.Folder), "-", "")
		} else if len(folderSplit) > 1 {
			lastTwo := folderSplit[len(folderSplit)-2:]
			goPkgName = strings.ReplaceAll(strings.Join(lastTwo, "_"), "-", "")
		}
		sqlFile, err := os.Open(fmt.Sprintf("%s/%s", input.Folder, input.SqlFile))
		if err != nil {
			fmt.Println("failed to open file: %s", err)
		}

		byteValue, err := io.ReadAll(sqlFile)
		if err != nil {
			fmt.Println("failed to read file: %s", err)
		}

		sqlContent := string(byteValue)
		sqlFile.Close()

		var tables []*Table
		if input.Driver == "postgres" {
			t, err := parsePostegresStatements(sqlContent)
			if err != nil {
				fmt.Println("Error parsing postgres SQL schema:", err)
				return
			}
			tables = t
		} else if input.Driver == "mysql" {
			t, err := parseMysqlStatements(sqlContent)
			if err != nil {
				fmt.Println("Error parsing mysql SQL schema:", err)
				return
			}
			tables = t
		}

		jobMapping := generateJobMapping(tables)

		formattedJobMappings, err := formatJobMappings(goPkgName, input.SqlFile, jobMapping)
		if err != nil {
			fmt.Println("Error formatting job mappings:", err)
			return
		}

		output := fmt.Sprintf("%s/job_mappings.go", input.Folder)
		outputFile, err := os.Create(output)
		if err != nil {
			fmt.Println("Error creating jobmapping.go file:", err)
			return
		}

		_, err = outputFile.WriteString(formattedJobMappings)
		if err != nil {
			fmt.Println("Error writing to jobmapping.go file:", err)
			return
		}
		outputFile.Close()
	}

	return
}
