// Code generated by mockery. DO NOT EDIT.

package clientmanager

import (
	context "context"

	client "go.temporal.io/sdk/client"

	mock "github.com/stretchr/testify/mock"

	slog "log/slog"

	workflow "go.temporal.io/api/workflow/v1"

	workflowservice "go.temporal.io/api/workflowservice/v1"
)

// MockInterface is an autogenerated mock type for the Interface type
type MockInterface struct {
	mock.Mock
}

type MockInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockInterface) EXPECT() *MockInterface_Expecter {
	return &MockInterface_Expecter{mock: &_m.Mock}
}

// CancelWorkflow provides a mock function with given fields: ctx, accountId, workflowId, logger
func (_m *MockInterface) CancelWorkflow(ctx context.Context, accountId string, workflowId string, logger *slog.Logger) error {
	ret := _m.Called(ctx, accountId, workflowId, logger)

	if len(ret) == 0 {
		panic("no return value specified for CancelWorkflow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) error); ok {
		r0 = rf(ctx, accountId, workflowId, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_CancelWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelWorkflow'
type MockInterface_CancelWorkflow_Call struct {
	*mock.Call
}

// CancelWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - workflowId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) CancelWorkflow(ctx interface{}, accountId interface{}, workflowId interface{}, logger interface{}) *MockInterface_CancelWorkflow_Call {
	return &MockInterface_CancelWorkflow_Call{Call: _e.mock.On("CancelWorkflow", ctx, accountId, workflowId, logger)}
}

func (_c *MockInterface_CancelWorkflow_Call) Run(run func(ctx context.Context, accountId string, workflowId string, logger *slog.Logger)) *MockInterface_CancelWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_CancelWorkflow_Call) Return(_a0 error) *MockInterface_CancelWorkflow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_CancelWorkflow_Call) RunAndReturn(run func(context.Context, string, string, *slog.Logger) error) *MockInterface_CancelWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSchedule provides a mock function with given fields: ctx, accountId, opts, logger
func (_m *MockInterface) CreateSchedule(ctx context.Context, accountId string, opts *client.ScheduleOptions, logger *slog.Logger) (string, error) {
	ret := _m.Called(ctx, accountId, opts, logger)

	if len(ret) == 0 {
		panic("no return value specified for CreateSchedule")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *client.ScheduleOptions, *slog.Logger) (string, error)); ok {
		return rf(ctx, accountId, opts, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *client.ScheduleOptions, *slog.Logger) string); ok {
		r0 = rf(ctx, accountId, opts, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *client.ScheduleOptions, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, opts, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_CreateSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSchedule'
type MockInterface_CreateSchedule_Call struct {
	*mock.Call
}

// CreateSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - opts *client.ScheduleOptions
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) CreateSchedule(ctx interface{}, accountId interface{}, opts interface{}, logger interface{}) *MockInterface_CreateSchedule_Call {
	return &MockInterface_CreateSchedule_Call{Call: _e.mock.On("CreateSchedule", ctx, accountId, opts, logger)}
}

func (_c *MockInterface_CreateSchedule_Call) Run(run func(ctx context.Context, accountId string, opts *client.ScheduleOptions, logger *slog.Logger)) *MockInterface_CreateSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*client.ScheduleOptions), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_CreateSchedule_Call) Return(_a0 string, _a1 error) *MockInterface_CreateSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_CreateSchedule_Call) RunAndReturn(run func(context.Context, string, *client.ScheduleOptions, *slog.Logger) (string, error)) *MockInterface_CreateSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSchedule provides a mock function with given fields: ctx, accountId, scheduleId, logger
func (_m *MockInterface) DeleteSchedule(ctx context.Context, accountId string, scheduleId string, logger *slog.Logger) error {
	ret := _m.Called(ctx, accountId, scheduleId, logger)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSchedule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) error); ok {
		r0 = rf(ctx, accountId, scheduleId, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_DeleteSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSchedule'
type MockInterface_DeleteSchedule_Call struct {
	*mock.Call
}

// DeleteSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - scheduleId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) DeleteSchedule(ctx interface{}, accountId interface{}, scheduleId interface{}, logger interface{}) *MockInterface_DeleteSchedule_Call {
	return &MockInterface_DeleteSchedule_Call{Call: _e.mock.On("DeleteSchedule", ctx, accountId, scheduleId, logger)}
}

func (_c *MockInterface_DeleteSchedule_Call) Run(run func(ctx context.Context, accountId string, scheduleId string, logger *slog.Logger)) *MockInterface_DeleteSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_DeleteSchedule_Call) Return(_a0 error) *MockInterface_DeleteSchedule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_DeleteSchedule_Call) RunAndReturn(run func(context.Context, string, string, *slog.Logger) error) *MockInterface_DeleteSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteWorkflowExecution provides a mock function with given fields: ctx, accountId, workflowId, logger
func (_m *MockInterface) DeleteWorkflowExecution(ctx context.Context, accountId string, workflowId string, logger *slog.Logger) error {
	ret := _m.Called(ctx, accountId, workflowId, logger)

	if len(ret) == 0 {
		panic("no return value specified for DeleteWorkflowExecution")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) error); ok {
		r0 = rf(ctx, accountId, workflowId, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_DeleteWorkflowExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteWorkflowExecution'
type MockInterface_DeleteWorkflowExecution_Call struct {
	*mock.Call
}

// DeleteWorkflowExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - workflowId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) DeleteWorkflowExecution(ctx interface{}, accountId interface{}, workflowId interface{}, logger interface{}) *MockInterface_DeleteWorkflowExecution_Call {
	return &MockInterface_DeleteWorkflowExecution_Call{Call: _e.mock.On("DeleteWorkflowExecution", ctx, accountId, workflowId, logger)}
}

func (_c *MockInterface_DeleteWorkflowExecution_Call) Run(run func(ctx context.Context, accountId string, workflowId string, logger *slog.Logger)) *MockInterface_DeleteWorkflowExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_DeleteWorkflowExecution_Call) Return(_a0 error) *MockInterface_DeleteWorkflowExecution_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_DeleteWorkflowExecution_Call) RunAndReturn(run func(context.Context, string, string, *slog.Logger) error) *MockInterface_DeleteWorkflowExecution_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSchedule provides a mock function with given fields: ctx, accountId, scheduleId, logger
func (_m *MockInterface) DescribeSchedule(ctx context.Context, accountId string, scheduleId string, logger *slog.Logger) (*client.ScheduleDescription, error) {
	ret := _m.Called(ctx, accountId, scheduleId, logger)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSchedule")
	}

	var r0 *client.ScheduleDescription
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) (*client.ScheduleDescription, error)); ok {
		return rf(ctx, accountId, scheduleId, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) *client.ScheduleDescription); ok {
		r0 = rf(ctx, accountId, scheduleId, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*client.ScheduleDescription)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, scheduleId, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DescribeSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSchedule'
type MockInterface_DescribeSchedule_Call struct {
	*mock.Call
}

// DescribeSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - scheduleId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) DescribeSchedule(ctx interface{}, accountId interface{}, scheduleId interface{}, logger interface{}) *MockInterface_DescribeSchedule_Call {
	return &MockInterface_DescribeSchedule_Call{Call: _e.mock.On("DescribeSchedule", ctx, accountId, scheduleId, logger)}
}

func (_c *MockInterface_DescribeSchedule_Call) Run(run func(ctx context.Context, accountId string, scheduleId string, logger *slog.Logger)) *MockInterface_DescribeSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_DescribeSchedule_Call) Return(_a0 *client.ScheduleDescription, _a1 error) *MockInterface_DescribeSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DescribeSchedule_Call) RunAndReturn(run func(context.Context, string, string, *slog.Logger) (*client.ScheduleDescription, error)) *MockInterface_DescribeSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeSchedules provides a mock function with given fields: ctx, accountId, scheduleIds, logger
func (_m *MockInterface) DescribeSchedules(ctx context.Context, accountId string, scheduleIds []string, logger *slog.Logger) ([]*DescribeSchedulesResponse, error) {
	ret := _m.Called(ctx, accountId, scheduleIds, logger)

	if len(ret) == 0 {
		panic("no return value specified for DescribeSchedules")
	}

	var r0 []*DescribeSchedulesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, *slog.Logger) ([]*DescribeSchedulesResponse, error)); ok {
		return rf(ctx, accountId, scheduleIds, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, *slog.Logger) []*DescribeSchedulesResponse); ok {
		r0 = rf(ctx, accountId, scheduleIds, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*DescribeSchedulesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, scheduleIds, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DescribeSchedules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeSchedules'
type MockInterface_DescribeSchedules_Call struct {
	*mock.Call
}

// DescribeSchedules is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - scheduleIds []string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) DescribeSchedules(ctx interface{}, accountId interface{}, scheduleIds interface{}, logger interface{}) *MockInterface_DescribeSchedules_Call {
	return &MockInterface_DescribeSchedules_Call{Call: _e.mock.On("DescribeSchedules", ctx, accountId, scheduleIds, logger)}
}

func (_c *MockInterface_DescribeSchedules_Call) Run(run func(ctx context.Context, accountId string, scheduleIds []string, logger *slog.Logger)) *MockInterface_DescribeSchedules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_DescribeSchedules_Call) Return(_a0 []*DescribeSchedulesResponse, _a1 error) *MockInterface_DescribeSchedules_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DescribeSchedules_Call) RunAndReturn(run func(context.Context, string, []string, *slog.Logger) ([]*DescribeSchedulesResponse, error)) *MockInterface_DescribeSchedules_Call {
	_c.Call.Return(run)
	return _c
}

// DescribeWorklowExecution provides a mock function with given fields: ctx, accountId, workflowId, logger
func (_m *MockInterface) DescribeWorklowExecution(ctx context.Context, accountId string, workflowId string, logger *slog.Logger) (*workflowservice.DescribeWorkflowExecutionResponse, error) {
	ret := _m.Called(ctx, accountId, workflowId, logger)

	if len(ret) == 0 {
		panic("no return value specified for DescribeWorklowExecution")
	}

	var r0 *workflowservice.DescribeWorkflowExecutionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) (*workflowservice.DescribeWorkflowExecutionResponse, error)); ok {
		return rf(ctx, accountId, workflowId, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) *workflowservice.DescribeWorkflowExecutionResponse); ok {
		r0 = rf(ctx, accountId, workflowId, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflowservice.DescribeWorkflowExecutionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, workflowId, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DescribeWorklowExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DescribeWorklowExecution'
type MockInterface_DescribeWorklowExecution_Call struct {
	*mock.Call
}

// DescribeWorklowExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - workflowId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) DescribeWorklowExecution(ctx interface{}, accountId interface{}, workflowId interface{}, logger interface{}) *MockInterface_DescribeWorklowExecution_Call {
	return &MockInterface_DescribeWorklowExecution_Call{Call: _e.mock.On("DescribeWorklowExecution", ctx, accountId, workflowId, logger)}
}

func (_c *MockInterface_DescribeWorklowExecution_Call) Run(run func(ctx context.Context, accountId string, workflowId string, logger *slog.Logger)) *MockInterface_DescribeWorklowExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_DescribeWorklowExecution_Call) Return(_a0 *workflowservice.DescribeWorkflowExecutionResponse, _a1 error) *MockInterface_DescribeWorklowExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DescribeWorklowExecution_Call) RunAndReturn(run func(context.Context, string, string, *slog.Logger) (*workflowservice.DescribeWorkflowExecutionResponse, error)) *MockInterface_DescribeWorklowExecution_Call {
	_c.Call.Return(run)
	return _c
}

// DoesAccountHaveNamespace provides a mock function with given fields: ctx, accountId, logger
func (_m *MockInterface) DoesAccountHaveNamespace(ctx context.Context, accountId string, logger *slog.Logger) (bool, error) {
	ret := _m.Called(ctx, accountId, logger)

	if len(ret) == 0 {
		panic("no return value specified for DoesAccountHaveNamespace")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slog.Logger) (bool, error)); ok {
		return rf(ctx, accountId, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slog.Logger) bool); ok {
		r0 = rf(ctx, accountId, logger)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_DoesAccountHaveNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DoesAccountHaveNamespace'
type MockInterface_DoesAccountHaveNamespace_Call struct {
	*mock.Call
}

// DoesAccountHaveNamespace is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) DoesAccountHaveNamespace(ctx interface{}, accountId interface{}, logger interface{}) *MockInterface_DoesAccountHaveNamespace_Call {
	return &MockInterface_DoesAccountHaveNamespace_Call{Call: _e.mock.On("DoesAccountHaveNamespace", ctx, accountId, logger)}
}

func (_c *MockInterface_DoesAccountHaveNamespace_Call) Run(run func(ctx context.Context, accountId string, logger *slog.Logger)) *MockInterface_DoesAccountHaveNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_DoesAccountHaveNamespace_Call) Return(_a0 bool, _a1 error) *MockInterface_DoesAccountHaveNamespace_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_DoesAccountHaveNamespace_Call) RunAndReturn(run func(context.Context, string, *slog.Logger) (bool, error)) *MockInterface_DoesAccountHaveNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// GetSyncJobTaskQueue provides a mock function with given fields: ctx, accountId, logger
func (_m *MockInterface) GetSyncJobTaskQueue(ctx context.Context, accountId string, logger *slog.Logger) (string, error) {
	ret := _m.Called(ctx, accountId, logger)

	if len(ret) == 0 {
		panic("no return value specified for GetSyncJobTaskQueue")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slog.Logger) (string, error)); ok {
		return rf(ctx, accountId, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slog.Logger) string); ok {
		r0 = rf(ctx, accountId, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_GetSyncJobTaskQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSyncJobTaskQueue'
type MockInterface_GetSyncJobTaskQueue_Call struct {
	*mock.Call
}

// GetSyncJobTaskQueue is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) GetSyncJobTaskQueue(ctx interface{}, accountId interface{}, logger interface{}) *MockInterface_GetSyncJobTaskQueue_Call {
	return &MockInterface_GetSyncJobTaskQueue_Call{Call: _e.mock.On("GetSyncJobTaskQueue", ctx, accountId, logger)}
}

func (_c *MockInterface_GetSyncJobTaskQueue_Call) Run(run func(ctx context.Context, accountId string, logger *slog.Logger)) *MockInterface_GetSyncJobTaskQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_GetSyncJobTaskQueue_Call) Return(_a0 string, _a1 error) *MockInterface_GetSyncJobTaskQueue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_GetSyncJobTaskQueue_Call) RunAndReturn(run func(context.Context, string, *slog.Logger) (string, error)) *MockInterface_GetSyncJobTaskQueue_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowExecutionById provides a mock function with given fields: ctx, accountId, workflowId, logger
func (_m *MockInterface) GetWorkflowExecutionById(ctx context.Context, accountId string, workflowId string, logger *slog.Logger) (*workflow.WorkflowExecutionInfo, error) {
	ret := _m.Called(ctx, accountId, workflowId, logger)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowExecutionById")
	}

	var r0 *workflow.WorkflowExecutionInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) (*workflow.WorkflowExecutionInfo, error)); ok {
		return rf(ctx, accountId, workflowId, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) *workflow.WorkflowExecutionInfo); ok {
		r0 = rf(ctx, accountId, workflowId, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*workflow.WorkflowExecutionInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, workflowId, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_GetWorkflowExecutionById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowExecutionById'
type MockInterface_GetWorkflowExecutionById_Call struct {
	*mock.Call
}

// GetWorkflowExecutionById is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - workflowId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) GetWorkflowExecutionById(ctx interface{}, accountId interface{}, workflowId interface{}, logger interface{}) *MockInterface_GetWorkflowExecutionById_Call {
	return &MockInterface_GetWorkflowExecutionById_Call{Call: _e.mock.On("GetWorkflowExecutionById", ctx, accountId, workflowId, logger)}
}

func (_c *MockInterface_GetWorkflowExecutionById_Call) Run(run func(ctx context.Context, accountId string, workflowId string, logger *slog.Logger)) *MockInterface_GetWorkflowExecutionById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_GetWorkflowExecutionById_Call) Return(_a0 *workflow.WorkflowExecutionInfo, _a1 error) *MockInterface_GetWorkflowExecutionById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_GetWorkflowExecutionById_Call) RunAndReturn(run func(context.Context, string, string, *slog.Logger) (*workflow.WorkflowExecutionInfo, error)) *MockInterface_GetWorkflowExecutionById_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowExecutionsByScheduleIds provides a mock function with given fields: ctx, accountId, scheduleIds, logger
func (_m *MockInterface) GetWorkflowExecutionsByScheduleIds(ctx context.Context, accountId string, scheduleIds []string, logger *slog.Logger) ([]*workflow.WorkflowExecutionInfo, error) {
	ret := _m.Called(ctx, accountId, scheduleIds, logger)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowExecutionsByScheduleIds")
	}

	var r0 []*workflow.WorkflowExecutionInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, *slog.Logger) ([]*workflow.WorkflowExecutionInfo, error)); ok {
		return rf(ctx, accountId, scheduleIds, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, *slog.Logger) []*workflow.WorkflowExecutionInfo); ok {
		r0 = rf(ctx, accountId, scheduleIds, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*workflow.WorkflowExecutionInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, scheduleIds, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_GetWorkflowExecutionsByScheduleIds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowExecutionsByScheduleIds'
type MockInterface_GetWorkflowExecutionsByScheduleIds_Call struct {
	*mock.Call
}

// GetWorkflowExecutionsByScheduleIds is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - scheduleIds []string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) GetWorkflowExecutionsByScheduleIds(ctx interface{}, accountId interface{}, scheduleIds interface{}, logger interface{}) *MockInterface_GetWorkflowExecutionsByScheduleIds_Call {
	return &MockInterface_GetWorkflowExecutionsByScheduleIds_Call{Call: _e.mock.On("GetWorkflowExecutionsByScheduleIds", ctx, accountId, scheduleIds, logger)}
}

func (_c *MockInterface_GetWorkflowExecutionsByScheduleIds_Call) Run(run func(ctx context.Context, accountId string, scheduleIds []string, logger *slog.Logger)) *MockInterface_GetWorkflowExecutionsByScheduleIds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].([]string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_GetWorkflowExecutionsByScheduleIds_Call) Return(_a0 []*workflow.WorkflowExecutionInfo, _a1 error) *MockInterface_GetWorkflowExecutionsByScheduleIds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_GetWorkflowExecutionsByScheduleIds_Call) RunAndReturn(run func(context.Context, string, []string, *slog.Logger) ([]*workflow.WorkflowExecutionInfo, error)) *MockInterface_GetWorkflowExecutionsByScheduleIds_Call {
	_c.Call.Return(run)
	return _c
}

// GetWorkflowHistory provides a mock function with given fields: ctx, accountId, workflowId, logger
func (_m *MockInterface) GetWorkflowHistory(ctx context.Context, accountId string, workflowId string, logger *slog.Logger) (client.HistoryEventIterator, error) {
	ret := _m.Called(ctx, accountId, workflowId, logger)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowHistory")
	}

	var r0 client.HistoryEventIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) (client.HistoryEventIterator, error)); ok {
		return rf(ctx, accountId, workflowId, logger)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) client.HistoryEventIterator); ok {
		r0 = rf(ctx, accountId, workflowId, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.HistoryEventIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *slog.Logger) error); ok {
		r1 = rf(ctx, accountId, workflowId, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_GetWorkflowHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWorkflowHistory'
type MockInterface_GetWorkflowHistory_Call struct {
	*mock.Call
}

// GetWorkflowHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - workflowId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) GetWorkflowHistory(ctx interface{}, accountId interface{}, workflowId interface{}, logger interface{}) *MockInterface_GetWorkflowHistory_Call {
	return &MockInterface_GetWorkflowHistory_Call{Call: _e.mock.On("GetWorkflowHistory", ctx, accountId, workflowId, logger)}
}

func (_c *MockInterface_GetWorkflowHistory_Call) Run(run func(ctx context.Context, accountId string, workflowId string, logger *slog.Logger)) *MockInterface_GetWorkflowHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_GetWorkflowHistory_Call) Return(_a0 client.HistoryEventIterator, _a1 error) *MockInterface_GetWorkflowHistory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_GetWorkflowHistory_Call) RunAndReturn(run func(context.Context, string, string, *slog.Logger) (client.HistoryEventIterator, error)) *MockInterface_GetWorkflowHistory_Call {
	_c.Call.Return(run)
	return _c
}

// PauseSchedule provides a mock function with given fields: ctx, accountId, scheduleId, opts, logger
func (_m *MockInterface) PauseSchedule(ctx context.Context, accountId string, scheduleId string, opts *client.SchedulePauseOptions, logger *slog.Logger) error {
	ret := _m.Called(ctx, accountId, scheduleId, opts, logger)

	if len(ret) == 0 {
		panic("no return value specified for PauseSchedule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *client.SchedulePauseOptions, *slog.Logger) error); ok {
		r0 = rf(ctx, accountId, scheduleId, opts, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_PauseSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PauseSchedule'
type MockInterface_PauseSchedule_Call struct {
	*mock.Call
}

// PauseSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - scheduleId string
//   - opts *client.SchedulePauseOptions
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) PauseSchedule(ctx interface{}, accountId interface{}, scheduleId interface{}, opts interface{}, logger interface{}) *MockInterface_PauseSchedule_Call {
	return &MockInterface_PauseSchedule_Call{Call: _e.mock.On("PauseSchedule", ctx, accountId, scheduleId, opts, logger)}
}

func (_c *MockInterface_PauseSchedule_Call) Run(run func(ctx context.Context, accountId string, scheduleId string, opts *client.SchedulePauseOptions, logger *slog.Logger)) *MockInterface_PauseSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*client.SchedulePauseOptions), args[4].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_PauseSchedule_Call) Return(_a0 error) *MockInterface_PauseSchedule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_PauseSchedule_Call) RunAndReturn(run func(context.Context, string, string, *client.SchedulePauseOptions, *slog.Logger) error) *MockInterface_PauseSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// TerminateWorkflow provides a mock function with given fields: ctx, accountId, workflowId, logger
func (_m *MockInterface) TerminateWorkflow(ctx context.Context, accountId string, workflowId string, logger *slog.Logger) error {
	ret := _m.Called(ctx, accountId, workflowId, logger)

	if len(ret) == 0 {
		panic("no return value specified for TerminateWorkflow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slog.Logger) error); ok {
		r0 = rf(ctx, accountId, workflowId, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_TerminateWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TerminateWorkflow'
type MockInterface_TerminateWorkflow_Call struct {
	*mock.Call
}

// TerminateWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - workflowId string
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) TerminateWorkflow(ctx interface{}, accountId interface{}, workflowId interface{}, logger interface{}) *MockInterface_TerminateWorkflow_Call {
	return &MockInterface_TerminateWorkflow_Call{Call: _e.mock.On("TerminateWorkflow", ctx, accountId, workflowId, logger)}
}

func (_c *MockInterface_TerminateWorkflow_Call) Run(run func(ctx context.Context, accountId string, workflowId string, logger *slog.Logger)) *MockInterface_TerminateWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_TerminateWorkflow_Call) Return(_a0 error) *MockInterface_TerminateWorkflow_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_TerminateWorkflow_Call) RunAndReturn(run func(context.Context, string, string, *slog.Logger) error) *MockInterface_TerminateWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// TriggerSchedule provides a mock function with given fields: ctx, accountId, scheduleId, opts, logger
func (_m *MockInterface) TriggerSchedule(ctx context.Context, accountId string, scheduleId string, opts *client.ScheduleTriggerOptions, logger *slog.Logger) error {
	ret := _m.Called(ctx, accountId, scheduleId, opts, logger)

	if len(ret) == 0 {
		panic("no return value specified for TriggerSchedule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *client.ScheduleTriggerOptions, *slog.Logger) error); ok {
		r0 = rf(ctx, accountId, scheduleId, opts, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_TriggerSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TriggerSchedule'
type MockInterface_TriggerSchedule_Call struct {
	*mock.Call
}

// TriggerSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - scheduleId string
//   - opts *client.ScheduleTriggerOptions
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) TriggerSchedule(ctx interface{}, accountId interface{}, scheduleId interface{}, opts interface{}, logger interface{}) *MockInterface_TriggerSchedule_Call {
	return &MockInterface_TriggerSchedule_Call{Call: _e.mock.On("TriggerSchedule", ctx, accountId, scheduleId, opts, logger)}
}

func (_c *MockInterface_TriggerSchedule_Call) Run(run func(ctx context.Context, accountId string, scheduleId string, opts *client.ScheduleTriggerOptions, logger *slog.Logger)) *MockInterface_TriggerSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*client.ScheduleTriggerOptions), args[4].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_TriggerSchedule_Call) Return(_a0 error) *MockInterface_TriggerSchedule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_TriggerSchedule_Call) RunAndReturn(run func(context.Context, string, string, *client.ScheduleTriggerOptions, *slog.Logger) error) *MockInterface_TriggerSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// UnpauseSchedule provides a mock function with given fields: ctx, accountId, scheduleId, opts, logger
func (_m *MockInterface) UnpauseSchedule(ctx context.Context, accountId string, scheduleId string, opts *client.ScheduleUnpauseOptions, logger *slog.Logger) error {
	ret := _m.Called(ctx, accountId, scheduleId, opts, logger)

	if len(ret) == 0 {
		panic("no return value specified for UnpauseSchedule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *client.ScheduleUnpauseOptions, *slog.Logger) error); ok {
		r0 = rf(ctx, accountId, scheduleId, opts, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_UnpauseSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnpauseSchedule'
type MockInterface_UnpauseSchedule_Call struct {
	*mock.Call
}

// UnpauseSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - scheduleId string
//   - opts *client.ScheduleUnpauseOptions
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) UnpauseSchedule(ctx interface{}, accountId interface{}, scheduleId interface{}, opts interface{}, logger interface{}) *MockInterface_UnpauseSchedule_Call {
	return &MockInterface_UnpauseSchedule_Call{Call: _e.mock.On("UnpauseSchedule", ctx, accountId, scheduleId, opts, logger)}
}

func (_c *MockInterface_UnpauseSchedule_Call) Run(run func(ctx context.Context, accountId string, scheduleId string, opts *client.ScheduleUnpauseOptions, logger *slog.Logger)) *MockInterface_UnpauseSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*client.ScheduleUnpauseOptions), args[4].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_UnpauseSchedule_Call) Return(_a0 error) *MockInterface_UnpauseSchedule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_UnpauseSchedule_Call) RunAndReturn(run func(context.Context, string, string, *client.ScheduleUnpauseOptions, *slog.Logger) error) *MockInterface_UnpauseSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSchedule provides a mock function with given fields: ctx, accountId, scheduleId, opts, logger
func (_m *MockInterface) UpdateSchedule(ctx context.Context, accountId string, scheduleId string, opts *client.ScheduleUpdateOptions, logger *slog.Logger) error {
	ret := _m.Called(ctx, accountId, scheduleId, opts, logger)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSchedule")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *client.ScheduleUpdateOptions, *slog.Logger) error); ok {
		r0 = rf(ctx, accountId, scheduleId, opts, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_UpdateSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSchedule'
type MockInterface_UpdateSchedule_Call struct {
	*mock.Call
}

// UpdateSchedule is a helper method to define mock.On call
//   - ctx context.Context
//   - accountId string
//   - scheduleId string
//   - opts *client.ScheduleUpdateOptions
//   - logger *slog.Logger
func (_e *MockInterface_Expecter) UpdateSchedule(ctx interface{}, accountId interface{}, scheduleId interface{}, opts interface{}, logger interface{}) *MockInterface_UpdateSchedule_Call {
	return &MockInterface_UpdateSchedule_Call{Call: _e.mock.On("UpdateSchedule", ctx, accountId, scheduleId, opts, logger)}
}

func (_c *MockInterface_UpdateSchedule_Call) Run(run func(ctx context.Context, accountId string, scheduleId string, opts *client.ScheduleUpdateOptions, logger *slog.Logger)) *MockInterface_UpdateSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*client.ScheduleUpdateOptions), args[4].(*slog.Logger))
	})
	return _c
}

func (_c *MockInterface_UpdateSchedule_Call) Return(_a0 error) *MockInterface_UpdateSchedule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_UpdateSchedule_Call) RunAndReturn(run func(context.Context, string, string, *client.ScheduleUpdateOptions, *slog.Logger) error) *MockInterface_UpdateSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockInterface creates a new instance of MockInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInterface {
	mock := &MockInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
